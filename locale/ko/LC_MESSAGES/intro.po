# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Django 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-11-27 22:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: seungho, kim <raccoonyy@gmail.com>, 2016\n"
"Language-Team: Korean (https://www.transifex.com/sk8erchoi/teams/11579/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../intro/contributing.txt:3
msgid "Writing your first patch for Django"
msgstr "첫 Django 패치 작성하기"

#: ../../intro/contributing.txt:6
msgid "Introduction"
msgstr "개요"

#: ../../intro/contributing.txt:8
msgid ""
"Interested in giving back to the community a little? Maybe you've found a "
"bug in Django that you'd like to see fixed, or maybe there's a small feature"
" you want added."
msgstr "커뮤니티에 보답하고 싶은가요? 고치고 싶은 버그가 있거나, 추가하고 싶은 기능이 있을지도 모릅니다."

#: ../../intro/contributing.txt:12
msgid ""
"Contributing back to Django itself is the best way to see your own concerns "
"addressed. This may seem daunting at first, but it's really pretty simple. "
"We'll walk you through the entire process, so you can learn by example."
msgstr ""
"장고에 공헌하는 것이야말로 여러분의 관심을 드러내는 최선의 방법입니다. 처음에는 부담스러워 보일지도 모르지만, 아주아주 간단합니다. "
"우리는 전체 프로세스를 살펴볼 것이므로, 여러분은 예를 통해 배울 수 있습니다."

#: ../../intro/contributing.txt:17
msgid "Who's this tutorial for?"
msgstr "이 튜토리얼은 누구를 위한 것인가요?"

#: ../../intro/contributing.txt:21
msgid ""
"If you are looking for a reference on how to submit patches, see the "
":doc:`/internals/contributing/writing-code/submitting-patches` "
"documentation."
msgstr ""
"만약 여러분이 패치를 제출하는 방법에 대한 레퍼런스를 찾고 있다면, :doc:`/internals/contributing/writing-"
"code/submitting-patches` 문서를 보세요."

#: ../../intro/contributing.txt:25
msgid ""
"For this tutorial, we expect that you have at least a basic understanding of"
" how Django works. This means you should be comfortable going through the "
"existing tutorials on :doc:`writing your first Django "
"app</intro/tutorial01>`. In addition, you should have a good understanding "
"of Python itself. But if you don't, `Dive Into Python`__ is a fantastic (and"
" free) online book for beginning Python programmers."
msgstr ""
"이 튜토리얼을 진행하기 위해서는, Django 에 대한 기본적인 이해가 필요합니다. :doc:`첫번째 Django 앱 "
"작성해보기</intro/tutorial01>` 를 무난하게 따라할 정도면 됩니다. 또한, Python 대한 깊은 이해가 필요합니다만 "
"그렇지 않다면 `Dive Into Python`__ 은 파이선 초심자에게 훌륭한 교재가 될 것입니다."

#: ../../intro/contributing.txt:32
msgid ""
"Those of you who are unfamiliar with version control systems and Trac will "
"find that this tutorial and its links include just enough information to get"
" started. However, you'll probably want to read some more about these "
"different tools if you plan on contributing to Django regularly."
msgstr ""
"버전 관리 시스템과 Trac에 대해 잘 모르는 분은 이 튜토리얼과 튜토리얼에 포함된 링크를 통해 충분한 정보를 찾을 수 있을 것입니다. "
"하지만, 장고에 계속 공헌하고자 한다면 이러한 다른 도구들에 대하여 더 읽어두는 것도 좋을 것입니다."

#: ../../intro/contributing.txt:37
msgid ""
"For the most part though, this tutorial tries to explain as much as "
"possible, so that it can be of use to the widest audience."
msgstr "하지만 대부분의 경우, 이 튜토리얼은 폭넓은 독자에게 사용이 될 수 있도록 최대한 설명하려고 합니다."

#: ../../intro/contributing.txt:40 ../../intro/tutorial01.txt:35
msgid "Where to get help:"
msgstr "도움을 받을 수 있는 방법"

#: ../../intro/contributing.txt:42
msgid ""
"If you're having trouble going through this tutorial, please post a message "
"to |django-developers| or drop by `#django-dev on irc.freenode.net`__ to "
"chat with other Django users who might be able to help."
msgstr ""
"만약 튜토리얼을 진행하다가 문제가 생길 경우, |django-developers|에 메시지를 보내거나, irc.freenode.net 의"
" #django-dev를 통해서 다른 장고 유저들과 이야기를 해볼 수 있습니다. 혹시 이들이 도움을 줄지도 모릅니다."

#: ../../intro/contributing.txt:50
msgid "What does this tutorial cover?"
msgstr "이 튜토리얼이 다루는 내용은 무엇입니까?"

#: ../../intro/contributing.txt:52
msgid ""
"We'll be walking you through contributing a patch to Django for the first "
"time. By the end of this tutorial, you should have a basic understanding of "
"both the tools and the processes involved. Specifically, we'll be covering "
"the following:"
msgstr ""
"여기서는 여러분이 장고에 대한 패치를 처음 제출하는 과정을 다룹니다. 이 튜토리얼을 마치면, 여러분은 기본적인 관련 도구와 프로세스를 "
"모두 이해하게 될 것입니다. 좀더 구체적으로는 다음 내용을 다룹니다."

#: ../../intro/contributing.txt:56
msgid "Installing Git."
msgstr "GIT 설치"

#: ../../intro/contributing.txt:57
msgid "How to download a development copy of Django."
msgstr "장고의 개발 사본을 다운로드하는 방법."

#: ../../intro/contributing.txt:58
msgid "Running Django's test suite."
msgstr "장고의 테스트 스위트를 실행."

#: ../../intro/contributing.txt:59
msgid "Writing a test for your patch."
msgstr "패치에 대한 테스트를 작성."

#: ../../intro/contributing.txt:60
msgid "Writing the code for your patch."
msgstr "패치 코드를 작성."

#: ../../intro/contributing.txt:61
msgid "Testing your patch."
msgstr "패치를 테스트."

#: ../../intro/contributing.txt:62
msgid "Generating a patch file for your changes."
msgstr "변경 사항에 대한 패치 파일을 생성."

#: ../../intro/contributing.txt:63
msgid "Where to look for more information."
msgstr "더 많은 정보를 찾을 수 있는 곳."

#: ../../intro/contributing.txt:65
msgid ""
"Once you're done with the tutorial, you can look through the rest of "
":doc:`Django's documentation on "
"contributing</internals/contributing/index>`. It contains lots of great "
"information and is a must read for anyone who'd like to become a regular "
"contributor to Django. If you've got questions, it's probably got the "
"answers."
msgstr ""
"한번 튜토리얼을 마쳤다면, :doc:`Django 문서의 기여하기</internals/contributing/index>` 를 통해 "
"나머지를 볼 수 있습니다. 다양한 정보들이 있으며, 특히 Django 의 정규 기여자가 되고 싶다면 반드시 봐야 합니다. 궁금하신 점이 "
"있다면 답을 얻으실 수 있을 것입니다."

#: ../../intro/contributing.txt:71
msgid "Python 3 required!"
msgstr "파이썬 3.x 버전이 필요합니다."

#: ../../intro/contributing.txt:73
msgid ""
"This tutorial assumes you are using Python 3. Get the latest version at "
"`Python's download page <https://www.python.org/download/>`_ or with your "
"operating system's package manager."
msgstr ""
"이 튜토리얼은 Python 3 를 기준으로 작성되었습니다. `Python 다운로드 페이지 "
"<https://www.python.org/download/>`_ 나, 운영체제의 패키지 관리자를 통해 가장 최신 버전을 받으실 수 "
"있습니다."

#: ../../intro/contributing.txt:77 ../../intro/contributing.txt:99
#: ../../intro/contributing.txt:145 ../../intro/contributing.txt:181
msgid "For Windows users"
msgstr "윈도우 운영체제를 사용하는 경우"

#: ../../intro/contributing.txt:79
msgid ""
"When installing Python on Windows, make sure you check the option \"Add "
"python.exe to Path\", so that it is always available on the command line."
msgstr ""
"윈도우에서 Python 을 설치할 경우, 커맨드라인에서 사용하기 위해서는 반드시 **\"Add python.exe to Path\"** "
"옵션을 체크해야 합니다. "

#: ../../intro/contributing.txt:83
msgid "Code of Conduct"
msgstr "행동 지침"

#: ../../intro/contributing.txt:85
msgid ""
"As a contributor, you can help us keep the Django community open and "
"inclusive. Please read and follow our `Code of Conduct "
"<https://www.djangoproject.com/conduct/>`_."
msgstr ""
"당신은 기여자로서, 개방적이고 포괄적인 Django 커뮤니티를 유지하도록 도움을 줄 수 있습니다. `행동 강령 "
"<https://www.djangoproject.com/conduct/>`_ 을 읽고 숙지해주세요."

#: ../../intro/contributing.txt:89
msgid "Installing Git"
msgstr "GIT 설치"

#: ../../intro/contributing.txt:91
msgid ""
"For this tutorial, you'll need Git installed to download the current "
"development version of Django and to generate patch files for the changes "
"you make."
msgstr ""
"이 튜토리얼에서와 같이, 현재 개발 버전의 Django를 다운로드하고 수정하여 패치 파일을 생성하기 위해서는 Git을 설치해야 합니다."

#: ../../intro/contributing.txt:95
msgid ""
"To check whether or not you have Git installed, enter ``git`` into the "
"command line. If you get messages saying that this command could not be "
"found, you'll have to download and install it, see `Git's download page`__."
msgstr ""
"Git 이 설치되었는지 확인해보기 위해, 커맨드라인에서 ``git`` 라고 입력해보세요. 만약 그런 명령을 찾을 수 없다는 메세지가 "
"나오면 Git 이 설치되지 않았다는 의미입니다. `Git's download page`__ 를 참조하세요."

#: ../../intro/contributing.txt:101
msgid ""
"When installing Git on Windows, it is recommended that you pick the \"Git "
"Bash\" option so that Git runs in its own shell. This tutorial assumes "
"that's how you have installed it."
msgstr ""
"Git 을 윈도우에 설치할 경우, Git 이 자신의 쉘에서 동작하도록 \"Git Bash\" 옵션을 체크하는것을 권장합니다. 이 "
"튜토리얼은 해당 옵션이 체크 되어 있다고 가정합니다."

#: ../../intro/contributing.txt:105
msgid ""
"If you're not that familiar with Git, you can always find out more about its"
" commands (once it's installed) by typing ``git help`` into the command "
"line."
msgstr ""
"Git 을 사용하는것이 익숙하지 않다면, 커맨드라인 상에서 ``git help`` 를 입력 함으로써 명령어에 대한 자세한 정보를 확인할 "
"수 있습니다."

#: ../../intro/contributing.txt:111
msgid "Getting a copy of Django's development version"
msgstr "Django 개발 버전의 사본을 얻기"

#: ../../intro/contributing.txt:113
msgid ""
"The first step to contributing to Django is to get a copy of the source "
"code. First, `fork Django on GitHub <https://github.com/django/django#fork-"
"destination-box>`__. Then, from the command line, use the ``cd`` command to "
"navigate to the directory where you'll want your local copy of Django to "
"live."
msgstr ""
"Django에 공헌하는 첫 걸음은 소스 코드의 사본을 구하는 것입니다. 먼저 Github의 `Django 저장소 "
"<https://github.com/django/django#fork-destination-box> 를 포크`__하세요. 그리고 "
"명령행에서 ``cd`` 명령을 사용하여 로컬 사본 디렉터리로 이동하세요."

#: ../../intro/contributing.txt:118
msgid ""
"Download the Django source code repository using the following command:"
msgstr "다음 명령을 통해 Django 소스코드 저장소를 다운로드하십시오."

#: ../../intro/contributing.txt:124
msgid ""
"Now that you have a local copy of Django, you can install it just like you "
"would install any package using ``pip``. The most convenient way to do so is"
" by using a *virtual environment* (or virtualenv) which is a feature built "
"into Python that allows you to keep a separate directory of installed "
"packages for each of your projects so that they don't interfere with each "
"other."
msgstr ""
"이제, Django 의 복사본을 확보했습니다. 다른 패키지를 설치할 때처럼, ``pip`` 를 이용해 설치할 수 있습니다. 가장 간단한 "
"방법은 *가상 환경* (Virtualenv) 을 이용하는 것입니다. *Virtualenv* 는 프로젝트 별로 패키지가 설치된 개별 "
"디렉토리를 유지하여 서로 간섭하지 않도록 하는 Python 의 기능입니다. "

#: ../../intro/contributing.txt:130
msgid ""
"It's a good idea to keep all your virtualenvs in one place, for example in "
"``.virtualenvs/`` in your home directory. Create it if it doesn't exist yet:"
msgstr ""
"virtualenvs 환경들을 ``~/.virtualenvs/`` 같은 디렉토리에 몰아서 관리하는 것은 좋은 생각입니다. 아직 그런 "
"디렉토리가 없다면, 다음 명령어로 만들어 보세요."

#: ../../intro/contributing.txt:137
msgid "Now create a new virtualenv by running:"
msgstr "다음을 실행시켜서 새로운 가상 환경을 생성하십시오."

#: ../../intro/contributing.txt:143
msgid "The path is where the new environment will be saved on your computer."
msgstr "경로는 당신의 컴퓨터에서 새로운 환경이 저장될 위치를 의미합니다."

#: ../../intro/contributing.txt:147
msgid ""
"Using the built-in ``venv`` module will not work if you are also using the "
"Git Bash shell on Windows, since activation scripts are only created for the"
" system shell (``.bat``) and PowerShell (``.ps1``). Use the ``virtualenv`` "
"package instead:"
msgstr ""
"``venv`` 모듈은 윈도우의 Git Bash Shell 에서는 동작하지 않습니다. 이 모듈의 활성 스크립트가 system shell "
"(``.bat``) 과 PowerShell (``.ps1``) 에서만 생성되기 때문입니다. ``venv`` 대신 "
"``virtualenv`` 패키지를 사용하세요."

#: ../../intro/contributing.txt:157
msgid "For Ubuntu users"
msgstr "우분투 운영체제 사용자의 경우"

#: ../../intro/contributing.txt:159
msgid ""
"On some versions of Ubuntu the above command might fail. Use the "
"``virtualenv`` package instead, first making sure you have ``pip3``:"
msgstr ""
"몇몇 버전의 우분투 운영체제에서는 위 명령이 동작하지 않을 수 있습니다. 대신 ``virtualenv`` 패키지를 사용하시고, 그 전에 "
"``pip3``가 설치되었는지 확인하십시오."

#: ../../intro/contributing.txt:169
msgid "The final step in setting up your virtualenv is to activate it:"
msgstr "가상 환경 설정의 마지막 단계는 그것을 활성화시키는 것입니다."

#: ../../intro/contributing.txt:175
msgid ""
"If the ``source`` command is not available, you can try using a dot instead:"
msgstr "만약 ``source`` 명령을 사용할 수 없다면, 대신 마침표(.)를 사용해 보십시오."

#: ../../intro/contributing.txt:183
msgid "To activate your virtualenv on Windows, run:"
msgstr "윈도우 운영체제에서 가상 환경을 활성화시키기 위해서는 다음을 실행하십시오:"

#: ../../intro/contributing.txt:189
msgid ""
"You have to activate the virtualenv whenever you open a new terminal window."
" virtualenvwrapper__ is a useful tool for making this more convenient."
msgstr ""
"당신은 새로운 터미널 창을 열 때마다 가상환경을 실행시켜야 합니다. virtualenvwrapper__ 는 이것을 편리하게 만들어주는 "
"유용한 도구입니다."

#: ../../intro/contributing.txt:194
msgid ""
"Anything you install through ``pip`` from now on will be installed in your "
"new virtualenv, isolated from other environments and system-wide packages. "
"Also, the name of the currently activated virtualenv is displayed on the "
"command line to help you keep track of which one you are using. Go ahead and"
" install the previously cloned copy of Django:"
msgstr ""
"``pip`` 를 통해 설치하는 모든 패키지들은 다른 실행 환경과 격리되어, 현재 활성화된 virtualenv 환경에 설치됩니다. "
"활성화된 virtualenv 는 커맨드라인의 프롬프트에 표시되므로, 내가 어느 실행환경에 있는지 쉽게 알 수 있습니다. 계속해서, 아까 "
"내려받은 개발버전의 Django 를 설치해보겠습니다. "

#: ../../intro/contributing.txt:204
msgid ""
"The installed version of Django is now pointing at your local copy. You will"
" immediately see any changes you make to it, which is of great help when "
"writing your first patch."
msgstr ""
"현재 설치된 Django 는 당신이 내려받은 Django 의 복제본을 가르키고 있습니다. Django 를 수정하면 그 내역이 곧바로 "
"반영될 것이며, 패치를 작성할때 굉장히 큰 도움이 됩니다."

#: ../../intro/contributing.txt:209
msgid "Rolling back to a previous revision of Django"
msgstr "이전 리비전의  Django로 되돌리기"

#: ../../intro/contributing.txt:211
msgid ""
"For this tutorial, we'll be using ticket :ticket:`24788` as a case study, so"
" we'll rewind Django's version history in git to before that ticket's patch "
"was applied. This will allow us to go through all of the steps involved in "
"writing that patch from scratch, including running Django's test suite."
msgstr ""
"이 튜토리얼에서는, :ticket:`24788` 티켓으로 사례 연구를 해보겠습니다. git 에 저장된 Django 의 버전 이력을 "
"이용하여, 해당 티켓의 패치가 반영되기 이전 버전으로 돌아간 후, 이를 활용하여 처음부터 패치를 작성하고 테스트 스위트를 동작시키는 것을"
" 포함한 모든 과정을 함께 진행해 보겠습니다."

#: ../../intro/contributing.txt:216
msgid ""
"**Keep in mind that while we'll be using an older revision of Django's trunk"
" for the purposes of the tutorial below, you should always use the current "
"development revision of Django when working on your own patch for a "
"ticket!**"
msgstr ""
"**반드시 염두에 두어야 할 것은, 여기서 Django 의 옛날 버전을 사용하는 이유는 순전히 튜토리얼의 진행을 위해서 입니다. 티켓을 "
"위한 패치를 작성할 때는 반드시 가장 최근 버전의 Django 개발 코드를 사용해야 합니다.**"

#: ../../intro/contributing.txt:222
msgid ""
"The patch for this ticket was written by Paweł Marczewski, and it was "
"applied to Django as `commit 4df7e8483b2679fc1cba3410f08960bac6f51115`__. "
"Consequently, we'll be using the revision of Django just prior to that, "
"`commit 4ccfc4439a7add24f8db4ef3960d02ef8ae09887`__."
msgstr ""
"이 티켓을 위한 패치는 Paweł Marczewski 가 작성하였고, Django 에 `commit "
"4df7e8483b2679fc1cba3410f08960bac6f51115`__ 에 반영되었습니다. 따라서, 우리는 `commit "
"4df7e8483b2679fc1cba3410f08960bac6f51115`__ 의 바로 직전 버전을 사용할 것입니다."

#: ../../intro/contributing.txt:230
msgid ""
"Navigate into Django's root directory (that's the one that contains "
"``django``, ``docs``, ``tests``, ``AUTHORS``, etc.). You can then check out "
"the older revision of Django that we'll be using in the tutorial below:"
msgstr ""
"Django 의 루트 디렉토리로 이동합니다(``django``, ``docs``, ``tests``, ``AUTHORS``, 같은 "
"디렉토리가 포함된 위치입니다.). 여기서 다음 명령을 통해 튜토리얼에서 사용할 Django 의 예전 버전을 checkout 할 수 "
"있습니다."

#: ../../intro/contributing.txt:239
msgid "Running Django's test suite for the first time"
msgstr "Django의 테스트 스위트를 처음으로 실행하기"

#: ../../intro/contributing.txt:241
msgid ""
"When contributing to Django it's very important that your code changes don't"
" introduce bugs into other areas of Django. One way to check that Django "
"still works after you make your changes is by running Django's test suite. "
"If all the tests still pass, then you can be reasonably sure that your "
"changes haven't completely broken Django. If you've never run Django's test "
"suite before, it's a good idea to run it once beforehand just to get "
"familiar with what its output is supposed to look like."
msgstr ""
"Django 에 코드를 기여할 때 중요한 점은, 변경된 코드가 Django 의 다른 부분에서 버그를 일으키지 말아야 한다는 것입니다. "
"이를 확인하기 위해 Django 의 테스트 스위트를 실행시켜 Django 가 잘 동작하는지 알아볼 수 있습니다. 만약 테스트를 모두 통과"
" 했다면, 코드의 변경사항이 Django 를 망가뜨리지 않는다고 생각할 수 있습니다.혹시 그동안 한번도 Django 의 테스트 스위트를 "
"돌려본적이 없다면, 어떤 식으로 동작하는지 미리 봐두는 차원에서 한번 실행해 보는것도 좋습니다."

#: ../../intro/contributing.txt:249
msgid ""
"Before running the test suite, install its dependencies by first ``cd``-ing "
"into the Django ``tests/`` directory and then running:"
msgstr "Django ``tests/`` 디렉터리로 이동하여 의존 패키지를 설치하고 나서 테스트 스위트를 실행합니다."

#: ../../intro/contributing.txt:256
msgid ""
"If you encounter an error during the installation, your system might be "
"missing a dependency for one or more of the Python packages. Consult the "
"failing package's documentation or search the Web with the error message "
"that you encounter."
msgstr ""
"설치 중 에러가 발생했다면, 하나 이상의 Python 패키지에서 필요한 의존성을 해결하지 못한 것일 수 있습니다. 설치에 실패한 "
"Python 패키지의 문서를 살펴보거나 에러 메세지를 인터넷에서 검색해서 해결 방법을 찾아볼 수 있습니다."

#: ../../intro/contributing.txt:261
msgid ""
"Now we are ready to run the test suite. If you're using GNU/Linux, Mac OS X "
"or some other flavor of Unix, run:"
msgstr ""
"이제, 테스트 스위트를 돌릴 준비가 되었습니다. GNU/Linux, Mac OSX, 기타 UNIX 계열의 운영체제를 사용한다면 다음과 "
"같이 실행할 수 있습니다."

#: ../../intro/contributing.txt:268
msgid ""
"Now sit back and relax. Django's entire test suite has over 9,600 different "
"tests, so it can take anywhere from 5 to 15 minutes to run, depending on the"
" speed of your computer."
msgstr ""
"이제 9,600 개에 달하는 Django 의 전체 테스트 스위트가 끝날때까지 편히 기다리면 됩니다. 컴퓨터 사양에 따라 다르지만, 전체 "
"실행에 약 5분에서 15분 정도가 소비됩니다."

#: ../../intro/contributing.txt:272
msgid ""
"While Django's test suite is running, you'll see a stream of characters "
"representing the status of each test as it's run. ``E`` indicates that an "
"error was raised during a test, and ``F`` indicates that a test's assertions"
" failed. Both of these are considered to be test failures. Meanwhile, ``x`` "
"and ``s`` indicated expected failures and skipped tests, respectively. Dots "
"indicate passing tests."
msgstr ""
"Django 의 테스트 스위트가 동작하며, 화면에 각 테스트의 상태가 출력되는것을 볼 수 있습니다. ``E`` 는 테스트 도중 에러가 "
"발생했다는 것을 말해주며, ``F`` 는 테스트가 실패했다는 것을 말합니다. 이 두 가지 상태 모두 테스트가 실패했다고 생각할 수 "
"있습니다. 반면, ``x`` 는 실패할 것을 예상한 테스트이고 ``s`` 는 건너띈 테스트를 말합니다. 점(``.``) 은 그동안 통과한"
" 테스트를 말합니다."

#: ../../intro/contributing.txt:279
msgid ""
"Skipped tests are typically due to missing external libraries required to "
"run the test; see :ref:`running-unit-tests-dependencies` for a list of "
"dependencies and be sure to install any for tests related to the changes you"
" are making (we won't need any for this tutorial). Some tests are specific "
"to a particular database backend and will be skipped if not testing with "
"that backend. SQLite is the database backend for the default settings. To "
"run the tests using a different backend, see :ref:`running-unit-tests-"
"settings`."
msgstr ""
"건너띈 테스트는 보통 테스트를 수행하기 위해 필요한 외부 라이브러리가 없는 경우 발생합니다. :ref:`running-unit-"
"tests-dependencies` 를 참조하여, 변경과 관련한 모든 테스트를 수행하기 위한 의존성을 확인하고 이를 설치하십시요. 특정한"
" 데이터베이스 백엔드를 필요로 하는 테스트의 경우, 해당 데이터베이스 백엔드를 사용하지 않으면 자동으로 테스트를 건너 띕니다. "
"``SQLite`` 는 기본 데이터베이스 백엔드 입니다. 다른 백엔드를 테스트 하고 싶다면 :ref:`running-unit-tests-"
"settings` 를 참조하세요."

#: ../../intro/contributing.txt:287
msgid ""
"Once the tests complete, you should be greeted with a message informing you "
"whether the test suite passed or failed. Since you haven't yet made any "
"changes to Django's code, the entire test suite **should** pass. If you get "
"failures or errors make sure you've followed all of the previous steps "
"properly. See :ref:`running-unit-tests` for more information. If you're "
"using Python 3.5+, there will be a couple failures related to deprecation "
"warnings that you can ignore. These failures have since been fixed in "
"Django."
msgstr ""
"일단 테스트가 완료되면, 테스트 성공 여부를 알려주는 메세지가 반길 것입니다. 아직 Django 에 대한 어떤 수정도 하지 않았다면, "
"**반드시** 모든 테스트는 통과 되어야 합니다. 만약 실패나 에러가 발생했다면, 이전의 절차를 제대로 수행했는지 다시한번 확인해 "
"보세요. :ref:`running-unit-tests` 에서 더 자세히 알아볼 수 있습니다. 만약 Python 3.5 이상의 버전을 "
"사용한다면, 새로운 Python 에서 도태된(deprecate) 기능에 대한 테스트 실패가 발생할 수 있습니다. 그러나 이는 무시해도 "
"괜찮습니다. 이러한 에러는 새로운 Python 버전에서 탈락된 기존의 기능들을 Django 에서 사용하기 때문에 발생합니다. 이러한 "
"에러는 Django 의 다음 버전에서 수정될 것입니다."

#: ../../intro/contributing.txt:295
msgid ""
"Note that the latest Django trunk may not always be stable. When developing "
"against trunk, you can check `Django's continuous integration builds`__ to "
"determine if the failures are specific to your machine or if they are also "
"present in Django's official builds. If you click to view a particular "
"build, you can view the \"Configuration Matrix\" which shows failures broken"
" down by Python version and database backend."
msgstr ""
"가장 최근의 개발 코드를 보관하는 trunk 저장소는 끊임없이 코드가 변경되기 때문에 안정적이지 않을 수 있습니다. 만약 trunk "
"저장소를 기준으로 개발한다면, `Django's continuous integration builds`__ 에서 테스트 실패의 원인이 내"
" 개발환경에 있는지, 공식적인 빌드에서 실패한 것인지 알 수 있습니다. 특정 빌드를 클릭하여, \"Configuration "
"Matrix\" 항목을 확인하면 어떤 파이선 버전과 데이터베이스 백엔드에서 해당 빌드가 실패했는지 자세히 파악할 수 있습니다."

#: ../../intro/contributing.txt:306
msgid ""
"For this tutorial and the ticket we're working on, testing against SQLite is"
" sufficient, however, it's possible (and sometimes necessary) to :ref:`run "
"the tests using a different database <running-unit-tests-settings>`."
msgstr ""
"이 튜토리얼과 여러분이 작업하는 티켓에 대해서는 SQLite로 작업하는 것으로 충분하지만, :ref:`다른 데이터베이스에서 테스트를 수행"
" <running-unit-tests-settings>`\\ 하는 것이 가능합니다(때로는 필수적입니다)."

#: ../../intro/contributing.txt:312
msgid "Writing some tests for your ticket"
msgstr "티켓에 대한 테스트를 작성하기"

#: ../../intro/contributing.txt:314
msgid ""
"In most cases, for a patch to be accepted into Django it has to include "
"tests. For bug fix patches, this means writing a regression test to ensure "
"that the bug is never reintroduced into Django later on. A regression test "
"should be written in such a way that it will fail while the bug still exists"
" and pass once the bug has been fixed. For patches containing new features, "
"you'll need to include tests which ensure that the new features are working "
"correctly. They too should fail when the new feature is not present, and "
"then pass once it has been implemented."
msgstr ""
"대부분의 경우에, Django에 대한 패치를 접수할 때에는 테스트를 포함합니다. 버그 수정 패치의 경우, 이것은 그 버그가 나중에 "
"Django에서 다시 발생하지 않도록 회귀 테스트를 작성하는 것을 의미합니다. 회귀 테스트는 버그가 존재하는 동안 실패하다가 일단 버그가"
" 수정되면 통과하도록 작성하여야 합니다. 새로운 기능을 포함하는 패치의 경우 새로운 기능이 올바르게 작동하는지 확인하는 테스트를 포함해야"
" 합니다. 그러한 테스트들은 새로운 기능이 존재하지 않는 경우에는 실패하고, 구현이 되면 통과합니다."

#: ../../intro/contributing.txt:323
msgid ""
"A good way to do this is to write your new tests first, before making any "
"changes to the code. This style of development is called `test-driven "
"development`__ and can be applied to both entire projects and single "
"patches. After writing your tests, you then run them to make sure that they "
"do indeed fail (since you haven't fixed that bug or added that feature yet)."
" If your new tests don't fail, you'll need to fix them so that they do. "
"After all, a regression test that passes regardless of whether a bug is "
"present is not very helpful at preventing that bug from reoccurring down the"
" road."
msgstr ""
"이 작업을 수행하는 좋은 방법은 코드를 변경하기 전에, 먼저 새로운 테스트부터 작성하는 것입니다. 이러한 개발 스타일은 `test-"
"driven development`__\\ 이라고 불리우며, 낱개의 패치에서부터 전체 프로젝트에 이르기까지 적용이 가능합니다. 테스트를 "
"작성한 후에는 (당신이 버그를 수정하거나 아직이 기능을 추가하지 않았기 때문에) 그것들이 실제로 실패하는지 확인하기 위해 실행시켜보도록 "
"합니다. 새 테스트가 실패하지 않을 경우, 테스트가 실패하도록 수정해야합니다. 버그가 있든없든 통과하는 회귀 테스트라면 다시 발생하는 "
"버그를 방지하는 데에 그다지 도움이 되지 않습니다."

#: ../../intro/contributing.txt:332
msgid "Now for our hands-on example."
msgstr "이제 우리 예제를 살펴보도록 하겠습니다."

#: ../../intro/contributing.txt:337
msgid "Writing some tests for ticket #24788"
msgstr "티켓 #24788에 대한 테스트 작성하기"

#: ../../intro/contributing.txt:339
msgid ""
"Ticket :ticket:`24788` proposes a small feature addition: the ability to "
"specify the class level attribute ``prefix`` on Form classes, so that::"
msgstr ""
":ticket:`24788` 은 작은 기능 추가에 대한 다음과 같은 제안입니다: 클래스 레벨 속성 ``prefix``\\ 를 Form "
"클래스에 정의할수 있게해서 다음과같은 효과를 줍니다::"

#: ../../intro/contributing.txt:346
msgid ""
"In order to resolve this ticket, we'll add a ``prefix`` attribute to the "
"``BaseForm`` class. When creating instances of this class, passing a prefix "
"to the ``__init__()`` method will still set that prefix on the created "
"instance. But not passing a prefix (or passing ``None``) will use the class-"
"level prefix. Before we make those changes though, we're going to write a "
"couple tests to verify that our modification functions correctly and "
"continues to function correctly in the future."
msgstr ""
"이 티켓을 해결하기 위해서, 우리는 ``prefix`` 속성를 ``BaseForm`` 클래스에 추가할 것입니다. 이 클래스의 인스턴스가 "
"만들어질때, prefix를 ``__init__()`` 메소드에 전달하면 생성된 인스턴스에 prefix가 그대로 설정될것 입니다. 하지만 "
"prefix를 전달하지 않으면(혹은 ``None``\\ 을 전달하면) 클래스 레벨 prefix를 사용할것 입니다. 우리가 이 변경을 "
"만들기전에, 우리가 수정하는 기능들이 올바르게 동작하고 향후에도 올바르게 동작하는지를 검증하기위한 몇가지 테스트를 작성할것 입니다."

#: ../../intro/contributing.txt:354
msgid ""
"Navigate to Django's ``tests/forms_tests/tests/`` folder and open the "
"``test_forms.py`` file. Add the following code on line 1674 right before the"
" ``test_forms_with_null_boolean`` function::"
msgstr ""
"Django의 ``tests/forms_tests/tests/`` 폴더로 이동하여``test_forms.py`` 파일을 엽니다. 1674"
" 행의 다음과 같은 코드를 ``test_forms_with_null_boolean`` 함수 바로 앞에 추가합니다. ::"

#: ../../intro/contributing.txt:370
msgid ""
"This new test checks that setting a class level prefix works as expected, "
"and that passing a ``prefix`` parameter when creating an instance still "
"works too."
msgstr ""
"이 새 테스트는 클래스 레벨 prefix 설정이 예상대로 동작하는지, 인스턴스 생성 시 ``prefix`` 파라미터 전달이 잘되는 지를 "
"검사합니다."

#: ../../intro/contributing.txt:373
msgid "But this testing thing looks kinda hard..."
msgstr "하지만 테스팅이 어려워보입니다..."

#: ../../intro/contributing.txt:375
msgid ""
"If you've never had to deal with tests before, they can look a little hard "
"to write at first glance. Fortunately, testing is a *very* big subject in "
"computer programming, so there's lots of information out there:"
msgstr ""
"이전에 테스트를 한번도 다뤄보지 않았다면, 처음에는 작성하기에 까다로울 수도 있습니다. 다행히도, 테스트는 컴퓨터 프로그래밍에서 *매우*"
" 중요한 주제이기 때문에, 많은 정보를 얻을 수 있습니다."

#: ../../intro/contributing.txt:379
msgid ""
"A good first look at writing tests for Django can be found in the "
"documentation on :doc:`/topics/testing/overview`."
msgstr ""
"첫 Django 패치 작성하기의 좋은 예제는 :doc:`/topics/testing/overview` 에 있는 문서에서 찾을 수 "
"있습니다."

#: ../../intro/contributing.txt:381
msgid ""
"Dive Into Python (a free online book for beginning Python developers) "
"includes a great `introduction to Unit Testing`__."
msgstr ""
"Dive Into Python (초보 파이썬 개발자를 위한 무료 온라인북)에 훌륭한 `introduction to Unit "
"Testing`__\\ 이 있습니다."

#: ../../intro/contributing.txt:383
msgid ""
"After reading those, if you want something a little meatier to sink your "
"teeth into, there's always the Python :mod:`unittest` documentation."
msgstr ""
"그것들을 읽어본 후에, 좀 더 음미해보고 싶다면,`Python :mod:`unittest` documentation`\\를 읽어보기 "
"바랍니다."

#: ../../intro/contributing.txt:389
msgid "Running your new test"
msgstr "새 테스트를 수행하기"

#: ../../intro/contributing.txt:391
msgid ""
"Remember that we haven't actually made any modifications to ``BaseForm`` "
"yet, so our tests are going to fail. Let's run all the tests in the "
"``forms_tests`` folder to make sure that's really what happens. From the "
"command line, ``cd`` into the Django ``tests/`` directory and run:"
msgstr ""
"아직 ``BaseForm`` \\을 실제로 수정하지 않았으므로, 이 테스트는 실패할 것이라는 점을 기억하세요. "
"``forms_tests`` 폴더의 모든 테스트를 수행하여 정말 그렇게 되는지 확인해보도록 하겠습니다. 명령행에서 Django "
"``tests/`` 디렉토리로 ``cd`` 하여 다음과 같이 실행합니다:"

#: ../../intro/contributing.txt:400
msgid ""
"If the tests ran correctly, you should see one failure corresponding to the "
"test method we added. If all of the tests passed, then you'll want to make "
"sure that you added the new test shown above to the appropriate folder and "
"class."
msgstr ""
"테스트가 올바로 수행되면, 우리가 추가한 테스트 메소드와 관련된 실패 한개를 확인할 수 있을 것입니다. 모든 테스트가 성공했다면, 새로운"
" 테스트를 올바른 폴더와 클래스에 추가한 것인지 다시 확인해보시기 바랍니다."

#: ../../intro/contributing.txt:405
msgid "Writing the code for your ticket"
msgstr "티켓에 대한 코드를 작성하기"

#: ../../intro/contributing.txt:407
msgid ""
"Next we'll be adding the functionality described in ticket :ticket:`24788` "
"to Django."
msgstr "다음에는 :ticket:`24788`\\에서 기술한 기능을 Django에 추가해보도록 하겠습니다."

#: ../../intro/contributing.txt:411
msgid "Writing the code for ticket #24788"
msgstr "티켓 #24788에 대한 코드 작성하기"

#: ../../intro/contributing.txt:413
msgid ""
"Navigate to the ``django/django/forms/`` folder and open the ``forms.py`` "
"file. Find the ``BaseForm`` class on line 72 and add the ``prefix`` class "
"attribute right after the ``field_order`` attribute::"
msgstr ""
"``django/django/forms/`` 폴더로 이동하여 ``forms.py`` 파일을 여세요. 72행에서 ``BaseForm`` "
"클래스를 찾아  ``field_order`` 속성 이후에  ``prefix`` 클래스 속성를 추가하세요."

#: ../../intro/contributing.txt:426
msgid "Verifying your test now passes"
msgstr "테스트가 통과하는지 확인하기"

#: ../../intro/contributing.txt:428
msgid ""
"Once you're done modifying Django, we need to make sure that the tests we "
"wrote earlier pass, so we can see whether the code we wrote above is working"
" correctly. To run the tests in the ``forms_tests`` folder, ``cd`` into the "
"Django ``tests/`` directory and run:"
msgstr ""
"일단 Django에 대한 수정을 하였으면, 우리는 앞서 우리가 작성한 테스트가 통과하는지 확인함으로써, 우리가 위에서 작성한 코드가 "
"제대로 작동하는지 확인할 수 있습니다. ``forms_tests`` 폴더에서 테스트를 실행하려면, Django ``tests/`` "
"디렉토리로 ``cd``\\ 하여 다음과 같이 실행합니다:"

#: ../../intro/contributing.txt:437
msgid ""
"Oops, good thing we wrote those tests! You should still see one failure with"
" the following exception::"
msgstr "이런, 테스트를 작성해두길 잘 했군요! 여전히 다음과 같은 예외가 발생하여 한 건이 실패했습니다. ::"

#: ../../intro/contributing.txt:442
msgid ""
"We forgot to add the conditional statement in the ``__init__`` method. Go "
"ahead and change ``self.prefix = prefix`` that is now on line 87 of "
"``django/forms/forms.py``, adding a conditional statement::"
msgstr ""
" ``__init__`` 메소드안에 조건문을 추가하는 것을 잊었습니다. 계속해서 ``django/forms/forms.py``\\의 "
"87행에 조건문을 추가하여 ``self.prefix = prefix``\\를 수정합니다."

#: ../../intro/contributing.txt:449
msgid ""
"Re-run the tests and everything should pass. If it doesn't, make sure you "
"correctly modified the ``BaseForm`` class as shown above and copied the new "
"test correctly."
msgstr ""
"테스트를 재수행하면 모두 통과할 것입니다. 그렇지 않다면, ``BaseForm`` 클래스를 위와 같이 올바로 수정하였고 새로운 테스트를 "
"올바로 복사했는지 확인해보시기 바랍니다."

#: ../../intro/contributing.txt:454
msgid "Running Django's test suite for the second time"
msgstr "Django의 테스트 스위트를 두 번째로 실행하기"

#: ../../intro/contributing.txt:456
msgid ""
"Once you've verified that your patch and your test are working correctly, "
"it's a good idea to run the entire Django test suite just to verify that "
"your change hasn't introduced any bugs into other areas of Django. While "
"successfully passing the entire test suite doesn't guarantee your code is "
"bug free, it does help identify many bugs and regressions that might "
"otherwise go unnoticed."
msgstr ""
"패치와 태스트가 올바로 작동하는 것을 확인하였다면, 여러분이 변경한 부분이 Django의 다른 부분에 어떠한 버그를 만들어내지 않았는지 "
"확인하기 위해 전체 Django 테스트 스위트를 실행해보는 것이 좋습니다. 전체 테스트 스위트를 통과하였다고해서 버그가 없다고 확신할 "
"수는 없지만, 모르고 지나쳤을 수도 있는 많은 버그와 잘못을 찾아내는 데에 도움이 됩니다."

#: ../../intro/contributing.txt:462
msgid ""
"To run the entire Django test suite, ``cd`` into the Django ``tests/`` "
"directory and run:"
msgstr ""
"Django 테스트 스위트 전체를 실행하려면, Django ``tests/`` 디렉토리로 ``cd``\\ 하여 다음과 같이 실행합니다:"

#: ../../intro/contributing.txt:469
msgid "As long as you don't see any failures, you're good to go."
msgstr "실패를 한개도 보지 못했다면, 여러분은 잘하고 있는 것입니다."

#: ../../intro/contributing.txt:472
msgid "Writing Documentation"
msgstr "문서 작성하기"

#: ../../intro/contributing.txt:474
msgid ""
"This is a new feature, so it should be documented. Add the following section"
" on line 1068 (at the end of the file) of "
"``django/docs/ref/forms/api.txt``::"
msgstr ""
"이것은 새로운 기능이므로, 문서화를 해야합니다. ``django/docs/ref/forms/api.txt``\\의 1068행(파일의 "
"끝)에 다음 내용을 추가하세요::"

#: ../../intro/contributing.txt:487
msgid ""
"Since this new feature will be in an upcoming release it is also added to "
"the release notes for Django 1.9, on line 164 under the \"Forms\" section in"
" the file ``docs/releases/1.9.txt``::"
msgstr ""
"이 새 기능은 다음 배포본에 있을 것이므로  Django 1.9 릴리즈 노트  ``docs/releases/1.9.txt`` 파일  "
"\"Forms\" 섹션 아래 164행에도 추가됩니다:: "

#: ../../intro/contributing.txt:494
msgid ""
"For more information on writing documentation, including an explanation of "
"what the ``versionadded`` bit is all about, see "
":doc:`/internals/contributing/writing-documentation`. That page also "
"includes an explanation of how to build a copy of the documentation locally,"
" so you can preview the HTML that will be generated."
msgstr ""
"``versionadded``\\ 에 대한 설명을 포함하여, 문서 작성에 대한 자세한 내용은 "
":doc:`/internals/contributing/writing-documentation`\\ 을 참조하시기 바랍니다. 그 페이지에는"
" 문서의 사본을 로컬에서 빌드하여, 생성되는 HTML을 미리 살펴볼 수 있도록 하는 방법도 설명하고 있습니다."

#: ../../intro/contributing.txt:501
msgid "Generating a patch for your changes"
msgstr "변경사항에 대한 패치 파일을 생성하기"

#: ../../intro/contributing.txt:503
msgid ""
"Now it's time to generate a patch file that can be uploaded to Trac or "
"applied to another copy of Django. To get a look at the content of your "
"patch, run the following command:"
msgstr ""
"이제, Trac에 업로드 될 수 있거나, 다른 Django 복사본에 적용될 수 있는 패치파일을 만들 시간입니다. 패치의 내용을 살펴 "
"보려면, 다음 명령을 실행합니다:"

#: ../../intro/contributing.txt:511
msgid ""
"This will display the differences between your current copy of Django (with "
"your changes) and the revision that you initially checked out earlier in the"
" tutorial."
msgstr "위 명령은 여러분의 Django 복사본(내용을 수정한)과 이전 튜토리얼에서 체크아웃한 리비전 사이의 차이점을 보여줄 겁니다."

#: ../../intro/contributing.txt:515
msgid ""
"Once you're done looking at the patch, hit the ``q`` key to exit back to the"
" command line. If the patch's content looked okay, you can run the following"
" command to save the patch file to your current working directory:"
msgstr ""
"패치를 검토를 완료하면, 커맨트라인으로 돌아가기 위해 ``q`` 키를 누르십시오. 패치의 내용이 괜찮아 보였을 경우에는, 여러분은 현재 "
"작업 디렉토리에 패치 파일을 저장하기 위해  다음 명령을 실행할 수 있습니다:"

#: ../../intro/contributing.txt:523
msgid ""
"You should now have a file in the root Django directory called "
"``24788.diff``. This patch file contains all your changes and should look "
"this:"
msgstr ""
"여러분은 루트 Django 디렉토리에  ``24788.diff`` 라 불리는 파일 하나를 가지게 되었습니다. 이 패치 파일은 여러분이 "
"변경한 모든 것이 들어있고 아래와 같습니다."

#: ../../intro/contributing.txt:607
msgid "So what do I do next?"
msgstr "이제 뭘 해야 할까요?"

#: ../../intro/contributing.txt:609
msgid ""
"Congratulations, you've generated your very first Django patch! Now that "
"you've got that under your belt, you can put those skills to good use by "
"helping to improve Django's codebase. Generating patches and attaching them "
"to Trac tickets is useful, however, since we are using git - adopting a more"
" :doc:`git oriented workflow </internals/contributing/writing-code/working-"
"with-git>` is recommended."
msgstr ""
"축하합니다, 당신은 첫 번째 장고 패치를 생성했습니다! 지금 당신은 당신의 벨트 아래에, 당신은 장고의 코드베이스를 개선하는 데 도움으로"
" 잘 사용하는 기술을 습득했습니다. 패치를 생성하고 Trac에 티켓에 붙이는 것은 유용하지만, 우리는 git을 사용하므로  "
":doc:`git oriented workflow </internals/contributing/writing-code/working-"
"with-git>`\\ 를 추천합니다."

#: ../../intro/contributing.txt:616
msgid ""
"Since we never committed our changes locally, perform the following to get "
"your git branch back to a good starting point:"
msgstr ""
"우리는 변한내용들을 로컬에 커밋하지는 않을 것이므로, 여러분의 git 브렌치를 좋은 출발점으로 되돌리기위해 다음 내용을 수행하세요. "

#: ../../intro/contributing.txt:625
msgid "More information for new contributors"
msgstr "새로 오신 기여자분들을 위한 추가 정보"

#: ../../intro/contributing.txt:627
msgid ""
"Before you get too into writing patches for Django, there's a little more "
"information on contributing that you should probably take a look at:"
msgstr "Django 를 위한 패치를 작성하기 전에, 한번 꼭 보셔야 할 정보들이 있습니다. "

#: ../../intro/contributing.txt:630
msgid ""
"You should make sure to read Django's documentation on :doc:`claiming "
"tickets and submitting patches </internals/contributing/writing-code"
"/submitting-patches>`. It covers Trac etiquette, how to claim tickets for "
"yourself, expected coding style for patches, and many other important "
"details."
msgstr ""
"Django 문서 중, :doc:`티켓 생성과 패치 제출 </internals/contributing/writing-code"
"/submitting-patches>` 문서를 반드시 읽어보십시요. 이 문서는 Trac 사용 예절과, 직접 티켓을 생성하는 방법, 패치 "
"작성 시 지켜야 할 코딩 스타일과 다른 중요한 것들을 자세히 설명합니다."

#: ../../intro/contributing.txt:635
msgid ""
"First time contributors should also read Django's :doc:`documentation for "
"first time contributors</internals/contributing/new-contributors/>`. It has "
"lots of good advice for those of us who are new to helping out with Django."
msgstr ""
"기여가 처음이신 분들은 :doc:`첫 기여자를 위한 문서</internals/contributing/new-contributors/>` "
"를 읽어주십시요. Django 를 도와주시려는 분들을 위한 좋은 조언들이 가득합니다."

#: ../../intro/contributing.txt:639
msgid ""
"After those, if you're still hungry for more information about contributing,"
" you can always browse through the rest of :doc:`Django's documentation on "
"contributing</internals/contributing/index>`. It contains a ton of useful "
"information and should be your first source for answering any questions you "
"might have."
msgstr ""
"기여에 대한 정보가 이것으로 충분하지 않으시면, :doc:`Django 문서의 기여 "
"항목</internals/contributing/index>` 의 나머지를 흝어보세요. 엄청나게 많은 정보들이 있으며, 궁금하신 점들은 "
"여기서 제일 먼저 찾으셔야 합니다. "

#: ../../intro/contributing.txt:646
msgid "Finding your first real ticket"
msgstr "첫 번째 진짜 티켓을 찾기"

#: ../../intro/contributing.txt:648
msgid ""
"Once you've looked through some of that information, you'll be ready to go "
"out and find a ticket of your own to write a patch for. Pay special "
"attention to tickets with the \"easy pickings\" criterion. These tickets are"
" often much simpler in nature and are great for first time contributors. "
"Once you're familiar with contributing to Django, you can move on to writing"
" patches for more difficult and complicated tickets."
msgstr ""
"여기까지 흝어 보셨다면, 이제 직접 패치를 작성해볼 티켓을 찾아봅시다. \"easy pickings\" 제약이 걸린 티켓들을 주의깊게 "
"살펴 봅시다. 이 티켓들은 처리하기 쉬운편이라, 초보 기여자에게 적당합니다. 일단 Django 에 기여하는 과정에 익숙해지면, 조금 더 "
"복잡하고 어려운 티켓에 도전할 수 있습니다."

#: ../../intro/contributing.txt:655
msgid ""
"If you just want to get started already (and nobody would blame you!), try "
"taking a look at the list of `easy tickets that need patches`__ and the "
"`easy tickets that have patches which need improvement`__. If you're "
"familiar with writing tests, you can also look at the list of `easy tickets "
"that need tests`__. Just remember to follow the guidelines about claiming "
"tickets that were mentioned in the link to Django's documentation on "
":doc:`claiming tickets and submitting patches </internals/contributing"
"/writing-code/submitting-patches>`."
msgstr ""
"지금 당장 시작해보고 싶다면(눈치보지 않아도 돼요!), `easy tickets that need patches`__ 목록과 `easy "
"tickets that have patches which need improvement`__ 목록을 살펴보기 바랍니다. 테스트를 "
"작성하는데에 익숙하다면, `easy tickets that need tests`__ 도 살펴보세요. :doc:`티켓 생성과 패치 제출하기"
" </internals/contributing/writing-code/submitting-patches>` 에 설명된 티켓 생성에 대한 "
"지침을 잘 따르시기만 하면 됩니다."

#: ../../intro/contributing.txt:669 ../../intro/tutorial05.txt:669
#: ../../intro/tutorial07.txt:415
msgid "What's next?"
msgstr "다음 내용은?"

#: ../../intro/contributing.txt:671
msgid ""
"After a ticket has a patch, it needs to be reviewed by a second set of eyes."
" After uploading a patch or submitting a pull request, be sure to update the"
" ticket metadata by setting the flags on the ticket to say \"has patch\", "
"\"doesn't need tests\", etc, so others can find it for review. Contributing "
"doesn't necessarily always mean writing a patch from scratch. Reviewing "
"existing patches is also a very helpful contribution. See "
":doc:`/internals/contributing/triaging-tickets` for details."
msgstr ""
"티켓이 패치를 갖게 된 후에는, 다른 이들에게 검토를 받아야 합니다. 패치를 업로드하거나 pull 요청을 한 후에는, \"has "
"patch\", \"doesn't need tests\" 등 티켓에 대한 플래그를 설정함으로써 메타데이터를 수정하여, 다른 사람들이 "
"검토가 필요한 것을 찾을 수 있도록 해야 합니다. 공헌이라는 것은 패치를 처음부터 작성하는 것만을 의미하는 것이 아닙니다. 기존의 패치를"
" 검토하는 것도 큰 도움이 됩니다. :doc:`/internals/contributing/triaging-tickets`\\ 를 "
"참조하시기 바랍니다."

#: ../../intro/index.txt:3
msgid "Getting started"
msgstr "시작하기"

#: ../../intro/index.txt:5
msgid ""
"New to Django? Or to Web development in general? Well, you came to the right"
" place: read this material to quickly get up and running."
msgstr ""
"Django\\가 처음이세요? 일반적인 웹 개발이 처음이신가요? 좋아요, 여기 잘 오셨습니다: 빠르게 시작하기 위해 이 자료를 "
"읽어보세요."

#: ../../intro/index.txt:26
msgid ""
"If you're new to Python_, you might want to start by getting an idea of what"
" the language is like. Django is 100% Python, so if you've got minimal "
"comfort with Python you'll probably get a lot more out of Django."
msgstr ""
"Python_\\ 이 처음이라면, 그것이 어떤 언어인지 알아보고 싶을 것입니다. Django는 100% 파이썬으로 작성되었으므로, "
"파이썬에 대해 익숙하다면 Django에 대해서 보다 잘 알 수 있을 것입니다."

#: ../../intro/index.txt:30
msgid ""
"If you're new to programming entirely, you might want to start with this "
"`list of Python resources for non-programmers`_"
msgstr ""
"프로그래밍을 전혀 해보지 않았다면 `list of Python resources for non-programmers`_\\ 에서 "
"시작하시기를 권합니다."

#: ../../intro/index.txt:33
msgid ""
"If you already know a few other languages and want to get up to speed with "
"Python quickly, we recommend `Dive Into Python`_. If that's not quite your "
"style, there are many other `books about Python`_."
msgstr ""
"여러분이 몇가지 다른 언어를 알고 파이썬으로 빠르게 시작하길 원한다면, 우리는 `Dive Into Python`_ 을 추천합니다. 그 "
"책이 여러분의 스타일이 아니더라도, 다른 많은 `books about Python`_ 이 있습니다."

#: ../../intro/install.txt:3
msgid "Quick install guide"
msgstr "빠른 설치 가이드"

#: ../../intro/install.txt:5
msgid ""
"Before you can use Django, you'll need to get it installed. We have a "
":doc:`complete installation guide </topics/install>` that covers all the "
"possibilities; this guide will guide you to a simple, minimal installation "
"that'll work while you walk through the introduction."
msgstr ""
"여러분이 Django를 사용하기전에, 설치를 해야합니다. 우리는 모든 가능성을 다루는 :doc:`완전한 설치 안내 "
"</topics/install>` 를 가지고 있습니다; 여러분이 서론까지 진행하는동안 이 안내는 간단하고,  최소한의 설치법으로 안내할 "
"것입니다."

#: ../../intro/install.txt:11
msgid "Install Python"
msgstr "파이썬 설치하기"

#: ../../intro/install.txt:13
msgid ""
"Being a Python Web framework, Django requires Python. See :ref:`faq-python-"
"version-support` for details. Python includes a lightweight database called "
"SQLite_ so you won't need to set up a database just yet."
msgstr ""
"파이썬 웹 프레임워크이므로, Django는 파이썬이 필요합니다. 자세한 내용은 :ref:`faq-python-version-"
"support` 를 참조하세요. 파이썬은 SQLite_ 라 불리는 경량 데이터베이스를 가지고 있어서 여러분은 아직 데이터베이스를 설정할 "
"필요가 없습니다."

#: ../../intro/install.txt:19
msgid ""
"Get the latest version of Python at https://www.python.org/download/ or with"
" your operating system's package manager."
msgstr ""
"https://www.python.org/download/ 나 여러분의 운영체제 시스템의 패키지 관리자에서 파이썬 최신버전을 구하세요."

#: ../../intro/install.txt:22
msgid "Django on Jython"
msgstr "Jython 환경의 Django "

#: ../../intro/install.txt:24
msgid ""
"If you use Jython_ (a Python implementation for the Java platform), you'll "
"need to follow a few additional steps. See :doc:`/howto/jython` for details."
msgstr ""
"여러분이 Jython_ (자바 플래폼을 위한 파이썬 구현체)을 사용한다면, 몇가지 추가적인 단계를 따라야 합니다. 자세한 내용을 "
":doc:`/howto/jython` 를 참조하세요."

#: ../../intro/install.txt:29
msgid ""
"You can verify that Python is installed by typing ``python`` from your "
"shell; you should see something like::"
msgstr ""
"파이썬이 설치되었는지 확인하려면 Shell에서 ``python`` 이라고 입력하세요. 그러면 다음과 같은 문구가 나타날 겁니다::"

#: ../../intro/install.txt:38
msgid "Set up a database"
msgstr "데이터베이스 설정하기"

#: ../../intro/install.txt:40
msgid ""
"This step is only necessary if you'd like to work with a \"large\" database "
"engine like PostgreSQL, MySQL, or Oracle. To install such a database, "
"consult the :ref:`database installation information <database-"
"installation>`."
msgstr ""
"이 단계는 PostgreSQL 이나 MYSQL, Oracle과 같이 \"거대한\" 데이터베이스 엔진을 이용하여 작업할 때만 필요합니다. "
"그러한 데이터베이스를 설치하려면 :ref:`데이터베이스 설치정보 <database-installation>` 를 참고하세요."

#: ../../intro/install.txt:45
msgid "Remove any old versions of Django"
msgstr "이전 버전의 장고를 삭제"

#: ../../intro/install.txt:47
msgid ""
"If you are upgrading your installation of Django from a previous version, "
"you will need to :ref:`uninstall the old Django version before installing "
"the new version <removing-old-versions-of-django>`."
msgstr ""
"여러분이 이전 버전에서 Django를 업드레이드하고 있다면, :ref:`uninstall the old Django version "
"before installing the new version <removing-old-versions-of-django>` 을 "
"봐야합니다."

#: ../../intro/install.txt:52
msgid "Install Django"
msgstr "장고 설치하기"

#: ../../intro/install.txt:54
msgid "You've got three easy options to install Django:"
msgstr "세 가지 방법으로 장고를 설치할 수 있습니다."

#: ../../intro/install.txt:56
msgid ""
"Install a version of Django :doc:`provided by your operating system "
"distribution </misc/distributions>`. This is the quickest option for those "
"who have operating systems that distribute Django."
msgstr ""
":doc:`운영체제</misc/distributions>` 에서 제공하는 Django 를 설치하세요. 운영체제에서 Django 를 "
"제공한다면 이 방법이 가장 간편하고 빠릅니다. "

#: ../../intro/install.txt:60
msgid ""
":ref:`Install an official release <installing-official-release>`. This is "
"the best approach for most users."
msgstr "대부분의 유저들에게는 :ref:`공식 릴리즈 <installing-official-release>`를 추천합니다."

#: ../../intro/install.txt:63
msgid ""
":ref:`Install the latest development version <installing-development-"
"version>`. This option is for enthusiasts who want the latest-and-greatest "
"features and aren't afraid of running brand new code. You might encounter "
"new bugs in the development version, but reporting them helps the "
"development of Django. Also, releases of third-party packages are less "
"likely to be compatible with the development version than with the latest "
"stable release."
msgstr ""
":ref:`최신 개발 버전 설치하기 <installing-development-version>`. 이 옵션은 가장 최신 버전의 기능을 "
"사용하기 원하는 열정적이고 도전적인 사람들을 위한 옵션입니다. 개발 버전을 사용할 경우 예기치 못한 새로운 버그에 맞닥뜨릴수도 있습니다."
" 이런 버그들을 발견하실 경우 버그 리포팅을 통해 Django개발에 도움을 주실 수 있습니다. 또한, 3rd-party-패키지의 경우에는"
" 현재 Stable로 제공되는 릴리즈 버전보다는 호환성이 떨어질 수 있습니다."

#: ../../intro/install.txt:71
msgid ""
"Always refer to the documentation that corresponds to the version of Django "
"you're using!"
msgstr "현재 사용하는 버전의 공식문서를 참고하세요."

#: ../../intro/install.txt:74
msgid ""
"If you do either of the first two steps, keep an eye out for parts of the "
"documentation marked **new in development version**. That phrase flags "
"features that are only available in development versions of Django, and they"
" likely won't work with an official release."
msgstr ""
"여러분이 처음 두 단계중 하나를 실행한다면, 문서에서 **new in development version** 라고 표시된 부분을 주의해서"
" 보세요. 그 구문 플래그는 Django 개발 버전에서만 사용가능하고, 공식 릴리즈에서는 작동하지 않을것을 알려주는 기능을 합니다."

#: ../../intro/install.txt:81
msgid "Verifying"
msgstr "검토하기"

#: ../../intro/install.txt:83
msgid ""
"To verify that Django can be seen by Python, type ``python`` from your "
"shell. Then at the Python prompt, try to import Django:"
msgstr ""
"파이썬이 Djagno를 보여줄 수 있다는 것을 확인하기 위해서, 여러분의 쉘에서 ``python`` 이라고 입력하세요. 파이썬 "
"프롬프트에서 Django를 임포트 해보세요."

#: ../../intro/install.txt:92
msgid "You may have another version of Django installed."
msgstr "여러분은 다른 버전의 장고가 설치되어있을 수도 있습니다."

#: ../../intro/install.txt:95
msgid "That's it!"
msgstr "끝입니다!"

#: ../../intro/install.txt:97
msgid ""
"That's it -- you can now :doc:`move onto the tutorial </intro/tutorial01>`."
msgstr "이게 끝입니다. 이제, :doc:`튜토리얼 </intro/tutorial01>` 을 시작해보세요."

#: ../../intro/overview.txt:3
msgid "Django at a glance"
msgstr "Django 훑어보기"

#: ../../intro/overview.txt:5
msgid ""
"Because Django was developed in a fast-paced newsroom environment, it was "
"designed to make common Web-development tasks fast and easy. Here's an "
"informal overview of how to write a database-driven Web app with Django."
msgstr ""
"Django는 급한 분위기의 뉴스룸에서 개발되어서 보편적인 웹 개발 업무를 빠르고 쉽게 만들어주도록 설계되었습니다. 여기서는 "
"Django와 데이터 드리븐 웹 어플리케이션을 어떻게 작성하는지에 대한 개요를 보실수 있습니다."

#: ../../intro/overview.txt:9
msgid ""
"The goal of this document is to give you enough technical specifics to "
"understand how Django works, but this isn't intended to be a tutorial or "
"reference -- but we've got both! When you're ready to start a project, you "
"can :doc:`start with the tutorial </intro/tutorial01>` or :doc:`dive right "
"into more detailed documentation </topics/index>`."
msgstr ""
"이 문서의 목표는 Django가 어떻게 동작하는지 이해하는데 충분한 기술적 사항들을 알려주는데 있습니다. 하지만 튜토리얼이나 레퍼런스의 "
"역할을 의도하지는 않습니다 -- 물론 우리는 그 두가지를 다 가지고있죠! 프로젝트를 시작할 준비가 되었으면 :doc:`튜토리얼로 시작 "
"</intro/tutorial01>`\\ 하거나 :doc:`바로 좀더 자세한 문서로 뛰어들수 있습니다 </topics/index>`."

#: ../../intro/overview.txt:16
msgid "Design your model"
msgstr "모델 설계"

#: ../../intro/overview.txt:18
msgid ""
"Although you can use Django without a database, it comes with an `object-"
"relational mapper`_ in which you describe your database layout in Python "
"code."
msgstr ""
"설사 Django를 데이터베이스 없이 쓸수 있을 지라도 데이터베이스 레이아웃을 파이썬 코드로 표현할수있는 `object-"
"relational mapper`_\\ 가 같이 딸려 옵니다."

#: ../../intro/overview.txt:24
msgid ""
"The :doc:`data-model syntax </topics/db/models>` offers many rich ways of "
"representing your models -- so far, it's been solving many years' worth of "
"database-schema problems. Here's a quick example:"
msgstr ""
":doc:`data-model syntax </topics/db/models>`\\ 는 당신의 모델을 표현할 풍부한 방법을 제공해줍니다 "
"-- 이는 지금까지 수년간 데이터베이스 스키마 문제들을 해결하는데에 많은 도움을 주어왔습니다. 아래의 간단한 예제를 보시죠."

#: ../../intro/overview.txt:49
msgid "Install it"
msgstr "설치하기"

#: ../../intro/overview.txt:51
msgid ""
"Next, run the Django command-line utility to create the database tables "
"automatically:"
msgstr "다음으로 데이터베이스 테이블을 자동으로 생성하기위해서 Django 명령줄 유틸리티를 실행합니다."

#: ../../intro/overview.txt:58
msgid ""
"The :djadmin:`migrate` command looks at all your available models and "
"creates tables in your database for whichever tables don't already exist, as"
" well as optionally providing :doc:`much richer schema control "
"</topics/migrations>`."
msgstr ""
":djadmin:`migrate` 명령어는 가용한 모든 모델을 보고 데이터베이스에 아직 생성되지 않은 테이블을 만듭니다, 그뿐 아니라 "
":doc:`스키마 제어를 위한 좀더 풍부한 기능 </topics/migrations>`\\ 을 옵션으로 제공합니다."

#: ../../intro/overview.txt:63
msgid "Enjoy the free API"
msgstr "무료 API 즐기기"

#: ../../intro/overview.txt:65
msgid ""
"With that, you've got a free, and rich, :doc:`Python API "
"</topics/db/queries>` to access your data. The API is created on the fly, no"
" code generation necessary:"
msgstr ""
"여러분의 데이터에 접근하기 위한 무료의 풍성한 :doc:`Python API </topics/db/queries>`\\ 가 있습니다. "
"API는 즉석에서 만들어지며, 코드 생성이 필요하지 않습니다."

#: ../../intro/overview.txt:141
msgid ""
"A dynamic admin interface: it's not just scaffolding -- it's the whole house"
msgstr "동적인 관리자 인터페이스: 단순한 뼈대 세우기가 아닙니다 -- 이것은 완성된 집입니다"

#: ../../intro/overview.txt:143
msgid ""
"Once your models are defined, Django can automatically create a "
"professional, production ready :doc:`administrative interface "
"</ref/contrib/admin/index>` -- a website that lets authenticated users add, "
"change and delete objects. It's as easy as registering your model in the "
"admin site:"
msgstr ""
".일단 모델이 정의되었다면 Django는 전문적이고 바로 써먹을수 있는 :doc:`관리자 인터페이스 "
"</ref/contrib/admin/index>` -- 를 자동으로 만들수 있습니다 -- 관리자 인터페이스는 인증된 사용자가 개체를 "
"추가하고 변경하고 삭제할 수 있는 웹사이트입니다. 관리자 사이트에 모델 개체를 등록하는건 정말 쉽습니다:"

#: ../../intro/overview.txt:168
msgid ""
"The philosophy here is that your site is edited by a staff, or a client, or "
"maybe just you -- and you don't want to have to deal with creating backend "
"interfaces just to manage content."
msgstr ""
"운영자에 의해서나 고객, 혹은 단지 개발자 당신 스스로에 의해 수정될 수 있는 이 사이트는 다음과 같은 철학을 가지고 있습니다. -- "
"단지 컨텐츠를 관리하기위한 백엔드 인터페이스를 만드는 데에 힘을 쏟지 말자."

#: ../../intro/overview.txt:172
msgid ""
"One typical workflow in creating Django apps is to create models and get the"
" admin sites up and running as fast as possible, so your staff (or clients) "
"can start populating data. Then, develop the way data is presented to the "
"public."
msgstr ""
"Django 앱을 생성하는 하나의 전형적인 작업 흐름은 일단 모델을 만들고 관리자 사이트를 올려서 가능한 빨리 작동할 수 있게 만드는 "
"것입니다, 그래서 당신의 운영자(혹은 고객)이 데이터 입력을 시작할 수 있게 합니다. 그러면 밖으로 데이터를 표현하는 방법을 개발합니다."

#: ../../intro/overview.txt:177
msgid "Design your URLs"
msgstr "URL 설계"

#: ../../intro/overview.txt:179
msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality Web "
"application. Django encourages beautiful URL design and doesn't put any "
"cruft in URLs, like ``.php`` or ``.asp``."
msgstr ""
"깔끔하고 우아한 URL 계획은 고품질의 웹 어플리케이션에 매우 중요한 부분입니다. Django는 아름다운 URL 설계를 장려하며 URL에"
"  ``.php`` 나 ``.asp`` 같은 불필요한 내용들을 넣지 않습니다."

#: ../../intro/overview.txt:183
msgid ""
"To design URLs for an app, you create a Python module called a :doc:`URLconf"
" </topics/http/urls>`. A table of contents for your app, it contains a "
"simple mapping between URL patterns and Python callback functions. URLconfs "
"also serve to decouple URLs from Python code."
msgstr ""
"앱을 위한 URL을 설계하기 위해서  :doc:`URLconf</topics/http/urls>` 파이썬 모듈을 생성해야 합니다. 이것은"
" URL패턴과 파이선 콜백 함수 간의 간단한 매핑 정보를 담고 있는 여러분의 앱에 대한 목차입니다. URLconf는 또한 파이썬 코드와 "
"URL간의 결합도를 낮춰줍니다."

#: ../../intro/overview.txt:188
msgid ""
"Here's what a URLconf might look like for the ``Reporter``/``Article`` "
"example above:"
msgstr "아래의 코드는 위의 ``Reporter``/``Article``  예제에 대해서 URLconf를 어떻게 쓰는지 보여줍니다:"

#: ../../intro/overview.txt:204
msgid ""
"The code above maps URLs, as simple :ref:`regular expressions <regex-"
"howto>`, to the location of Python callback functions (\"views\"). The "
"regular expressions use parenthesis to \"capture\" values from the URLs. "
"When a user requests a page, Django runs through each pattern, in order, and"
" stops at the first one that matches the requested URL. (If none of them "
"matches, Django calls a special-case 404 view.) This is blazingly fast, "
"because the regular expressions are compiled at load time."
msgstr ""
"위 코드는 간단한  :ref:`정규표현식 <regex-howto>` 으로 작성된 URL들을 파이썬 콜백 함수들 (\"views\")로 "
"연결해줍니다. 정규표현식들은 URL에서 값을 \"가져오기\" 위해 괄호를 사용합니다. 사용자가 페이지를 요청하면, 장고는 순서대로 각 "
"패턴을 실행하고, 요청된 URL과 일치하는 첫번째 패턴을 만나면 정지합니다.(일치하는 패턴이 없으면, 장고는 특수한 보기인 404 뷰를 "
"호출합니다.) 정규표현식들은 로드할 때 컴파일되어 있기 때문에 엄청나게 빠릅니다."

#: ../../intro/overview.txt:212
msgid ""
"Once one of the regexes matches, Django imports and calls the given view, "
"which is a simple Python function. Each view gets passed a request object --"
" which contains request metadata -- and the values captured in the regex."
msgstr ""
"한번 정규 표현식 하나가 매치되면 Django는 간단한 파이썬 함수인 view를 import하고 호출 합니다. 각 view는 "
"request object -- 각 요청에 대한 메타 데이터를 담고 있는 -- 와 정규표현식으로 URL로 부터 포착한 값을 전달 받게 "
"됩니다."

#: ../../intro/overview.txt:216
msgid ""
"For example, if a user requested the URL \"/articles/2005/05/39323/\", "
"Django would call the function ``news.views.article_detail(request, '2005', "
"'05', '39323')``."
msgstr ""
"예를 들어 사용자가 URL \"/articles/2005/05/39323/\"로 요청을 보냅니다, 그러면 Django는 다음처럼 함수를 호출하게 됩니다. ``news.views.article_detail(request,\n"
"'2005', '05', '39323')``"

#: ../../intro/overview.txt:221
msgid "Write your views"
msgstr "뷰를 작성합니다"

#: ../../intro/overview.txt:223
msgid ""
"Each view is responsible for doing one of two things: Returning an "
":class:`~django.http.HttpResponse` object containing the content for the "
"requested page, or raising an exception such as "
":class:`~django.http.Http404`. The rest is up to you."
msgstr ""
"각각의 뷰는 다음의 두가지 중에 하나를 수행할 책임이 있습니다.:\n"
"요청된 페이지의 내용을 담고 있는 :class:`~django.http.HttpResponse` 객체를 반환 하거나, :class:`~django.http.Http404`\\ 와 같은 예외를 발생시키는 것 입니다.\n"
"나머지는 여러분에게 달려있습니다."

#: ../../intro/overview.txt:228
msgid ""
"Generally, a view retrieves data according to the parameters, loads a "
"template and renders the template with the retrieved data. Here's an example"
" view for ``year_archive`` from above:"
msgstr ""
"일반적으로 뷰는 파라미터들에 따라 데이터를 가져오며 템플릿을 로드하고 템플릿을 가져온 데이타로 렌더링합니다. 아래는 위에서 만든 ``year_archive``\\에 대한 예제 뷰입니다:\n"
"\n"
"::"

#: ../../intro/overview.txt:244
msgid ""
"This example uses Django's :doc:`template system </topics/templates>`, which"
" has several powerful features but strives to stay simple enough for non-"
"programmers to use."
msgstr ""
"이 예제는 Django의 :doc:`template system </topics/templates>`\\ 을 사용합니다. Djago "
"템플릿 시스템은 몇몇 강력한 기능들을 가지고 있지만 프로그래머가 아닌 사람도 사용하기에 어렵지 않도록 간결함을 유지하도록 노력하였습니다."

#: ../../intro/overview.txt:249
msgid "Design your templates"
msgstr "여러분만의 템플릿 작성"

#: ../../intro/overview.txt:251
msgid "The code above loads the ``news/year_archive.html`` template."
msgstr "위의 코드는 ``news/year_archive.html`` 템플릿을 로드합니다."

#: ../../intro/overview.txt:253
msgid ""
"Django has a template search path, which allows you to minimize redundancy "
"among templates. In your Django settings, you specify a list of directories "
"to check for templates with :setting:`DIRS <TEMPLATES-DIRS>`. If a template "
"doesn't exist in the first directory, it checks the second, and so on."
msgstr ""
"장고는 여러분이 템플릿들중 중복을 최소화할 수 있게 하는 템플릿 검색 경로를 가지고 있습니다. 여러분의 장소 셋팅에 "
":setting:`DIRS <TEMPLATES-DIRS>` 템플릿을 확인하기 위한 디렉토리의 목록을 명시합니다.  만약 첫번째 디렉토리에"
" 템플릿이 존재하지 않으면, 두번째 디렉토리, 그 외 디렉토리를 점검합니다."

#: ../../intro/overview.txt:258
msgid ""
"Let's say the ``news/year_archive.html`` template was found. Here's what "
"that might look like:"
msgstr "``news/year_archive.html`` 템플릿을 발견했다고 합시다.  아마도 이런 모양일 것입니다:"

#: ../../intro/overview.txt:278
msgid ""
"Variables are surrounded by double-curly braces. ``{{ article.headline }}`` "
"means \"Output the value of the article's headline attribute.\" But dots "
"aren't used only for attribute lookup. They also can do dictionary-key "
"lookup, index lookup and function calls."
msgstr ""
"변수는 이중 중괄호로 둘러싸입니다. ``{{ article.headline }}`` 의 뜻은 “article의 headline 속성의 "
"값을 출력하겠다.” 입니다. 하지만 마침표가 속성의 조회에만 사용되는것은 아닙니다. 점은 사전의 키 조회에도 사용될수 있으며 인덱스 "
"조회와 함수 호출에도 사용될 수 있습니다."

#: ../../intro/overview.txt:283
msgid ""
"Note ``{{ article.pub_date|date:\"F j, Y\" }}`` uses a Unix-style \"pipe\" "
"(the \"|\" character). This is called a template filter, and it's a way to "
"filter the value of a variable. In this case, the date filter formats a "
"Python datetime object in the given format (as found in PHP's date "
"function)."
msgstr ""
"참고로 ``{{ article.pub_date|date:\"F j, Y\" }}``\\ 는 유닉스 스타일의 “파이프”(“|” 문자)를 "
"사용한것입니다. 이 파이프는 템플릿 필터를 호출하며 이를 통해 변수의 값을 필터링 할 수 있습니다. 이 코드에서 date 필터는 파이썬의"
" datetime 개체를 지정한 포맷으로 변환 시킵니다.(PHP의 date 함수처럼 말이죠, 네 PHP 의 좋은 아이디어 중에 "
"하나입니다.)"

#: ../../intro/overview.txt:288
msgid ""
"You can chain together as many filters as you'd like. You can write "
":ref:`custom template filters <howto-writing-custom-template-filters>`. You "
"can write :doc:`custom template tags </howto/custom-template-tags>`, which "
"run custom Python code behind the scenes."
msgstr ""
"여러분은 좋아하는 여러 필터들을 함께 연결할 수 있습니다. 여러분은 :ref:`커스텀 템플릿 필터 <howto-writing-"
"custom-template-filters>` 를 작성할 수 있습니다. 여러분은 은밀하게 실행되는 커스텀 파이썬 코드인 :doc:`커스텀"
" 템플릿 태그 </howto/custom-template-tags>` 를 작성할 수도 있습니다. "

#: ../../intro/overview.txt:293
msgid ""
"Finally, Django uses the concept of \"template inheritance\". That's what "
"the ``{% extends \"base.html\" %}`` does. It means \"First load the template"
" called 'base', which has defined a bunch of blocks, and fill the blocks "
"with the following blocks.\" In short, that lets you dramatically cut down "
"on redundancy in templates: each template has to define only what's unique "
"to that template."
msgstr ""
"이제 마지막으로 Django의 “템플릿 상속” 개념을 사용해 보죠. 이를 통해 ``{% extends \"base.html\" %}`` "
"코드가 무슨 일을 하는지 알 수 있습니다. 이 코드의 의미는 ” 한 뭉치의 block들이 정의된 ‘base’라는 템플릿을 먼저 로드하고 "
"뒤따르는 block들로 이 block들을 채운다는것” 입니다. 간단히 말해 템플릿안의 중복을 극적으로 낮추게 합니다. 각각의 템플릿은 "
"자신이 표현하려는 내용들만 정의할수 있게 되기 때문입니다."

#: ../../intro/overview.txt:299
msgid ""
"Here's what the \"base.html\" template, including the use of :doc:`static "
"files </howto/static-files/index>`, might look like:"
msgstr ""
"“base.html” 템플릿은 :doc:`static files </howto/static-files/index>`\\ 의 사용을 "
"포함하여, 다음과 같이 채워져 있을 것입니다."

#: ../../intro/overview.txt:316
msgid ""
"Simplistically, it defines the look-and-feel of the site (with the site's "
"logo), and provides \"holes\" for child templates to fill. This makes a site"
" redesign as easy as changing a single file -- the base template."
msgstr ""
"간단하게 사이트의 룩앤필(사이트의 로고)을 정의하고 자식 템플릿이 내용을 채워넣을 “구멍”들을 제공합니다. 이러한 방식은 사이트의 디자인"
" 변경을 ‘base’ 템플릿 파일 하나를 바꾸는 것 같이 쉬운 방법으로 가능하게 해줍니다."

#: ../../intro/overview.txt:320
msgid ""
"It also lets you create multiple versions of a site, with different base "
"templates, while reusing child templates. Django's creators have used this "
"technique to create strikingly different mobile versions of sites -- simply "
"by creating a new base template."
msgstr ""
"또한 자식 템플릿을 재활용해서 서로 다른 base 템플릿으로 여러 버전의 사이트를 만들수 있게 합니다. Django의 제작자는 이러한 "
"테크닉으로 완전히 다른 모바일 버전의 사이트를 만들었습니다. 간단히 새로운 base 템플릿을 만드는것으로 말이죠."

#: ../../intro/overview.txt:325
msgid ""
"Note that you don't have to use Django's template system if you prefer "
"another system. While Django's template system is particularly well-"
"integrated with Django's model layer, nothing forces you to use it. For that"
" matter, you don't have to use Django's database API, either. You can use "
"another database abstraction layer, you can read XML files, you can read "
"files off disk, or anything you want. Each piece of Django -- models, views,"
" templates -- is decoupled from the next."
msgstr ""
"여러분이 선호하는 템플릿 시스템이 있다면 꼭 Django의 템플릿 시스템을 사용할 필요는 없습니다. Django의 템플릿 시스템은 "
"Django의 모델계층과 매우 잘 통합되어 있지만 꼭 이를 사용하도록 강제하는 것은 아닙니다. 이러한 이유들로 Django의 "
"database API 역시 반드시 써야할 필요는 없습니다. 여러분은 다른 데이터베이스 추상화 계층을 사용할수 있으며 XML 파일이나 "
"디스크에서 다른파일을 사용하거나 여러분이 원하는 다른 여러가지 방식으로 사용할수도 있습니다. 각각의 Django 구성요소들 -- 모델, "
"뷰, 템플릿 -- 은 서로 결합도가 낮게 되어있습니다."

#: ../../intro/overview.txt:334
msgid "This is just the surface"
msgstr "이건 단지 껍데기일 뿐"

#: ../../intro/overview.txt:336
msgid ""
"This has been only a quick overview of Django's functionality. Some more "
"useful features:"
msgstr "이건 Django의 기능에 대한 간략한 개요에 불과합니다. 다음과 같이 좀 더 유용한 기능들도 많습니다."

#: ../../intro/overview.txt:339
msgid ""
"A :doc:`caching framework </topics/cache>` that integrates with memcached or"
" other backends."
msgstr "memached나 기타 백엔드와 통합된 :doc:`캐시 프레임워크 </topics/cache>`."

#: ../../intro/overview.txt:342
msgid ""
"A :doc:`syndication framework </ref/contrib/syndication>` that makes "
"creating RSS and Atom feeds as easy as writing a small Python class."
msgstr ""
"파이썬 클래스를 약간 작성하는 것만으로 RSS와 Atom 피드를 쉽게 만들어주는 :doc:`신디케이션 프레임워크 "
"</ref/contrib/syndication>`."

#: ../../intro/overview.txt:345
msgid ""
"More sexy automatically-generated admin features -- this overview barely "
"scratched the surface."
msgstr "아주 매력적인 자동 생성 관리자 기능 -- 이 개요문서는 맛보기일 뿐입니다."

#: ../../intro/overview.txt:348
msgid ""
"The next obvious steps are for you to `download Django`_, read :doc:`the "
"tutorial </intro/tutorial01>` and join `the community`_. Thanks for your "
"interest!"
msgstr ""
"여러분이 앞으로 거쳐갈 단계는 `download Django`_, :doc:`튜토리얼 </intro/tutorial01>`\\ 을 읽고 "
"`the community`_\\ 에 참여하는 것입니다. 여러분의 관심에 감사드립니다."

#: ../../intro/reusable-apps.txt:3
msgid "Advanced tutorial: How to write reusable apps"
msgstr "심화 튜토리얼: 재사용 가능한 앱을 만드는 법"

#: ../../intro/reusable-apps.txt:5
msgid ""
"This advanced tutorial begins where :doc:`Tutorial 7 </intro/tutorial07>` "
"left off. We'll be turning our Web-poll into a standalone Python package you"
" can reuse in new projects and share with other people."
msgstr ""
"이 심화 튜토리얼은 :doc:`Tutorial 7 </intro/tutorial07>`\\ 의 완료 지점에서 시작합니다. 우리를 이제 "
"우리의 Web-poll을 새 프로젝트에서 재사용하거나 다른사람들과 공유할수있는 독립적인 파이썬 패키지로 만들것입니다."

#: ../../intro/reusable-apps.txt:9
msgid ""
"If you haven't recently completed Tutorials 1–7, we encourage you to review "
"these so that your example project matches the one described below."
msgstr ""
"아직 튜토리얼 1-7을 완료하지 않았다면 이를 리뷰해서 당신의 예제 프로젝트가 아래에 설명하는것과 일치되도록 하기를 권장합니다."

#: ../../intro/reusable-apps.txt:13
msgid "Reusability matters"
msgstr "재사용성의 문제들"

#: ../../intro/reusable-apps.txt:15
msgid ""
"It's a lot of work to design, build, test and maintain a web application. "
"Many Python and Django projects share common problems. Wouldn't it be great "
"if we could save some of this repeated work?"
msgstr ""
"웹 어플리케이션을 설계, 빌드, 테스트와 관리는 꽤나 큰 일입니다. 많은 파이썬 그리고 Django 프로젝트들은 공통의 문제를 "
"공유합니다. 만약 우리가 이 반복적인 작업들중에서 몇몇을 구해낼수 있다면 정말 멋지지 않을까요?"

#: ../../intro/reusable-apps.txt:19
msgid ""
"Reusability is the way of life in Python. `The Python Package Index (PyPI) "
"<https://pypi.python.org/pypi>`_ has a vast range of packages you can use in"
" your own Python programs. Check out `Django Packages "
"<https://www.djangopackages.com>`_ for existing reusable apps you could "
"incorporate in your project. Django itself is also just a Python package. "
"This means that you can take existing Python packages or Django apps and "
"compose them into your own web project. You only need to write the parts "
"that make your project unique."
msgstr ""
"파이썬에서 재사용성은 생활의 방식입니다. `The Python Package Index (PyPI) "
"<https://pypi.python.org/pypi>`_ 에 있는 방대한 패키지들을 여러분의 파이썬 프로그램들에 사용할 수 있습니다. "
"여러분의 프로젝트에 사용할 수 있는 재사용가능한 앱들을  `Django Packages "
"<https://www.djangopackages.com>`_ 에서 확인해보세요. 여러분이 기존의 파이썬 패키지들이나 Django 앱들을"
" 사용할 수 있고, 그것들은 여러분의 웹 프로젝트에 결합할 수도 있습니다. 여러분 프로젝트의 고유한 기능만 작성하면 됩니다. "

#: ../../intro/reusable-apps.txt:28
msgid ""
"Let's say you were starting a new project that needed a polls app like the "
"one we've been working on. How do you make this app reusable? Luckily, "
"you're well on the way already. In :doc:`Tutorial 3 </intro/tutorial03>`, we"
" saw how we could decouple polls from the project-level URLconf using an "
"``include``. In this tutorial, we'll take further steps to make the app easy"
" to use in new projects and ready to publish for others to install and use."
msgstr ""
"이제 우리가 작업했던 것과 같은 설문 조사 앱이 필요하여 새로운 프로젝트를 시작했다고 가정해봅시다. 어떻게 이 앱을 재사용할 수 있게 "
"만들 수 있을까요? 운 좋게도, 여러분은 이미 방법을 알고 있습니다. :doc:`Tutorial 3 </intro/tutorial03>`"
" 에서, 우리는 ``include``를 이용하여 프로젝트 수준의 URLconf에서 설문조사를 분리하는 방법을 봤습니다. 이 "
"튜토리얼에서는, 새로운 프로젝트에서 사용하기 쉬운 앱을 만들기 위해, 설치하고 사용할 다른 사람들을 위해 게시할 준비를 하기 위해 "
"추가적인 작업을 할 것입니다. "

#: ../../intro/reusable-apps.txt:35
msgid "Package? App?"
msgstr "패키지? 앱?"

#: ../../intro/reusable-apps.txt:37
msgid ""
"A Python :term:`package` provides a way of grouping related Python code for "
"easy reuse. A package contains one or more files of Python code (also known "
"as \"modules\")."
msgstr ""
"Python :term:`package` 는 쉽게 재사용하기 위해 연관된 Python 코드를 묶어놓은 것입니다. package 는 "
"Python 코드가 들어있는 하나 이상의 파일들이 포함되어  있으며, 이를 \"module\" 이라고도 합니다. "

#: ../../intro/reusable-apps.txt:41
msgid ""
"A package can be imported with ``import foo.bar`` or ``from foo import "
"bar``. For a directory (like ``polls``) to form a package, it must contain a"
" special file ``__init__.py``, even if this file is empty."
msgstr ""
"``import foo.bar`` 나 ``from foo import bar``로 패키지를 import 할 수 있습니다. "
"디렉토리(``polls``와 같은)는 패키지를 형성하기 위해, 특별한 파일 ``__init__.py``를 포함하고 있습니다, 그 파일이 "
"빈파일일 경우에도 포함하고 있습니다."

#: ../../intro/reusable-apps.txt:45
msgid ""
"A Django *application* is just a Python package that is specifically "
"intended for use in a Django project. An application may use common Django "
"conventions, such as having ``models``, ``tests``, ``urls``, and ``views`` "
"submodules."
msgstr ""
"Django *애플리케이션*은 Django 프로젝트에 사용하기 위한 파이썬 패키지일 뿐입니다. 애플리케이션은 ``models``, "
"``tests``, ``urls``, ``views`` 서브모듈들을 포함하고 있는 공통적인 Django 규칙을 이요할 수 있습니다."

#: ../../intro/reusable-apps.txt:50
msgid ""
"Later on we use the term *packaging* to describe the process of making a "
"Python package easy for others to install. It can be a little confusing, we "
"know."
msgstr ""
"나중에 우리는 다른사람들이 쉽게 파이썬 패키지를 설치하는 과정을 설명하기 위해  *패키징* 기능을 사용할 것입니다. 조금 혼란스러울 수도"
" 있습니다."

#: ../../intro/reusable-apps.txt:55
msgid "Your project and your reusable app"
msgstr "프로젝트와 재사용가능한 앱"

#: ../../intro/reusable-apps.txt:57
msgid "After the previous tutorials, our project should look like this::"
msgstr "이전 프로젝트를 마치면, 프로젝트는 아래와 같을 것입니다::"

#: ../../intro/reusable-apps.txt:90
msgid ""
"You created ``mysite/templates`` in :doc:`Tutorial 7 </intro/tutorial07>`, "
"and ``polls/templates`` in :doc:`Tutorial 3 </intro/tutorial03>`. Now "
"perhaps it is clearer why we chose to have separate template directories for"
" the project and application: everything that is part of the polls "
"application is in ``polls``. It makes the application self-contained and "
"easier to drop into a new project."
msgstr ""
"여러분은 :doc:`튜토리얼 7 </intro/tutorial07>` 에서 ``mysite/templates``  나 "
":doc:`Tutorial 3 </intro/tutorial03>` 에서 ``polls/templates``  를 생성하였습니다. 이제 "
"프로젝트와 어플리케이션으로 분리한 이유가 명확합니다. ``polls`` 어플리케이션의 부분들은 ``polls``에 모두 있습니다.  It"
" makes the application self-contained and easier to drop into a new project."

#: ../../intro/reusable-apps.txt:97
msgid ""
"The ``polls`` directory could now be copied into a new Django project and "
"immediately reused. It's not quite ready to be published though. For that, "
"we need to package the app to make it easy for others to install."
msgstr ""
"``polls`` 디렉토리가 이제 새 Django 프로젝트로 복사되었고, 바로 재사용할 수 있습니다. 그래도 게시 할 준비가 되지 "
"않았습니다. 이를 위해, 다른 사람들이 쉽게 설치할 수 있도록 앱을 패키지화해야합니다."

#: ../../intro/reusable-apps.txt:104
msgid "Installing some prerequisites"
msgstr "필수 구성 요소 설치"

#: ../../intro/reusable-apps.txt:106
msgid ""
"The current state of Python packaging is a bit muddled with various tools. "
"For this tutorial, we're going to use setuptools_ to build our package. It's"
" the recommended packaging tool (merged with the ``distribute`` fork). We'll"
" also be using `pip`_ to install and uninstall it. You should install these "
"two packages now. If you need help, you can refer to :ref:`how to install "
"Django with pip<installing-official-release>`. You can install "
"``setuptools`` the same way."
msgstr ""
"파이썬 패키징의 현재상태는 다양한 도구들로 인해 약간 혼란스럽습니다. 이 튜토리얼에서, 우리의 패키지를 빌드하는데 setuptools_ "
"를 사용할 것입니다. 권장 패키징 도구(``distribute`` 포크와 병합된)입니다. 설치하고 재설치하는데 `pip`_ 를 사용할 "
"수도 있습니다. 이제 이 두 패키지들을 설치해야합니다. 도움이 필요하면 :ref:`pip로 Django 설치하는 법<installing-"
"official-release>` 을 참조할 수 있습니다. 같은 방법으로 ``setuptools`` 도 설치할 수 있습니다."

#: ../../intro/reusable-apps.txt:118
msgid "Packaging your app"
msgstr "앱 패키징하기"

#: ../../intro/reusable-apps.txt:120
msgid ""
"Python *packaging* refers to preparing your app in a specific format that "
"can be easily installed and used. Django itself is packaged very much like "
"this. For a small app like polls, this process isn't too difficult."
msgstr ""
"파이썬 *패키징* 은 쉽게 설치하고 사용할 수 있는 특별한 형식으로 앱을 준비하는 것을 의미합니다. 장고 자체도 이와 같이 패키지화되어 "
"있습니다. 설문조사처럼 작은 앱은 이 과정이 어렵지 않습니다."

#: ../../intro/reusable-apps.txt:124
msgid ""
"First, create a parent directory for ``polls``, outside of your Django "
"project. Call this directory ``django-polls``."
msgstr ""
"먼저, Django 프로젝트 외부에 ``polls`` 의 상위 디렉토리를 만듭니다. 이 디렉토리를 ``django-polls``라 "
"부르겠습니다."

#: ../../intro/reusable-apps.txt:127
msgid "Choosing a name for your app"
msgstr "앱 이름 선택"

#: ../../intro/reusable-apps.txt:129
msgid ""
"When choosing a name for your package, check resources like PyPI to avoid "
"naming conflicts with existing packages. It's often useful to prepend "
"``django-`` to your module name when creating a package to distribute. This "
"helps others looking for Django apps identify your app as Django specific."
msgstr ""
"패키지 이름을 선택할 때, 기존 패키지들과 충돌을 피하기 위해 PyPI 같은 리소스들을 점검하세요.  배포할 패키지를 생성할 때, 모듈 "
"이름 앞에 ``django-`` 를 앞에 붙이는 것이 좋습니다. 이러면 Django 앱을 찾는 다른 사용자가 여러분의 앱을 Django "
"고유 앱으로 인식하는데 도움이 됩니다."

#: ../../intro/reusable-apps.txt:135
msgid ""
"Application labels (that is, the final part of the dotted path to "
"application packages) *must* be unique in :setting:`INSTALLED_APPS`. Avoid "
"using the same label as any of the Django :doc:`contrib packages "
"</ref/contrib/index>`, for example ``auth``, ``admin``, or ``messages``."
msgstr ""
"애플리케이션 라벨들(즉, 애플리케이션 패키지들의 경로의 가장 마지막부분)은   :setting:`INSTALLED_APPS` 에서 "
"*고유해야합니다* . ``auth``, ``admin``, or ``messages``  같은 Django :doc:`contrib "
"packages </ref/contrib/index>` 와 같은 라벨을 사용하지 마세요. "

#: ../../intro/reusable-apps.txt:141
msgid "Move the ``polls`` directory into the ``django-polls`` directory."
msgstr "``django-polls`` 디렉토리의 ``polls`` 디렉토리로 이동하세요. "

#: ../../intro/reusable-apps.txt:143
msgid "Create a file ``django-polls/README.rst`` with the following contents:"
msgstr "다음과 같은 내용으로 ``django-polls/README.rst``를 생성합니다:"

#: ../../intro/reusable-apps.txt:178
msgid ""
"Create a ``django-polls/LICENSE`` file. Choosing a license is beyond the "
"scope of this tutorial, but suffice it to say that code released publicly "
"without a license is *useless*. Django and many Django-compatible apps are "
"distributed under the BSD license; however, you're free to pick your own "
"license. Just be aware that your licensing choice will affect who is able to"
" use your code."
msgstr ""
"``django-polls/LICENSE`` 파일을 생성합니다. 라이선스 선택은 이 튜토리얼의 범위를 벗어나므로, 라이선스 없이 공개된 "
"코드는 *쓸모없음* 을 의미한다는 것만 말해두겠습니다.  Django와 많은 Django 호환 앱들이 BSD 라이센스로 배포되고 "
"있습니다; 그러나 자신의 라이센스를 자유롭게 선택할 수 있습니다. 라이선스 선택이 누군가 여러분의 코드를 사용하는데 영향이 미칠수 있다는"
" 사실은 알고 있어야합니다."

#: ../../intro/reusable-apps.txt:185
msgid ""
"Next we'll create a ``setup.py`` file which provides details about how to "
"build and install the app.  A full explanation of this file is beyond the "
"scope of this tutorial, but the `setuptools docs "
"<https://setuptools.readthedocs.io/en/latest/>`_ have a good explanation. "
"Create a file ``django-polls/setup.py`` with the following contents:"
msgstr ""
"다음에, 우리는 앱을 빌드하고 설치하는 방법에 대한 세부 사항을 제공하는 ``setup.py`` 파일을 생성 할 것입니다. 이 파일에 "
"대한 전체적인 설명은 이 튜토리얼의 범위에서 벗어나지만, `setuptools 문서 "
"<https://setuptools.readthedocs.io/en/latest/>`_ 에 좋은 설명이 입습니다. 다음 내용으로  "
"``django-polls/setup.py`` 파일을 만드세요."

#: ../../intro/reusable-apps.txt:232
msgid ""
"Only Python modules and packages are included in the package by default. To "
"include additional files, we'll need to create a ``MANIFEST.in`` file. The "
"setuptools docs referred to in the previous step discuss this file in more "
"details. To include the templates, the ``README.rst`` and our ``LICENSE`` "
"file, create a file ``django-polls/MANIFEST.in`` with the following "
"contents:"
msgstr ""
"기본적으로 파이썬 모듈들과 패키지들만 패키지에 포함되어 있습니다. 추가 파일을 포함 시키기위해선 ``MANIFEST.in`` 파일을 "
"만들어야합니다. 이전 단계에서 나온 setuptools 문서에 이 파일에 대해 자세한 설명이 있습니다. 템플릿들, "
"``README.rst`` , 우리의 ``LICENSE`` 파일을 포함 시키려면, 다음 내용으로 ``django-"
"polls/MANIFEST.in`` 파일을 만듭니다."

#: ../../intro/reusable-apps.txt:247
msgid ""
"It's optional, but recommended, to include detailed documentation with your "
"app. Create an empty directory ``django-polls/docs`` for future "
"documentation. Add an additional line to ``django-polls/MANIFEST.in``::"
msgstr ""
"선택사항입니다만, 자세한 문서를 포함시키는 것을 추천합니다. 장래의 문서들을 위해 ``django-polls/docs`` 라는 빈 "
"디렉토리를 생성합니다. ``django-polls/MANIFEST.in`` 에 다음 한줄을 추가합니다::"

#: ../../intro/reusable-apps.txt:253
msgid ""
"Note that the ``docs`` directory won't be included in your package unless "
"you add some files to it. Many Django apps also provide their documentation "
"online through sites like `readthedocs.org <https://readthedocs.org>`_."
msgstr ""
"파일을 추가하지 않으면 ``docs`` 디렉토리는 패키지에 포함되지 않을 것입니다. 많은 Django 앱들이 "
"`readthedocs.org <https://readthedocs.org>`_ 같은 사이트들을 통해 온라인 문서를 제공합니다. "

#: ../../intro/reusable-apps.txt:257
msgid ""
"Try building your package with ``python setup.py sdist`` (run from inside "
"``django-polls``). This creates a directory called ``dist`` and builds your "
"new package, ``django-polls-0.1.tar.gz``."
msgstr ""
"``python setup.py sdist`` 로 패키지를 빌드해보세요 (``django-polls`` 내에서 실행). 이 명령은 "
"``dist`` 디렉토리를 생성하고, 새 패키지  ``django-polls-0.1.tar.gz`` 를 빌드합니다. "

#: ../../intro/reusable-apps.txt:261
msgid ""
"For more information on packaging, see Python's `Tutorial on Packaging and "
"Distributing Projects "
"<https://packaging.python.org/en/latest/distributing.html>`_."
msgstr ""
"패키징에 관한 더 많은 정보는, Python's `Tutorial on Packaging and Distributing Projects "
"<https://packaging.python.org/en/latest/distributing.html>`_ 에 있습니다."

#: ../../intro/reusable-apps.txt:265
msgid "Using your own package"
msgstr "여러분의 패키지 사용하기"

#: ../../intro/reusable-apps.txt:267
msgid ""
"Since we moved the ``polls`` directory out of the project, it's no longer "
"working. We'll now fix this by installing our new ``django-polls`` package."
msgstr ""
"우리가 ``polls`` 디렉토리를 프로젝트 바깥으로 이동했으므로, 작동하지 않을것입니다. 우리의 새 ``django-polls`` "
"패키지를 설치하여 이 문제를 해결할 것입니다."

#: ../../intro/reusable-apps.txt:270
msgid "Installing as a user library"
msgstr "유저 라이브러리 설치하기"

#: ../../intro/reusable-apps.txt:272
msgid ""
"The following steps install ``django-polls`` as a user library. Per-user "
"installs have a lot of advantages over installing the package system-wide, "
"such as being usable on systems where you don't have administrator access as"
" well as preventing the package from affecting system services and other "
"users of the machine."
msgstr ""
"다음 단계는 ``django-polls`` 를 사용자 라이브러리로 설치합니다. 사용자 단위 설치는  관리자권한 접근이 안되는 시스템 "
"뿐만아니라 시스템 서비스나 다른 사용자들의 영향으로부터 패키지를 보호하는 것 같은 이점이 많습니다."

#: ../../intro/reusable-apps.txt:278
msgid ""
"Note that per-user installations can still affect the behavior of system "
"tools that run as that user, so ``virtualenv`` is a more robust solution "
"(see below)."
msgstr ""
"사용자 단위 설치는 해당 사용자로 실행되는 시스템 도구들의 동작에 영향을 미칠 수 있으므로, ``virtualenv`` 가 보다 강력한 "
"솔루션입니다 (아래 참조)."

#: ../../intro/reusable-apps.txt:282
msgid ""
"To install the package, use pip (you already :ref:`installed it <installing-"
"reusable-apps-prerequisites>`, right?)::"
msgstr ""
"pip를 이용하여 패키지를 설치하세요(여러분은  이미 :ref:`설치 하였습니다<installing-reusable-apps-"
"prerequisites>`, 맞죠?)::"

#: ../../intro/reusable-apps.txt:287
msgid ""
"With luck, your Django project should now work correctly again. Run the "
"server again to confirm this."
msgstr "운이 따라준다면, 여러분의 Django 프로젝트는 이제 잘 작동할 것입니다. 확인해보기위해 서버를 다시 실행하세요."

#: ../../intro/reusable-apps.txt:290
msgid "To uninstall the package, use pip::"
msgstr "pip를 사용해 패키지를 삭제"

#: ../../intro/reusable-apps.txt:297
msgid "Publishing your app"
msgstr "앱 퍼블리싱"

#: ../../intro/reusable-apps.txt:299
msgid ""
"Now that we've packaged and tested ``django-polls``, it's ready to share "
"with the world! If this wasn't just an example, you could now:"
msgstr ""
"우리는 ``django-polls`` 를 패키지화하고 테스트했기에, 세계와 공유할 준비가 되었습니다. 단순한 예제가 아니면, 여러분은 "
"이제 아래와 같은 것들을 할 수 있습니다:"

#: ../../intro/reusable-apps.txt:302
msgid "Email the package to a friend."
msgstr "친구에게 패키지를 이메일로 보내기"

#: ../../intro/reusable-apps.txt:304
msgid "Upload the package on your website."
msgstr "웹사이트에 패키지 업로드"

#: ../../intro/reusable-apps.txt:306
msgid ""
"Post the package on a public repository, such as `the Python Package Index "
"(PyPI)`_. `packaging.python.org <https://packaging.python.org>`_ has `a good"
" tutorial <https://packaging.python.org/en/latest/distributing.html"
"#uploading-your-project-to-pypi>`_ for doing this."
msgstr ""
"`the Python Package Index (PyPI)`_ 같은 공개 저장소에 패키지 등록하기. 등록할 때 참고하기 `좋은 튜토리얼 "
"<https://packaging.python.org/en/latest/distributing.html#uploading-your-"
"project-to-pypi>`_ 이 `packaging.python.org <https://packaging.python.org>`_ "
"에 있습니다."

#: ../../intro/reusable-apps.txt:312
msgid "Installing Python packages with virtualenv"
msgstr "virtualenv를 이용한 파이썬 패키지 설치하기"

#: ../../intro/reusable-apps.txt:314
msgid ""
"Earlier, we installed the polls app as a user library. This has some "
"disadvantages:"
msgstr "앞에서, 우리는 설문 조사 앱을 사용자 라이브러리로 설치했습니다. 여기에는 몇 가지 단점이 있습니다:"

#: ../../intro/reusable-apps.txt:317
msgid ""
"Modifying the user libraries can affect other Python software on your "
"system."
msgstr "사용자 라이브러리를 수정하면 시스템의 다른 파이썬 소프트웨어에 영향을 미칠 수 있습니다."

#: ../../intro/reusable-apps.txt:319
msgid ""
"You won't be able to run multiple versions of this package (or others with "
"the same name)."
msgstr "이 패키지의 여러 버전 (또는 이름이 같은 다른 버전)을 실행할 수 없습니다."

#: ../../intro/reusable-apps.txt:322
msgid ""
"Typically, these situations only arise once you're maintaining several "
"Django projects. When they do, the best solution is to use `virtualenv "
"<http://www.virtualenv.org/>`_. This tool allows you to maintain multiple "
"isolated Python environments, each with its own copy of the libraries and "
"package namespace."
msgstr ""
"일반적으로 이런 현상은 Django 프로젝트를 여럿 다룰 때만 발생합니다. 이때 가장 좋은 해결책은 `virtualenv "
"<http://www.virtualenv.org/>`_ 입니다. 이 도구를 사용하면 파이썬의 라이브러리와 패키지 네임스페이스를 각 환경에"
" 따라 별도로 관리할 수 있습니다."

#: ../../intro/tutorial01.txt:3
msgid "Writing your first Django app, part 1"
msgstr "첫 번째 장고 앱 작성하기, part 1"

#: ../../intro/tutorial01.txt:5
msgid "Let's learn by example."
msgstr "예제로 배워봅시다."

#: ../../intro/tutorial01.txt:7
msgid ""
"Throughout this tutorial, we'll walk you through the creation of a basic "
"poll application."
msgstr "이 튜토리얼을 통해, 간단한 투표(Polls) 어플리케이션을 만드는 과정을 따라해 보겠습니다."

#: ../../intro/tutorial01.txt:10
msgid "It'll consist of two parts:"
msgstr "두 파트로 구성되어 있습니다."

#: ../../intro/tutorial01.txt:12
msgid "A public site that lets people view polls and vote in them."
msgstr "사람들이 투표 내용을 보고 직접 투표할 수 있는 개방된 사이트"

#: ../../intro/tutorial01.txt:13
msgid "An admin site that lets you add, change, and delete polls."
msgstr "관리자가 투표를 추가, 변경, 삭제할 수 있는 관리용 사이트"

#: ../../intro/tutorial01.txt:15
msgid ""
"We'll assume you have :doc:`Django installed </intro/install>` already. You "
"can tell Django is installed and which version by running the following "
"command:"
msgstr ""
"이미 :doc:`Django 설치 </intro/install>` 를 살펴보았다고 가정하겠습니다. 다음 명령을 통해 어떤 버전의 "
"Django 가 설치되었는지 확인할 수 있습니다."

#: ../../intro/tutorial01.txt:22
msgid ""
"If Django is installed, you should see the version of your installation. If "
"it isn't, you'll get an error telling \"No module named django\"."
msgstr ""
"Django 가 설치 되었다면, 설치된 Django 의 버전을 확인할 수 있습니다. 만약 설치가 제대로 되지 않았다면, \"No "
"module named django\" 과 같은 에러가 발생합니다."

#: ../../intro/tutorial01.txt:25
msgid ""
"This tutorial is written for Django |version| and Python 3.4 or later. If "
"the Django version doesn't match, you can refer to the tutorial for your "
"version of Django by using the version switcher at the bottom right corner "
"of this page, or update Django to the newest version. If you are still using"
" Python 2.7, you will need to adjust the code samples slightly, as described"
" in comments."
msgstr ""
"이 튜토리얼은 Django |version| 과 Python 3.4 혹은 그 이후의 버전을 기준으로 작성되었습니다. 만약 Django "
"버전이 맞지 않으면, Django 버전을 업데이트 하여 진행하시거나, 우측 하단의 버전 링크를 통해 자신의 버전에 맞는 튜토리얼을 참고할"
" 수 있습니다. 만약 아직 Python 2.7 를 사용한다면, 코드가 조금 수정되어야 합니다. 이 부분은 코멘트를 통해 설명하겠습니다."

#: ../../intro/tutorial01.txt:32
msgid ""
"See :doc:`How to install Django </topics/install>` for advice on how to "
"remove older versions of Django and install a newer one."
msgstr ""
"예전 버전의 Django 를 제거하고, 새로운 버전의 Django 를 설치하는 방법은 :doc:`Django 설치하기 "
"</topics/install>` 에서 알 수 있습니다."

#: ../../intro/tutorial01.txt:37
msgid ""
"If you're having trouble going through this tutorial, please post a message "
"to |django-users| or drop by `#django on irc.freenode.net "
"<irc://irc.freenode.net/django>`_ to chat with other Django users who might "
"be able to help."
msgstr ""
"이 튜토리얼을 진행하다 막혔을 경우, |django-users| 에 글을 올리거나, `irc.freenode.net 의 #django "
"채널 <irc://irc.freenode.net/django>`_ 에 글을 남겨주세요. 다른 Django 사용자들이 도움을 줄 수 있을지"
" 모릅니다."

#: ../../intro/tutorial01.txt:43
msgid "Creating a project"
msgstr "프로젝트 만들기"

#: ../../intro/tutorial01.txt:45
msgid ""
"If this is your first time using Django, you'll have to take care of some "
"initial setup. Namely, you'll need to auto-generate some code that "
"establishes a Django :term:`project` -- a collection of settings for an "
"instance of Django, including database configuration, Django-specific "
"options and application-specific settings."
msgstr ""
"Django를 처음 사용한다면, 초기 설정에서 주의를 기울여야 합니다. 즉, Django :term:`project` 를 구성하는 코드를"
" 자동 생성해야 하는데, 이 과정에서 데이터베이스 설정, Django 위한 옵션들, 어플리케이션을 위한 설정들과 같은 Django "
"인스턴스를 구성하는 수많은 설정들이 생성되기 때문입니다."

#: ../../intro/tutorial01.txt:51
msgid ""
"From the command line, ``cd`` into a directory where you'd like to store "
"your code, then run the following command:"
msgstr "커맨드라인에서 ``cd`` 명령으로 코드를 저장할 디렉토리로 이동 한 후, 다음의 명령을 수행합니다."

#: ../../intro/tutorial01.txt:58
msgid ""
"This will create a ``mysite`` directory in your current directory. If it "
"didn't work, see :ref:`troubleshooting-django-admin`."
msgstr ""
"이 명령은 현재 디렉토리에서 ``mysite`` 라는 디렉토리를 생성할 것입니다. 만약 이 명령이 동작하지 않는다면, :ref"
":`troubleshooting-django-admin` 를 확인하세요"

#: ../../intro/tutorial01.txt:63
msgid ""
"You'll need to avoid naming projects after built-in Python or Django "
"components. In particular, this means you should avoid using names like "
"``django`` (which will conflict with Django itself) or ``test`` (which "
"conflicts with a built-in Python package)."
msgstr ""
"project 를 생성할 때, Python 이나 Django 에서 사용중인 이름은 피해야 합니다. 특히, ``django`` "
"(Django 그 자체와 충돌이 일어납니다) 나, ``test`` (Python 패키지의 이름중 하나입니다) 같은 이름은 피해야 한다는 "
"의미입니다."

#: ../../intro/tutorial01.txt:68
msgid "Where should this code live?"
msgstr "코드가 어디에서 서비스 되어야 할까요?"

#: ../../intro/tutorial01.txt:70
msgid ""
"If your background is in plain old PHP (with no use of modern frameworks), "
"you're probably used to putting code under the Web server's document root "
"(in a place such as ``/var/www``). With Django, you don't do that. It's not "
"a good idea to put any of this Python code within your Web server's document"
" root, because it risks the possibility that people may be able to view your"
" code over the Web. That's not good for security."
msgstr ""
"과거의 PHP 를 작성해본 경험이 있다면(최근의 프레임워크 말고) 아마 코드 전체를 ``/var/www`` 같은 웹 서버의 "
"DocumentRoot 에 넣으려고 하려고 할겁니다. Django 에서는 그러지 마십시요. 파이선 코드가 웹서버의 DocumentRoot"
" 에 존재하는것은 좋은 생각이 아닙니다. 웹을 통해서 외부의 사람들이 Python 코드를 직접 열어볼 수 있는 위험이 있기 때문입니다. "
"그렇게 되면 보안에 별로 좋지 않습니다."

#: ../../intro/tutorial01.txt:77
msgid ""
"Put your code in some directory **outside** of the document root, such as "
":file:`/home/mycode`."
msgstr "작성한 코드를 :file:`/home/mycode` 와 같은 DocumentRoot 의 **바깥에** 두는것을 권합니다."

#: ../../intro/tutorial01.txt:80
msgid "Let's look at what :djadmin:`startproject` created::"
msgstr ":djadmin:`startproject` 에서 무엇이 생성되는지 확인해 봅시다."

#: ../../intro/tutorial01.txt:90
msgid "These files are:"
msgstr "이 파일들은,"

#: ../../intro/tutorial01.txt:92
msgid ""
"The outer :file:`mysite/` root directory is just a container for your "
"project. Its name doesn't matter to Django; you can rename it to anything "
"you like."
msgstr ""
":file:`mysite/` 디렉토리 바깥의 디렉토리는 단순히 프로젝트를 담는 공간입니다. 이 이름은 Django 와 아무 상관이 "
"없으니, 원하는 이름으로 변경하셔도 됩니다."

#: ../../intro/tutorial01.txt:96
msgid ""
":file:`manage.py`: A command-line utility that lets you interact with this "
"Django project in various ways. You can read all the details about "
":file:`manage.py` in :doc:`/ref/django-admin`."
msgstr ""
":file:`manage.py`: Django 프로젝트와 다양한 방법으로 상호작용 하는 커맨드라인의 유틸리티 입니다. "
":file:`manage.py` 에 대한 자세한 정보는 :doc:`/ref/django-admin` 에서 확인할 수 있습니다."

#: ../../intro/tutorial01.txt:100
msgid ""
"The inner :file:`mysite/` directory is the actual Python package for your "
"project. Its name is the Python package name you'll need to use to import "
"anything inside it (e.g. ``mysite.urls``)."
msgstr ""
":file:`mysite/` 디렉토리 내부에는 project 를 위한 실제 Python 패키지들이 저장됩니다. 이 디렉토리 내의 이름을 "
"이용하여, (``mysite.urls`` 와 같은 식으로) project 어디서나 Python 패키지들을 import 할 수 있습니다. "

#: ../../intro/tutorial01.txt:104
msgid ""
":file:`mysite/__init__.py`: An empty file that tells Python that this "
"directory should be considered a Python package. If you're a Python "
"beginner, read :ref:`more about packages <tut-packages>` in the official "
"Python docs."
msgstr ""
":file:`mysite/__init__.py`: Python 으로 하여금 이 디렉토리를 패키지 처럼 다루라고 알려주는 용도의 단순한 빈"
" 파일입니다. Python 초심자라면, Python 공식 홈페이지의 :ref:`more about packages <tut-"
"packages>` 를 읽어보십시요. "

#: ../../intro/tutorial01.txt:108
msgid ""
":file:`mysite/settings.py`: Settings/configuration for this Django project."
"  :doc:`/topics/settings` will tell you all about how settings work."
msgstr ""
":file:`mysite/settings.py`: 현재 Django project 의 환경/구성을 저장합니다. "
":doc:`/topics/settings` 에서 환경 설정이 어떻게 동작하는지 확인할 수 있습니다."

#: ../../intro/tutorial01.txt:112
msgid ""
":file:`mysite/urls.py`: The URL declarations for this Django project; a "
"\"table of contents\" of your Django-powered site. You can read more about "
"URLs in :doc:`/topics/http/urls`."
msgstr ""
":file:`mysite/urls.py`: 현재 Django project 의 URL 선언을 저장합니다. Django 로 작성된 사이트의"
" \"목차\" 라고 할 수 있습니다. :doc:`/topics/http/urls` 에서 URL 에 대한 자세한 내용을 읽어보세요."

#: ../../intro/tutorial01.txt:116
msgid ""
":file:`mysite/wsgi.py`: An entry-point for WSGI-compatible web servers to "
"serve your project. See :doc:`/howto/deployment/wsgi/index` for more "
"details."
msgstr ""
":file:`mysite/wsgi.py`: 현재 project 를 서비스 하기 위한 WSGI 호환 웹 서버의 진입점 입니다. "
":doc:`/howto/deployment/wsgi/index` 를 읽어보세요."

#: ../../intro/tutorial01.txt:120
msgid "The development server"
msgstr "개발 서버"

#: ../../intro/tutorial01.txt:122
msgid ""
"Let's verify your Django project works. Change into the outer :file:`mysite`"
" directory, if you haven't already, and run the following commands:"
msgstr ""
"당신의 Django project 가 제대로 동작하는지 확인해 봅시다. :file:`mysite` 디렉토리로 이동하고, 다음 명령어를 "
"입력하십시요."

#: ../../intro/tutorial01.txt:129
msgid "You'll see the following output on the command line:"
msgstr "커맨드라인에서 다음과 같은 출력을 볼 수 있습니다."

#: ../../intro/tutorial01.txt:146
msgid ""
"Ignore the warning about unapplied database migrations for now; we'll deal "
"with the database shortly."
msgstr ""
"현재 데이터베이스에 적용되지 않은 변경사항들(migrations)에 대한 경고들은 무시해도 됩니다. 데이터베이스에 대한 부분은 간단히 "
"다루도록 하겠습니다."

#: ../../intro/tutorial01.txt:149
msgid ""
"You've started the Django development server, a lightweight Web server "
"written purely in Python. We've included this with Django so you can develop"
" things rapidly, without having to deal with configuring a production server"
" -- such as Apache -- until you're ready for production."
msgstr ""
"Django 개발 서버를 시작했습니다. 개발 서버는 순수 Python 으로 작성된 경량 웹 서버입니다. Django 에 포함되어 있기 "
"때문에 아무 설정없이 바로 개발에 사용할 수 있습니다."

#: ../../intro/tutorial01.txt:154
msgid ""
"Now's a good time to note: **don't** use this server in anything resembling "
"a production environment. It's intended only for use while developing. "
"(We're in the business of making Web frameworks, not Web servers.)"
msgstr ""
"이쯤에서 하나 기억할 것이 있습니다. **절대로** 개발 서버를 운영 환경에서 사용하지 마십시요. **개발 서버는 오직 개발 "
"목적으로만** 사용하여야 합니다. (우리는 웹 프레임워크를 만들지 웹 서버를 만들지는 않거든요)"

#: ../../intro/tutorial01.txt:158
msgid ""
"Now that the server's running, visit http://127.0.0.1:8000/ with your Web "
"browser. You'll see a \"Welcome to Django\" page, in pleasant, light-blue "
"pastel. It worked!"
msgstr ""
"이제 서버가 동작하기 시작했으니, 웹 브라우져에서 http://127.0.0.1:8000/ 를 통해 접속할 수있습니다. 파스텔톤의 밝은 "
"파란색의 따뜻한 \"Welcome to Django\" 환영 페이지를 볼 수 있을 것입니다. 잘 동작 하네요!"

#: ../../intro/tutorial01.txt:162
msgid "Changing the port"
msgstr "포트 변경하기"

#: ../../intro/tutorial01.txt:164
msgid ""
"By default, the :djadmin:`runserver` command starts the development server "
"on the internal IP at port 8000."
msgstr "기본적으로, :djadmin:`runserver` 명령은 내부 IP 의 8000 번 포트로 개발 서버를 띄웁니다."

#: ../../intro/tutorial01.txt:167
msgid ""
"If you want to change the server's port, pass it as a command-line argument."
" For instance, this command starts the server on port 8080:"
msgstr ""
"만약 이 서버의 포트를 변경하고 싶다면, 커맨드라인에서 인수를 전달해주면 됩니다. 예를들어, 이 명령은 포트를 8080 으로 서버를 "
"시작할 것입니다."

#: ../../intro/tutorial01.txt:175
msgid ""
"If you want to change the server's IP, pass it along with the port. So to "
"listen on all public IPs (useful if you want to show off your work on other "
"computers on your network), use:"
msgstr ""
"만약 서버의 IP 를 바꾸고 싶다면, 포트와 함께 전달해 주면 됩니다. 다음과 같이 내 컴퓨터에 연결된 모든 공개 IP 를 서버에 "
"연결(listen) 할 수 있습니다. 네트워크 상의 다른 컴퓨터에게 내 작업물을 보여줄 때 유용합니다."

#: ../../intro/tutorial01.txt:183
msgid ""
"Full docs for the development server can be found in the "
":djadmin:`runserver` reference."
msgstr "개발 서버에 대한 자세한 내용은 :djadmin:`runserver` 를 참조하세요."

#: ../../intro/tutorial01.txt:186
msgid "Automatic reloading of :djadmin:`runserver`"
msgstr ":djadmin:`runserver` 의 자동 변경 기능"

#: ../../intro/tutorial01.txt:188
msgid ""
"The development server automatically reloads Python code for each request as"
" needed. You don't need to restart the server for code changes to take "
"effect. However, some actions like adding files don't trigger a restart, so "
"you'll have to restart the server in these cases."
msgstr ""
"개발 서버는 요청이 들어올 때마다 자동으로 Python 코드를 다시 불러옵니다. 코드의 변경사항을 반영하기 위해서 굳이 서버를 재기동 "
"하지 않아도 됩니다. 그러나, 파일을 추가하는 등의 몇몇의 동작은 개발서버가 자동으로 인식하지 못하기 때문에, 이런 상황에서는 서버를 "
"재기동 해야 적용됩니다."

#: ../../intro/tutorial01.txt:194
msgid "Creating the Polls app"
msgstr "투표 앱 만들기"

#: ../../intro/tutorial01.txt:196
msgid ""
"Now that your environment -- a \"project\" -- is set up, you're set to start"
" doing work."
msgstr "이제, 작업을 시작하기 위해 당신의 환경(project) 이 설치되었습니다."

#: ../../intro/tutorial01.txt:199
msgid ""
"Each application you write in Django consists of a Python package that "
"follows a certain convention. Django comes with a utility that automatically"
" generates the basic directory structure of an app, so you can focus on "
"writing code rather than creating directories."
msgstr ""
"Django 에서 당신이 작성하는 각 어플리케이션들은 다음과 같은 관례로 Python 패키지가 구성됩니다. Django 는 앱(app) "
"의 기본 디렉토리 구조를 자동으로 생성할 수 있는 도구를 제공하기 때문에, 코드에만 더욱 집중할 수 있습니다."

#: ../../intro/tutorial01.txt:204
msgid "Projects vs. apps"
msgstr "프로젝트 대 앱"

#: ../../intro/tutorial01.txt:206
msgid ""
"What's the difference between a project and an app? An app is a Web "
"application that does something -- e.g., a Weblog system, a database of "
"public records or a simple poll app. A project is a collection of "
"configuration and apps for a particular website. A project can contain "
"multiple apps. An app can be in multiple projects."
msgstr ""
"project 와 app 은 무엇이 다를까요? app 은 (웹블로그나 공공 기록물을 위한 데이터베이스나, 간단한 투표 앱과 같은) 특정한"
" 기능을 수행하는 웹 어플리케이션을 말합니다. project 는 이런 특정 웹 사이트를 위한 app 들과 각 설정들을 한데 묶어놓은 것 "
"입니다. project 는 다수의 app 을 포함할 수 있고, app 은 다수의 project 에 포함될 수 있습니다."

#: ../../intro/tutorial01.txt:212
msgid ""
"Your apps can live anywhere on your :ref:`Python path <tut-searchpath>`. In "
"this tutorial, we'll create our poll app right next to your "
":file:`manage.py` file so that it can be imported as its own top-level "
"module, rather than a submodule of ``mysite``."
msgstr ""
"당신의 app 은 :ref:`Python 경로 <tut-searchpath>` 어디라도 있을 수 있습니다. 그러나 이 예제에서는, "
"``mysite`` 같은 submodule 말고, top-level 에서 곧바로 import 할 수 있게 끔 "
":file:`manage.py` 바로 옆에 생성해 보도록 하겠습니다."

#: ../../intro/tutorial01.txt:217
msgid ""
"To create your app, make sure you're in the same directory as "
":file:`manage.py` and type this command:"
msgstr "app 을 생성하기 위해 :file:`manage.py` 가 존재하는 디렉토리에서 다음의 명령을 입력해 봅시다."

#: ../../intro/tutorial01.txt:224
msgid ""
"That'll create a directory :file:`polls`, which is laid out like this::"
msgstr ":file:`polls` 라는 디렉토리가 생겼습니다. 이걸 펼쳐놓으면 아래와 같습니다."

#: ../../intro/tutorial01.txt:236
msgid "This directory structure will house the poll application."
msgstr "이 디렉토리 구조는 poll 어플리케이션의 집이 되어줄 것입니다."

#: ../../intro/tutorial01.txt:239
msgid "Write your first view"
msgstr "첫 번째 뷰 작성하기"

#: ../../intro/tutorial01.txt:241
msgid ""
"Let's write the first view. Open the file ``polls/views.py`` and put the "
"following Python code in it:"
msgstr "첫 번째 뷰를 작성해봅시다. \"polls/view.py\"를 열어 다음과 같은 파이썬 코드를 입력합니다"

#: ../../intro/tutorial01.txt:253
msgid ""
"This is the simplest view possible in Django. To call the view, we need to "
"map it to a URL - and for this we need a URLconf."
msgstr ""
"Django 에서 가장 간단한 형태의 view 입니다. view 를 호출하려면 이와 연결된 URL 이 있어야 하는데, 이를 위해 "
"URLconf 가 사용됩니다."

#: ../../intro/tutorial01.txt:256
msgid ""
"To create a URLconf in the polls directory, create a file called "
"``urls.py``. Your app directory should now look like::"
msgstr ""
"polls 디렉토리에서 URLconf 를 생성하려면, ``urls.py`` 라는 파일을 생성해야 합니다. 정확히 생성했다면, app "
"디렉토리는 다음과 같이 보일겁니다.::"

#: ../../intro/tutorial01.txt:270
msgid "In the ``polls/urls.py`` file include the following code:"
msgstr "\"polls/urls.py\" 파일에는 다음과 같은 코드가 포함되어 있습니다."

#: ../../intro/tutorial01.txt:283
msgid ""
"The next step is to point the root URLconf at the ``polls.urls`` module. In "
"``mysite/urls.py``, add an import for ``django.conf.urls.include`` and "
"insert an :func:`~django.conf.urls.include` in the ``urlpatterns`` list, so "
"you have:"
msgstr ""
"다음 단계는, project 최상단의 URLconf 에서 ``polls.urls`` 모듈을 바라보게 설정합니다. "
"``mysite/urls.py`` 파일을 열고, ``django.conf.urls.include`` 를 import 하십시요. 그리고 "
"``urlpatterns`` 리스트에 :func:`~django.conf.urls.include` 함수를 다음과 같이 추가합니다."

#: ../../intro/tutorial01.txt:298
msgid ""
"The :func:`~django.conf.urls.include` function allows referencing other "
"URLconfs. Note that the regular expressions for the "
":func:`~django.conf.urls.include` function doesn't have a ``$`` (end-of-"
"string match character) but rather a trailing slash. Whenever Django "
"encounters :func:`~django.conf.urls.include`, it chops off whatever part of "
"the URL matched up to that point and sends the remaining string to the "
"included URLconf for further processing."
msgstr ""
":func:`~django.conf.urls.include` 함수는 다른 URLconf 를 참조할 수 있도록 도와줍니다. "
":func:`~django.conf.urls.include` 함수를 위한 정규 표현식에서 끝을 의미하는 기호로 ``$`` 대신 "
"슬래시(``/``) 가 붙는다는 점을 기억하십시요. Django 가 :func:`~django.conf.urls.include` 를 "
"만나게 되면, 그 시점까지 일치하는 URL 의 부분을 잘라내고, 남은 부분을 후속 처리를 위해 include 된 URLconf 로 "
"전달합니다. 즉, ``/polls/some/method`` 를 요청받으면, ``some/method`` 가 "
"``polls/urls.py`` 의 URLconf 로 넘어갑니다."

#: ../../intro/tutorial01.txt:306
msgid ""
"The idea behind :func:`~django.conf.urls.include` is to make it easy to "
"plug-and-play URLs. Since polls are in their own URLconf "
"(``polls/urls.py``), they can be placed under \"/polls/\", or under "
"\"/fun_polls/\", or under \"/content/polls/\", or any other path root, and "
"the app will still work."
msgstr ""
":func:`~django.conf.urls.include` 에 숨은 아이디어 덕분에, URL 을 쉽게 연결할 수 있습니다(plug-"
"and-ply). polls 앱에 자체적인 URLconf(``polls/urls.py``) 가 존재하는 한, \"/polls/\", 혹은"
" \"/fun_polls/\", 혹은 \"/content/polls/\" 같은 그 어떤 경로에 붙이더라도 app 은 여전히 잘 동작할 "
"것입니다."

#: ../../intro/tutorial01.txt:312
msgid "When to use :func:`~django.conf.urls.include()`"
msgstr "언제 :func:`~django.conf.urls.include()` 를 사용해야 하나요?"

#: ../../intro/tutorial01.txt:314
msgid ""
"You should always use ``include()`` when you include other URL patterns. "
"``admin.site.urls`` is the only exception to this."
msgstr ""
"``admin.site.urls`` 를 제외한, 다른 URL 패턴을 include 할 때마다 항상 ``include()`` 를 사용해야 "
"합니다. "

#: ../../intro/tutorial01.txt:317
msgid "Doesn't match what you see?"
msgstr "보고 계신 내용과 뭔가 맞지 않으신가요?"

#: ../../intro/tutorial01.txt:319
msgid ""
"If you're seeing ``include(admin.site.urls)`` instead of just "
"``admin.site.urls``, you're probably using a version of Django that doesn't "
"match this tutorial version.  You'll want to either switch to the older "
"tutorial or the newer Django version."
msgstr ""
"``include(admin.site.urls)`` 대신 ``admin.site.urls`` 같은 문장이 보인다면, 이 튜토리얼에서 "
"사용하는 Django 와 다른 버전의 Django 를 사용하고 계신겁니다. 예전 튜토리얼을 참고하시거나, Django 를 업데이트 "
"해주세요."

#: ../../intro/tutorial01.txt:324
msgid ""
"You have now wired an ``index`` view into the URLconf. Lets verify it's "
"working, run the following command:"
msgstr "이제 ``index`` view 가 URLconf 에서 연결되었습니다. 잘 작동하는지 확인하기 위해 다음을 입력해 보세요."

#: ../../intro/tutorial01.txt:331
msgid ""
"Go to http://localhost:8000/polls/ in your browser, and you should see the "
"text \"*Hello, world. You're at the polls index.*\", which you defined in "
"the ``index`` view."
msgstr ""
"브라우저에서 http://localhost:8000/polls/ 를 입력하면 ``index`` view 로 정의한 \"*Hello, "
"world. You're at the polls index.*\" 가 보일 것입니다."

#: ../../intro/tutorial01.txt:335
msgid ""
"The :func:`~django.conf.urls.url` function is passed four arguments, two "
"required: ``regex`` and ``view``, and two optional: ``kwargs``, and "
"``name``. At this point, it's worth reviewing what these arguments are for."
msgstr ""
":func:`~django.conf.urls.url` 함수에는 4 개의 인수가 전달되었습니다. 두개의 필수 인수로 ``regex`` 와 "
"``view`` 가 있고, 두개의 옵션 인수로 ``kwargs`` 와 ``name`` 이 있습니다. 이 시점에서, 이 인수가 무엇인지 "
"살펴보는것은 의미가 있습니다."

#: ../../intro/tutorial01.txt:340
msgid ":func:`~django.conf.urls.url` argument: regex"
msgstr ":func:`~django.conf.urls.url` 인수: ``regex``"

#: ../../intro/tutorial01.txt:342
msgid ""
"The term \"regex\" is a commonly used short form meaning \"regular "
"expression\", which is a syntax for matching patterns in strings, or in this"
" case, url patterns. Django starts at the first regular expression and makes"
" its way down the list,  comparing the requested URL against each regular "
"expression until it finds one that matches."
msgstr ""
"\"regex\" 는 보통 정규 표현식(\"Regular Expression\") 을 짧게 줄여 쓰는 표현입니다. 문자열의 패턴을 "
"일치시키는 문법을 말하며, 이 경우에는 url 의 패턴을 찾아내는데 사용되었습니다. Django 에서는 목록의 첫번째 정규표현식부터 "
"시작해서, 요청된 URL 에 대하여 일치하는 정규 표현식이 발견 될때까지 차례로 비교합니다."

#: ../../intro/tutorial01.txt:348
msgid ""
"Note that these regular expressions do not search GET and POST parameters, "
"or the domain name. For example, in a request to "
"``https://www.example.com/myapp/``, the URLconf will look for ``myapp/``. In"
" a request to ``https://www.example.com/myapp/?page=3``, the URLconf will "
"also look for ``myapp/``."
msgstr ""
"이 정규 표현식 들은 ``GET`` 이나 ``POST`` 의 매개변수나, 도메인 이름을 뒤지지는 않습니다. 예를 들어, "
"``https://www.example.com/myapp/`` 가 요청된 경우, URLconf 는 오직 ``myapp/`` 부분만 "
"바라봅니다. ``https://www.example.com/myapp/?page=3`` 같은 요청에도, URLconf 는 역시 "
"``myapp/`` 부분만 신경씁니다."

#: ../../intro/tutorial01.txt:354
msgid ""
"If you need help with regular expressions, see `Wikipedia's entry`_ and the "
"documentation of the :mod:`re` module. Also, the O'Reilly book \"Mastering "
"Regular Expressions\" by Jeffrey Friedl is fantastic. In practice, however, "
"you don't need to be an expert on regular expressions, as you really only "
"need to know how to capture simple patterns. In fact, complex regexes can "
"have poor lookup performance, so you probably shouldn't rely on the full "
"power of regexes."
msgstr ""
"정규 표현식에 대해 도움이 필요하다면, `Wikipedia's entry`_ 를 참고하시거나 :mod:`re` 모듈의 문서를 참고해 "
"주십시요. 특히 Jeffrey Friedl 가 쓴 오라일리 출판의 \"정규표현식 완전 해부와 실습\"(\"Mastering Regular"
" Expressions\") 는 완벽한 참고서입니다.그러나 현실적으로 이 모든 내용을 전부 알아야 할 필요는 없습니다. 딱 필요한 만큼,"
" 간단한 패턴을 잡아낼 정도만 알면 됩니다. 사실, 복잡한 정규표현식을 사용하면 검색 속도가 아주 느려지므로, 전적으로 정규 표현식에 "
"의존하지 않아야 합니다."

#: ../../intro/tutorial01.txt:361
msgid ""
"Finally, a performance note: these regular expressions are compiled the "
"first time the URLconf module is loaded. They're super fast (as long as the "
"lookups aren't too complex as noted above)."
msgstr ""
"마지막으로 성능에 관해 알아야 할 사실은, 이런 정규 표현식들은 URLconf 모듈이 처음 불러올 때 자동으로 컴파일 되기 때문에 "
"엄청나게 빠르다는 것입니다. 물론 앞서 언급했듯이 복잡한 검색을 쓰지 않는 한 말이죠."

#: ../../intro/tutorial01.txt:368
msgid ":func:`~django.conf.urls.url` argument: view"
msgstr ":func:`~django.conf.urls.url` 인수: view"

#: ../../intro/tutorial01.txt:370
msgid ""
"When Django finds a regular expression match, Django calls the specified "
"view function, with an :class:`~django.http.HttpRequest` object as the first"
" argument and any “captured” values from the regular expression as other "
"arguments. If the regex uses simple captures, values are passed as "
"positional arguments; if it uses named captures, values are passed as "
"keyword arguments. We'll give an example of this in a bit."
msgstr ""
"Django 에서 일치하는 정규 표현식을 찾아내면, :class:`~django.http.HttpRequest` 객체를 첫번째 인수로 "
"하고, 정규표현식에서 “잡힌” 값들을 나머지 인수로 하여 특정한 view 함수를 호출합니다. 만약 정규표현식이 간단한 형식이라면, 잡힌 "
"값들은 단순히 순서 기반의 인수로서 함수에 넘겨집니다. 만약 이름 기반의 정규표현식이라면, 잡힌 값들은 키워드 인수들로 함수에 "
"넘겨집니다. 나중에 이에 대한 간단한 예제를 살펴보겠습니다."

#: ../../intro/tutorial01.txt:378
msgid ":func:`~django.conf.urls.url` argument: kwargs"
msgstr ":func:`~django.conf.urls.url` 인수: kwargs"

#: ../../intro/tutorial01.txt:380
msgid ""
"Arbitrary keyword arguments can be passed in a dictionary to the target "
"view. We aren't going to use this feature of Django in the tutorial."
msgstr "임의의 키워드 인수들은 목표한 view 에 사전형으로 전달됩니다. 그러나 이 튜토리얼에서는 사용하지 않을겁니다."

#: ../../intro/tutorial01.txt:384
msgid ":func:`~django.conf.urls.url` argument: name"
msgstr ":func:`~django.conf.urls.url` 인수: name"

#: ../../intro/tutorial01.txt:386
msgid ""
"Naming your URL lets you refer to it unambiguously from elsewhere in Django,"
" especially from within templates. This powerful feature allows you to make "
"global changes to the URL patterns of your project while only touching a "
"single file."
msgstr ""
"URL 에 이름을 지으면, 템플릿을 포함한 Django 어디에서나 명확하게 참조할 수 있습니다. 이 강력한 기능을 이용하여, 단 하나의 "
"파일만 수정해도 project 내의 모든 URL 패턴을 바꿀 수 있도록 도와줍니다."

#: ../../intro/tutorial01.txt:391
msgid ""
"When you're comfortable with the basic request and response flow, read "
":doc:`part 2 of this tutorial </intro/tutorial02>` to start working with the"
" database."
msgstr ""
"request 와 response 의 기본 흐름을 이해하셨다면, :doc:`튜토리얼 2장 </intro/tutorial02>` 에서 "
"데이터베이스 작업을 시작해보세요."

#: ../../intro/tutorial02.txt:3
msgid "Writing your first Django app, part 2"
msgstr "첫 번째 장고 앱 작성하기, part 2"

#: ../../intro/tutorial02.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 1 </intro/tutorial01>` left off. "
"We'll setup the database, create your first model, and get a quick "
"introduction to Django's automatically-generated admin site."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 1장 </intro/tutorial01>` 이후부터 이어집니다. 데이터베이스를 설치하고 첫 모델을 "
"생성한 후, Django 에서 자동 생성되는 관리용 사이트에 대한 짧은 소개를 하겠습니다. "

#: ../../intro/tutorial02.txt:10
msgid "Database setup"
msgstr "데이터베이스 설치"

#: ../../intro/tutorial02.txt:12
msgid ""
"Now, open up :file:`mysite/settings.py`. It's a normal Python module with "
"module-level variables representing Django settings."
msgstr ""
"이제, :file:`mysite/settings.py` 파일을 열어보세요. 이 파일은 Django 설정을 모듈 변수로 표현한 보통의 "
"Python 모듈 입니다. "

#: ../../intro/tutorial02.txt:15
msgid ""
"By default, the configuration uses SQLite. If you're new to databases, or "
"you're just interested in trying Django, this is the easiest choice. SQLite "
"is included in Python, so you won't need to install anything else to support"
" your database. When starting your first real project, however, you may want"
" to use a more scalable database like PostgreSQL, to avoid database-"
"switching headaches down the road."
msgstr ""
"기본적으로는 SQLite 을 사용하도록 구성되어 있습니다. 만약 데이터베이스를 처음 경험해보거나, Django 에서 데이터베이스를 한번 "
"경험해 보고 싶다면, SQLite 가 가장 간단한 방법입니다. SQLite 는 Python 에서 기본으로 제공되기 때문에 별도로 설치할 "
"필요가 없습니다. 그러나 실제 project 를 시작할 때에는, 나중에 데이터베이스를 교체하느라 골치아파질 일을 피하기 위해서라도 "
"PostgreSQL 같이 좀 더 확장성있는 데이터베이스를 사용하고 싶을 겁니다."

#: ../../intro/tutorial02.txt:22
msgid ""
"If you wish to use another database, install the appropriate :ref:`database "
"bindings <database-installation>` and change the following keys in the "
":setting:`DATABASES` ``'default'`` item to match your database connection "
"settings:"
msgstr ""
"다른 데이터베이스를 사용해보고 싶으시다면, 적절한 :ref:`데이터베이스 연결 <database-installation>` 을 설치하고,"
" 데이터베이스 연결 설정과 맞게끔 :setting:`DATABASES` ``'default'`` 항목의 값을 다음의 키 값으로 "
"바꿔주세요. "

#: ../../intro/tutorial02.txt:27
msgid ""
":setting:`ENGINE <DATABASE-ENGINE>` -- Either "
"``'django.db.backends.sqlite3'``, ``'django.db.backends.postgresql'``, "
"``'django.db.backends.mysql'``, or ``'django.db.backends.oracle'``. Other "
"backends are :ref:`also available <third-party-notes>`."
msgstr ""
":setting:`ENGINE <DATABASE-ENGINE>` -- ``'django.db.backends.sqlite3'``, "
"``'django.db.backends.postgresql'``, ``'django.db.backends.mysql'``, or "
"``'django.db.backends.oracle'``. 그 외에 :ref:`서드파티 백엔드 <third-party-notes>` 를 "
"참조."

#: ../../intro/tutorial02.txt:34
msgid ""
":setting:`NAME` -- The name of your database. If you're using SQLite, the "
"database will be a file on your computer; in that case, :setting:`NAME` "
"should be the full absolute path, including filename, of that file. The "
"default value, ``os.path.join(BASE_DIR, 'db.sqlite3')``, will store the file"
" in your project directory."
msgstr ""
":setting:`NAME` -- 데이터베이스의 이름. 만약 SQLite 를 사용 중이라면, 데이터베이스는 당신의 컴퓨터의 파일로서 "
"저장됩니다. 이 경우, :setting:`NAME` 는 파일명을 포함한 절대 경로 로서 지정되어야 합니다.기본 값은 "
"``os.path.join(BASE_DIR, 'db.sqlite3')`` 로 정의되어 있으며, project 디렉토리 내에 "
"``db.sqlite3`` 파일로 저장됩니다."

#: ../../intro/tutorial02.txt:40
msgid ""
"If you are not using SQLite as your database, additional settings such as "
":setting:`USER`, :setting:`PASSWORD`, and :setting:`HOST` must be added. For"
" more details, see the reference documentation for :setting:`DATABASES`."
msgstr ""
"SQLite 를 데이터베이스로 사용하지 않는 경우, :setting:`USER`, :setting:`PASSWORD`, "
":setting:`HOST` 같은 추가 설정이 반드시 필요합니다. 더 자세한 내용은 :setting:`DATABASES` 문서를 참조해 "
"주세요."

#: ../../intro/tutorial02.txt:44
msgid "For databases other than SQLite"
msgstr "SQLite가 아닌 데이터베이스라면"

#: ../../intro/tutorial02.txt:46
msgid ""
"If you're using a database besides SQLite, make sure you've created a "
"database by this point. Do that with \"``CREATE DATABASE database_name;``\" "
"within your database's interactive prompt."
msgstr ""
"만약 SQLite 이외의 데이터베이스를 사용하는 경우, 이 시점에서 데이터베이스를 생성해야 합니다. 데이터베이스의 대화형 프롬프트 내에서"
" \"``CREATE DATABASE database_name;``\" 명령을 실행하면 됩니다."

#: ../../intro/tutorial02.txt:50
msgid ""
"Also make sure that the database user provided in :file:`mysite/settings.py`"
" has \"create database\" privileges. This allows automatic creation of a "
":ref:`test database <the-test-database>` which will be needed in a later "
"tutorial."
msgstr ""
"또한, :file:`mysite/settings.py` 에 설정된 데이터베이스 사용자가 \"create database\" 권한이 "
"있는지도 확인해 봐야 합니다. 튜토리얼을 진행하며 필요한 경우 :ref:`테스트 데이터베이스 <the-test-database>` 를 "
"자동으로 생성할 수 있도록 해줍니다. "

#: ../../intro/tutorial02.txt:55
msgid ""
"If you're using SQLite, you don't need to create anything beforehand - the "
"database file will be created automatically when it is needed."
msgstr ""
"SQLite 를 사용하고 계시다면, 아무것도 미리 생성할 필요가 없습니다. 데이터베이스 파일은 필요할때마다 자동으로 생성될 것입니다."

#: ../../intro/tutorial02.txt:58
msgid ""
"While you're editing :file:`mysite/settings.py`, set :setting:`TIME_ZONE` to"
" your time zone."
msgstr ""
":file:`mysite/settings.py` 을 편집하는 동안, 당신의 시간대에 맞춰 set :setting:`TIME_ZONE` "
"값을 설정하기 바랍니다."

#: ../../intro/tutorial02.txt:61
msgid ""
"Also, note the :setting:`INSTALLED_APPS` setting at the top of the file. "
"That holds the names of all Django applications that are activated in this "
"Django instance. Apps can be used in multiple projects, and you can package "
"and distribute them for use by others in their projects."
msgstr ""
"또한, 이 파일의 윗쪽에 있는 :setting:`INSTALLED_APPS` 에 대해 언급하자면, 이 파일은 현재 Django "
"인스턴스에서 활성화된 모든 Django 어플리케이션들의 이름이 담겨 있습니다. App 들은 다수의 project 에서 사용될 수 있고, "
"다른 project 에서 쉽게 사용 될 수 있도록 패키지 하여 배포할 수 있습니다."

#: ../../intro/tutorial02.txt:66
msgid ""
"By default, :setting:`INSTALLED_APPS` contains the following apps, all of "
"which come with Django:"
msgstr ""
"기본적으로는, :setting:`INSTALLED_APPS` 는 Django 와 함께 딸려오는 다음의 app 들을 포함합니다. "

#: ../../intro/tutorial02.txt:69
msgid ":mod:`django.contrib.admin` -- The admin site. You'll use it shortly."
msgstr ":mod:`django.contrib.admin` -- 관리용 사이트, 곧 사용하게 될겁니다."

#: ../../intro/tutorial02.txt:71
msgid ":mod:`django.contrib.auth` -- An authentication system."
msgstr ":mod:`django.contrib.auth` -- 인증 시스템."

#: ../../intro/tutorial02.txt:73
msgid ":mod:`django.contrib.contenttypes` -- A framework for content types."
msgstr ":mod:`django.contrib.contenttypes` -- 컨텐츠 타입을 위한 프레임워크."

#: ../../intro/tutorial02.txt:75
msgid ":mod:`django.contrib.sessions` -- A session framework."
msgstr ":mod:`django.contrib.sessions` -- 세션 프레임워크."

#: ../../intro/tutorial02.txt:77
msgid ":mod:`django.contrib.messages` -- A messaging framework."
msgstr ":mod:`django.contrib.messages` -- 메세징 프레임워크."

#: ../../intro/tutorial02.txt:79
msgid ""
":mod:`django.contrib.staticfiles` -- A framework for managing static files."
msgstr ":mod:`django.contrib.staticfiles` -- 정적 파일을 관리하는 프레임워크."

#: ../../intro/tutorial02.txt:82
msgid ""
"These applications are included by default as a convenience for the common "
"case."
msgstr "이 어플리케이션들은 일반적인 경우에 사용하기 편리하도록 기본으로 제공됩니다. "

#: ../../intro/tutorial02.txt:84
msgid ""
"Some of these applications make use of at least one database table, though, "
"so we need to create the tables in the database before we can use them. To "
"do that, run the following command:"
msgstr ""
"이러한 기본 어플리케이션들 중 몇몇은 최소한 하나 이상의 데이터베이스 테이블을 사용하는데, 그러기 위해서는 데이터베이스에서 테이블을 미리"
" 만들 필요가 있습니다. 이를 위해, 다음의 명령을 실행해봅시다."

#: ../../intro/tutorial02.txt:92
msgid ""
"The :djadmin:`migrate` command looks at the :setting:`INSTALLED_APPS` "
"setting and creates any necessary database tables according to the database "
"settings in your :file:`mysite/settings.py` file and the database migrations"
" shipped with the app (we'll cover those later). You'll see a message for "
"each migration it applies. If you're interested, run the command-line client"
" for your database and type ``\\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL),"
" ``.schema`` (SQLite), or ``SELECT TABLE_NAME FROM USER_TABLES;`` (Oracle) "
"to display the tables Django created."
msgstr ""
":djadmin:`migrate` 명령은 :setting:`INSTALLED_APPS` 의 설정을 탐색하여, "
":file:`mysite/settings.py` 의 데이터베이스 설정과 app 과 함께 제공되는 데이터베이스 migrations(나중에 "
"설명하겠습니다) 에 따라, 필요한 데이터베이스 테이블을 생성합니다. 이 명령을 수행하면 각 migration 이 적용되는 메세지가 화면에"
" 출력되는 것을 확인할 수 있습니다. 어떤 내용이 생성되었는지 궁금하다면, 데이터베이스 클라이언트로 접속한 후, ``\\dt`` "
"(PostgreSQL), ``SHOW TABLES;`` (MySQL), ``.schema`` (SQLite), ``SELECT "
"TABLE_NAME FROM USER_TABLES;`` (Oracle) 을 통해 Django 가 생성한 테이블을 확인해 볼 수 있습니다."

#: ../../intro/tutorial02.txt:101
msgid "For the minimalists"
msgstr "최소주의자(minimalists)들을 위하여"

#: ../../intro/tutorial02.txt:103
msgid ""
"Like we said above, the default applications are included for the common "
"case, but not everybody needs them. If you don't need any or all of them, "
"feel free to comment-out or delete the appropriate line(s) from "
":setting:`INSTALLED_APPS` before running :djadmin:`migrate`. The "
":djadmin:`migrate` command will only run migrations for apps in "
":setting:`INSTALLED_APPS`."
msgstr ""
"위에서 언급했다시피, 기본으로 제공되는 어플리케이션은 일반적인 상황을 염두에 두었으나, 모두에게 필요한것은 아닙니다. 만약 이것들이 필요"
" 없다고 생각되시면, :djadmin:`migrate` 를 실행하기 전에 :setting:`INSTALLED_APPS` 에서 제거할 "
"어플리케이션들을 그냥 주석처리(comment-out) 하시거나 삭제하시면 됩니다. :djadmin:`migrate` 명령은 "
":setting:`INSTALLED_APPS` 에 등록된 어플리케이션에 한하여 실행될 것입니다."

#: ../../intro/tutorial02.txt:113
msgid "Creating models"
msgstr "모델 만들기"

#: ../../intro/tutorial02.txt:115
msgid ""
"Now we'll define your models -- essentially, your database layout, with "
"additional metadata."
msgstr ""
"이제, 모델을 정의해 보겠습니다. 본질적으로, 모델이란 부가적인 메타데이터를 가진 데이터베이스의 구조(layout)를 말합니다."

#: ../../intro/tutorial02.txt:118 ../../intro/tutorial02.txt:201
#: ../../intro/tutorial02.txt:585 ../../intro/tutorial03.txt:331
msgid "Philosophy"
msgstr "철학"

#: ../../intro/tutorial02.txt:120
msgid ""
"A model is the single, definitive source of truth about your data. It "
"contains the essential fields and behaviors of the data you're storing. "
"Django follows the :ref:`DRY Principle <dry>`. The goal is to define your "
"data model in one place and automatically derive things from it."
msgstr ""
"모델(\"model\")은 데이터에 관한 단 하나의, 가장 확실한 진리의 원천입니다. 이것은 당신이 저장하는 데이터의 필수적인 필드들과 "
"동작들을 포함하고 있습니다. Django 는 :ref:`DRY 원칙 <dry>` 을 따릅니다. 이 원칙에 따라 데이터 모델을 한곳에서 "
"정의하고, 이것으로부터 자동으로 뭔가를 유도하는 것이 목표입니다."

#: ../../intro/tutorial02.txt:125
msgid ""
"This includes the migrations - unlike in Ruby On Rails, for example, "
"migrations are entirely derived from your models file, and are essentially "
"just a history that Django can roll through to update your database schema "
"to match your current models."
msgstr ""
"이 규칙은 migration 에도 해당됩니다. Ruby On Rails 와는 다르게, Django 의 경우 migration 들은 모두 "
"모델 파일로 부터 유도되며, 이 migration 들은 Django 가 데이터 스키마의 업데이트를 통해 현재의 모델에 도달할 수 있게 "
"해주는, 일종의 역사와 같습니다. "

#: ../../intro/tutorial02.txt:130
msgid ""
"In our simple poll app, we'll create two models: ``Question`` and "
"``Choice``. A ``Question`` has a question and a publication date. A "
"``Choice`` has two fields: the text of the choice and a vote tally. Each "
"``Choice`` is associated with a ``Question``."
msgstr ""
"우리가 만드는 단순한 투표(poll) 앱을 위해 ``Question`` 과 ``Choice`` 라는 두개의 모델을 만들어 보겠습니다. "
"``Question`` 은 질문(question) 과 발행일(publication date) 을 위한 두개의 필드를 가집니다. "
"``Choice`` 는 선택지(choice) 와 표(vote) 계산을 위한 두개의 필드를 가집니다. 각 ``Choice`` 모델은 "
"``Question`` 모델과 연관(associated) 됩니다."

#: ../../intro/tutorial02.txt:135
msgid ""
"These concepts are represented by simple Python classes. Edit the "
":file:`polls/models.py` file so it looks like this:"
msgstr ""
"이런 개념은 간단한 Python 클래스로 표현할 수 있습니다. :file:`polls/models.py` 파일을 수정하여 다음과 같이 "
"만들어 봅시다."

#: ../../intro/tutorial02.txt:154
msgid ""
"The code is straightforward. Each model is represented by a class that "
"subclasses :class:`django.db.models.Model`. Each model has a number of class"
" variables, each of which represents a database field in the model."
msgstr ""
"아주 간단한 코드입니다. 각 모델은 :class:`django.db.models.Model` 이라는 클래스의 서브클래스로 표현됩니다. 각"
" 모델은 몇개의 클래스 변수를 가지고 있으며, 각각의 클래스 변수들은 모델의 데이터베이스 필드를 나타냅니다."

#: ../../intro/tutorial02.txt:158
msgid ""
"Each field is represented by an instance of a "
":class:`~django.db.models.Field` class -- e.g., "
":class:`~django.db.models.CharField` for character fields and "
":class:`~django.db.models.DateTimeField` for datetimes. This tells Django "
"what type of data each field holds."
msgstr ""
"데이터베이스의 각 필드는 :class:`~django.db.models.Field` 클래스의 인스턴스로서 표현됩니다. "
":class:`~django.db.models.CharField` 는 문자(character) 필드를 표현하고, "
":class:`~django.db.models.DateTimeField` 는 날짜와 시간(datetime) 필드를 표현합니다. 이것은 각"
" 필드가 어떤 자료형을 가질 수 있는지를 Django 에게 말해줍니다."

#: ../../intro/tutorial02.txt:163
msgid ""
"The name of each :class:`~django.db.models.Field` instance (e.g. "
"``question_text`` or ``pub_date``) is the field's name, in machine-friendly "
"format. You'll use this value in your Python code, and your database will "
"use it as the column name."
msgstr ""
"각각의 :class:`~django.db.models.Field` 인스턴스의 이름은 기계가 읽기 좋은 형식(machine-friendly"
" format)의 데이터베이스 필드 이름입니다. 이 필드명을 Python 코드에서 사용할수 있으며, 데이터베이스에서는 컬럼명으로 사용할 "
"것입니다. "

#: ../../intro/tutorial02.txt:168
msgid ""
"You can use an optional first positional argument to a "
":class:`~django.db.models.Field` to designate a human-readable name. That's "
"used in a couple of introspective parts of Django, and it doubles as "
"documentation. If this field isn't provided, Django will use the machine-"
"readable name. In this example, we've only defined a human-readable name for"
" ``Question.pub_date``. For all other fields in this model, the field's "
"machine-readable name will suffice as its human-readable name."
msgstr ""
":class:`~django.db.models.Field` 클래스의 생성자에 선택적인 첫번째 위치 인수를 전달하여 사람이 읽기 좋은"
"(human-readable) 이름을 지정할 수도 있습니다. 이 방법은 Django 의 내부를 설명하는 용도로 종종 사용되는데, 이는 "
"마치 문서가 늘어나는 것 같은 효과를 가집니다. 만약 이 선택적인 첫번째 위치 인수를 사용하지 않으면, Django 는 기계가 읽기 좋은"
" 형식의 이름을 사용합니다. 이 예제에서는, ``Question.pub_date`` 에 한해서만 인간이 읽기 좋은 형태의 이름을 "
"정의하겠습니다. 그 외의 다른 필드들은, 기계가 읽기 좋은 형태의 이름이라도 사람이 읽기에는 충분합니다. "

#: ../../intro/tutorial02.txt:176
msgid ""
"Some :class:`~django.db.models.Field` classes have required arguments. "
":class:`~django.db.models.CharField`, for example, requires that you give it"
" a :attr:`~django.db.models.CharField.max_length`. That's used not only in "
"the database schema, but in validation, as we'll soon see."
msgstr ""
"몇몇 :class:`~django.db.models.Field` 클래스들은 필수 인수가 필요합니다. 예를 들어, "
":class:`~django.db.models.CharField` 의 경우 "
":attr:`~django.db.models.CharField.max_length` 를 입력해 주어야 합니다. 이것은 데이터베이스 "
"스키마에서만 필요한것이 아닌 값을 검증할때도 쓰이는데, 곧 보게 될것입니다."

#: ../../intro/tutorial02.txt:181
msgid ""
"A :class:`~django.db.models.Field` can also have various optional arguments;"
" in this case, we've set the :attr:`~django.db.models.Field.default` value "
"of ``votes`` to 0."
msgstr ""
"또한 :class:`~django.db.models.Field` 는 다양한 선택적 인수들을 가질 수 있습니다. 이 예제에서는, "
":attr:`~django.db.models.Field.default` 로 하여금 ``votes`` 의 기본값을 0 으로 설정하였습니다."

#: ../../intro/tutorial02.txt:185
msgid ""
"Finally, note a relationship is defined, using "
":class:`~django.db.models.ForeignKey`. That tells Django each ``Choice`` is "
"related to a single ``Question``. Django supports all the common database "
"relationships: many-to-one, many-to-many, and one-to-one."
msgstr ""
"마지막으로, :class:`~django.db.models.ForeignKey` 를 사용한 관계설정에 대해 설명하겠습니다. 이 예제에서는"
" 각각의 ``Choice`` 가 하나의 ``Question`` 에 관계된다는 것을 Django 에게 알려줍니다. Django 는 "
"다-대-일(many-to-one), 다-대-다(many-to-many), 일-대-일(one-to-one) 과 같은 모든 일반 "
"데이터베이스의 관계들를 지원합니다."

#: ../../intro/tutorial02.txt:191
msgid "Activating models"
msgstr "모델의 활성화"

#: ../../intro/tutorial02.txt:193
msgid ""
"That small bit of model code gives Django a lot of information. With it, "
"Django is able to:"
msgstr ""
"모델에 대한 이 작은 코드가, Django 에게는 상당한 량의 정보를 전달합니다. 이 정보로 Django 는 다음을 할 수 있습니다.:"

#: ../../intro/tutorial02.txt:196
msgid "Create a database schema (``CREATE TABLE`` statements) for this app."
msgstr "이 app 에 대하여 데이터베이스 스키마 생성 (``CREATE TABLE`` statements)"

#: ../../intro/tutorial02.txt:197
msgid ""
"Create a Python database-access API for accessing ``Question`` and "
"``Choice`` objects."
msgstr "``Question`` 과 ``Choice`` 객체에 접근하기 위한 Python 데이터베이스 접근 API 를 생성"

#: ../../intro/tutorial02.txt:199
msgid ""
"But first we need to tell our project that the ``polls`` app is installed."
msgstr "그러나, 가장 먼저 현재 project 에게 ``polls`` app 이 설치되어 있다는 것을 알려야 합니다. "

#: ../../intro/tutorial02.txt:203
msgid ""
"Django apps are \"pluggable\": You can use an app in multiple projects, and "
"you can distribute apps, because they don't have to be tied to a given "
"Django installation."
msgstr ""
"Django 의 app 들은 착탈 가능(\"pluggable\") 합니다. app 을 다수의 프로젝트에서 사용할 수 있으며, app 을 "
"배포할 수도 있습니다. 특정 Django 에 app 들이 묶여있지 않아도 되기 때문입니다."

#: ../../intro/tutorial02.txt:207
msgid ""
"To include the app in our project, we need to add a reference to its "
"configuration class in the :setting:`INSTALLED_APPS` setting. The "
"``PollsConfig`` class is in the :file:`polls/apps.py` file, so its dotted "
"path is ``'polls.apps.PollsConfig'``. Edit the :file:`mysite/settings.py` "
"file and add that dotted path to the :setting:`INSTALLED_APPS` setting. "
"It'll look like this:"
msgstr ""
"app 을 현재의 project 에 포함시키기 위해서는, app 의 구성 클래스에 대한 참조를 "
":setting:`INSTALLED_APPS` 설정에 추가시켜야 합니다. ``PollsConfig`` 클래스는 "
":file:`polls/apps.py` 파일 내에 존재합니다. 따라서, 점으로 구분된 경로는 "
"``'polls.apps.PollsConfig'`` 가 됩니다. 이 점으로 구분된 경로를, "
":file:`mysite/settings.py` 파일을 편집하여 :setting:`INSTALLED_APPS` 설정에 추가하면 됩니다. "
"이는 다음과 같이 보일것입니다."

#: ../../intro/tutorial02.txt:227
msgid ""
"Now Django knows to include the ``polls`` app. Let's run another command:"
msgstr "이제, Django 는 ``polls`` app 이 포함된 것을 알게 되었습니다. 다른 명령을 내려봅시다."

#: ../../intro/tutorial02.txt:233
msgid "You should see something similar to the following:"
msgstr "다음과 비슷한 것이 보일겁니다.:"

#: ../../intro/tutorial02.txt:243
msgid ""
"By running ``makemigrations``, you're telling Django that you've made some "
"changes to your models (in this case, you've made new ones) and that you'd "
"like the changes to be stored as a *migration*."
msgstr ""
"``makemigrations`` 을 실행시킴으로서, 당신이 모델을 변경시킨 사실과(이 경우에는 새로운 모델을 만들었습니다) 이 "
"변경사항을 *migration* 으로 저장시키고 싶다는 것을 Django 에게 알려줍니다."

#: ../../intro/tutorial02.txt:247
msgid ""
"Migrations are how Django stores changes to your models (and thus your "
"database schema) - they're just files on disk. You can read the migration "
"for your new model if you like; it's the file "
"``polls/migrations/0001_initial.py``. Don't worry, you're not expected to "
"read them every time Django makes one, but they're designed to be human-"
"editable in case you want to manually tweak how Django changes things."
msgstr ""
"migration 은 Django가 모델(즉, 데이터베이스 스키마를 포함한)의 변경사항을 저장하는 방법으로써, 디스크상의 파일로 "
"존재합니다. 원한다면, ``polls/migrations/0001_initial.py`` 파일로 저장된 새 모델에 대한 migration"
" 을 읽어볼 수 있습니다. 걱정하지 마십시요, Django 가 migration 을 만들때마다 직접 읽어보실 필요는 없습니다만, 수동으로"
" Django 의 변경점을 조정하고 싶을때 사람이 직접 변경할 수 있도록 설계되어 있습니다."

#: ../../intro/tutorial02.txt:254
msgid ""
"There's a command that will run the migrations for you and manage your "
"database schema automatically - that's called :djadmin:`migrate`, and we'll "
"come to it in a moment - but first, let's see what SQL that migration would "
"run. The :djadmin:`sqlmigrate` command takes migration names and returns "
"their SQL:"
msgstr ""
"당신을 위해 migration 들을 실행시켜주고, 자동으로 데이터베이스 스키마를 관리해주는 :djadmin:`migrate` 라는 "
"명령어가 존재합니다. 이 명령을 알아보기 전에 migration 이 내부적으로 어떤 SQL 문장을 실행하는지 살펴봅시다. "
":djadmin:`sqlmigrate` 명령은 migration 이름을 인수로 받아, 실행하는 SQL 문장을 보여줍니다."

#: ../../intro/tutorial02.txt:263
msgid ""
"You should see something similar to the following (we've reformatted it for "
"readability):"
msgstr "다음과 비슷한 결과를 보실 수 있습니다. (가독성을 위해 결과물을 조금 다듬었습니다)"

#: ../../intro/tutorial02.txt:299
msgid "Note the following:"
msgstr "다음을 참고하세요:"

#: ../../intro/tutorial02.txt:301
msgid ""
"The exact output will vary depending on the database you are using. The "
"example above is generated for PostgreSQL."
msgstr "사용하는 데이터베이스에 따라서 출력결과는 다를 수 있습니다. 위의 출력결과는 PostgreSQL 에서 생성되었습니다."

#: ../../intro/tutorial02.txt:304
msgid ""
"Table names are automatically generated by combining the name of the app "
"(``polls``) and the lowercase name of the model -- ``question`` and "
"``choice``. (You can override this behavior.)"
msgstr ""
"테이블 이름은 app 의 이름과 모델의 이름(소문자)이 조합되어 자동으로 생성됩니다. 이 경우, 앱의 이름인 ``polls`` 와 "
"소문자로 표기된 모델의 이름인 ``question`` 과 ``choice`` 가 합쳐집니다. 이 동작을 재지정(override) 하여 "
"수정할 수 있습니다.)"

#: ../../intro/tutorial02.txt:308
msgid ""
"Primary keys (IDs) are added automatically. (You can override this, too.)"
msgstr "기본 키(Primary, ID) 는 자동으로 추가됩니다. (역시 이 동작도 재지정(override) 할 수 있습니다.)"

#: ../../intro/tutorial02.txt:310
msgid ""
"By convention, Django appends ``\"_id\"`` to the foreign key field name. "
"(Yes, you can override this, as well.)"
msgstr ""
"관례에 따라, Django 는 외래 키(foreign key) 필드명에 ``\"_id\"`` 이름을 자동으로 추가합니다. (물론 이것도 "
"재지정 할 수 있습니다.)"

#: ../../intro/tutorial02.txt:313
msgid ""
"The foreign key relationship is made explicit by a ``FOREIGN KEY`` "
"constraint. Don't worry about the ``DEFERRABLE`` parts; that's just telling "
"PostgreSQL to not enforce the foreign key until the end of the transaction."
msgstr ""
"외래 키 관계는 ``FOREIGN KEY`` 제약이 명시적으로 생성됩니다. 제약 조건 연기(``DEFERRABLE``) 에 대해서는 "
"걱정하지 않으셔도 됩니다. 이것은 단순히 PostgreSQL 에게 transaction 이 끝날때까지 외래 키를 강제하지 말라고 알려주는"
" 것 뿐입니다."

#: ../../intro/tutorial02.txt:317
msgid ""
"It's tailored to the database you're using, so database-specific field types"
" such as ``auto_increment`` (MySQL), ``serial`` (PostgreSQL), or ``integer "
"primary key autoincrement`` (SQLite) are handled for you automatically. Same"
" goes for the quoting of field names -- e.g., using double quotes or single "
"quotes."
msgstr ""
"사용하는 데이터베이스에 따라, 데이터베이스 고유의 필드타입이 조정됩니다. 따라서, 자동 증가 필드를 생성할 경우 "
"``auto_increment`` (MySQL), ``serial`` (PostgreSQL), ``integer primary key "
"autoincrement`` (SQLite) 와 같이 사용하는 데이터베이스에 따라 적절한 필드타입이 자동으로 선택됩니다. 필드 명에 "
"사용되는 인용부호도 상황에 따라 겹따옴표나 홑따옴표가 적절히 선택됩니다."

#: ../../intro/tutorial02.txt:323
msgid ""
"The :djadmin:`sqlmigrate` command doesn't actually run the migration on your"
" database - it just prints it to the screen so that you can see what SQL "
"Django thinks is required. It's useful for checking what Django is going to "
"do or if you have database administrators who require SQL scripts for "
"changes."
msgstr ""
":djadmin:`sqlmigrate` 명령은 실제로 데이터베이스의 migration 을 실행하지는 않습니다. 이 명령은 단순히 결과만 "
"출력할 뿐이며, Django 가 필요로 하는 SQL 이 무엇인지 확인할 수 있습니다. 이 결과를 이용하여 Django 가 무엇을 할 "
"것인지 미리 확인하거나, 데이터베이스 관리자에게 필요한 SQL 스크립트를 요청할 수도 있습니다."

#: ../../intro/tutorial02.txt:329
msgid ""
"If you're interested, you can also run :djadmin:`python manage.py check "
"<check>`; this checks for any problems in your project without making "
"migrations or touching the database."
msgstr ""
"관심이 있다면, :djadmin:`python manage.py check <check>` 명령을 통해 migration 을 생성하거나 "
"데이터베이스를 건드리지 않고도 project 에서 문제를 확인할 수 있습니다. "

#: ../../intro/tutorial02.txt:333
msgid ""
"Now, run :djadmin:`migrate` again to create those model tables in your "
"database:"
msgstr "이제, :djadmin:`migrate` 를 실행시켜 데이터베이스에 모델과 관련된 테이블을 생성해봅시다."

#: ../../intro/tutorial02.txt:344
msgid ""
"The :djadmin:`migrate` command takes all the migrations that haven't been "
"applied (Django tracks which ones are applied using a special table in your "
"database called ``django_migrations``) and runs them against your database -"
" essentially, synchronizing the changes you made to your models with the "
"schema in the database."
msgstr ""
":djadmin:`migrate` 명령은 아직 적용되지 않은 모든 migration 들을 수집하여 이를 실행합니다. (Django 는 "
"migration 의 적용 여부를 기록하는 ``django_migrations`` 테이블이 있습니다) 이 과정을 통해 모델에서의 변경 "
"사항들과 데이터베이스의 스키마의 동기화가 이루어집니다."

#: ../../intro/tutorial02.txt:350
msgid ""
"Migrations are very powerful and let you change your models over time, as "
"you develop your project, without the need to delete your database or tables"
" and make new ones - it specializes in upgrading your database live, without"
" losing data. We'll cover them in more depth in a later part of the "
"tutorial, but for now, remember the three-step guide to making model "
"changes:"
msgstr ""
"migration 은 매우 기능이 강력하여, 마치 project 를 개발 할 때처럼 데이터베이스나 테이블에 손대지 않고도 모델의 반복적인"
" 변경을 가능하게 해줍니다. 동작중인 데이터베이스를 자료 손실 없이 업그레이드 하는데에 최적화 되어 있습니다. 튜토리얼의 나머지 부분에서"
" 이 부분을 조금 더 살펴 보겠습니다만, 지금은 모델의 변경을 만드는 세단계의 지침을 기억하세요:"

#: ../../intro/tutorial02.txt:356
msgid "Change your models (in ``models.py``)."
msgstr "(``models.py`` 에서) 모델을 변경합니다."

#: ../../intro/tutorial02.txt:357
msgid ""
"Run :djadmin:`python manage.py makemigrations <makemigrations>` to create "
"migrations for those changes"
msgstr ""
":djadmin:`python manage.py makemigrations <makemigrations>` 을 통해 이 변경사항에 대한 "
"migration 을 만드세요."

#: ../../intro/tutorial02.txt:359
msgid ""
"Run :djadmin:`python manage.py migrate <migrate>` to apply those changes to "
"the database."
msgstr ""
":djadmin:`python manage.py migrate <migrate>` 명령을 통해 변경사항을 데이터베이스에 적용하세요."

#: ../../intro/tutorial02.txt:362
msgid ""
"The reason that there are separate commands to make and apply migrations is "
"because you'll commit migrations to your version control system and ship "
"them with your app; they not only make your development easier, they're also"
" useable by other developers and in production."
msgstr ""
"migration 을 만드는 명령과, 적용하는 명령이 분리된 이유는 버전 관리 시스템에 migration 을 커밋할 수 있게 하여 app"
" 과 함께 제공하기 위해서입니다. 이것은 단순히 당신의 개발을 쉽게 해주는 것 뿐 아니라, 다른 개발자들과 운영 환경에서도 유용하게 "
"사용될 수 있습니다."

#: ../../intro/tutorial02.txt:367
msgid ""
"Read the :doc:`django-admin documentation </ref/django-admin>` for full "
"information on what the ``manage.py`` utility can do."
msgstr ""
":doc:`django-admin documentation </ref/django-admin>` 문서에 ``manage.py`` "
"유틸리티가 어떤 일들을 할 수 있는지 알 수 있습니다."

#: ../../intro/tutorial02.txt:371
msgid "Playing with the API"
msgstr "API 가지고 놀기"

#: ../../intro/tutorial02.txt:373
msgid ""
"Now, let's hop into the interactive Python shell and play around with the "
"free API Django gives you. To invoke the Python shell, use this command:"
msgstr ""
"이제, 대화식 Python 쉘에 뛰어들어 Django API 를 자유롭게 가지고 놀아봅시다. Python 쉘을 실행하려면 다음의 명령을 "
"입력합니다:"

#: ../../intro/tutorial02.txt:380
msgid ""
"We're using this instead of simply typing \"python\", because "
":file:`manage.py` sets the ``DJANGO_SETTINGS_MODULE`` environment variable, "
"which gives Django the Python import path to your :file:`mysite/settings.py`"
" file."
msgstr ""
"단순히 \"python\" 이라고 실행하는 대신에, 위의 명령을 실행한 까닭은, :file:`manage.py` 에 설정된 "
"``DJANGO_SETTINGS_MODULE`` 환경변수 때문입니다. 이 환경변수는 :file:`mysite/settings.py` "
"파일에 대한 Python import 경로를 Django 에게 제공하여, 대화식 Python 쉘에서 Django 가 접근할 수 있는 "
"Python 모듈 경로를 그대로 사용 할 수 있습니다. 즉, Django 에서 동작하는 모든 명령을 대화식 Python 쉘에서 그대로 "
"시험해 볼 수 있습니다."

#: ../../intro/tutorial02.txt:384
msgid "Bypassing manage.py"
msgstr "manage.py 안 쓰기"

#: ../../intro/tutorial02.txt:386
msgid ""
"If you'd rather not use :file:`manage.py`, no problem. Just set the "
":envvar:`DJANGO_SETTINGS_MODULE` environment variable to "
"``mysite.settings``, start a plain Python shell, and set up Django:"
msgstr ""
"만약 :file:`manage.py` 파일을 사용하지 않더라도 문제는 없습니다. "
":envvar:`DJANGO_SETTINGS_MODULE` 환경변수를 ``mysite.settings`` 에 설정하고, Python 쉘을"
" 시작한 뒤, 다음과 같이 Django 를 설정하면 됩니다:"

#: ../../intro/tutorial02.txt:395
msgid ""
"If this raises an :exc:`AttributeError`, you're probably using a version of "
"Django that doesn't match this tutorial version. You'll want to either "
"switch to the older tutorial or the newer Django version."
msgstr ""
"만약 :exc:`AttributeError` 가 발생하면, 사용하고 있는 Django 의 버전과 이 튜토리얼에서 사용하는 버전이 다르기 "
"때문일수도 있습니다. 사용하고 있는 Django 버전에 맞는 튜토리얼로 진행하든지, 현재 튜토리얼 버전에 맞는 Django 를 "
"설치해주세요."

#: ../../intro/tutorial02.txt:399
msgid ""
"You must run ``python`` from the same directory :file:`manage.py` is in, or "
"ensure that directory is on the Python path, so that ``import mysite`` "
"works."
msgstr ""
"단, 반드시 :file:`manage.py` 과 같은 디렉토리에서 ``python`` 을 실행하거나, Python 의 import "
"path 에 해당 디렉토리가 추가되어야만 ``import mysite`` 가 제대로 동작합니다."

#: ../../intro/tutorial02.txt:403
msgid ""
"For more information on all of this, see the :doc:`django-admin "
"documentation </ref/django-admin>`."
msgstr ""
"위의 내용에 대한 더 자세한 정보는 :doc:`django-admin documentation </ref/django-admin>` 에서"
" 참고해 주십시요."

#: ../../intro/tutorial02.txt:406
msgid ""
"Once you're in the shell, explore the :doc:`database API "
"</topics/db/queries>`::"
msgstr "쉘에 진입한 후, :doc:`database API </topics/db/queries>` 를 탐험해 보세요:"

#: ../../intro/tutorial02.txt:445
msgid ""
"Wait a minute. ``<Question: Question object>`` is, utterly, an unhelpful "
"representation of this object. Let's fix that by editing the ``Question`` "
"model (in the ``polls/models.py`` file) and adding a "
":meth:`~django.db.models.Model.__str__` method to both ``Question`` and "
"``Choice``:"
msgstr ""
"잠깐만요, ``<Question: Question object>`` 는 이 객체를 설명하는데에 정말 하나도 도움이 안되네요. "
"(``polls/models.py`` 파일의) ``Question`` 모델을 수정하여 "
":meth:`~django.db.models.Model.__str__` 메소드를 ``Question`` 과 ``Choice`` 에 추가해"
" 봅시다."

#: ../../intro/tutorial02.txt:469
msgid ""
"It's important to add :meth:`~django.db.models.Model.__str__` methods to "
"your models, not only for your own convenience when dealing with the "
"interactive prompt, but also because objects' representations are used "
"throughout Django's automatically-generated admin."
msgstr ""
"당신의 모델에 :meth:`~django.db.models.Model.__str__` 메소드를 추가하는것은 객체의 표현을 대화식 "
"프롬프트에서 편하게 보려는 이유 말고도, Django 가 자동으로 생성하는 관리 사이트 에서도 객체의 표현이 사용되기 때문입니다."

#: ../../intro/tutorial02.txt:474
msgid ""
"Note these are normal Python methods. Let's add a custom method, just for "
"demonstration:"
msgstr "이것들은 모두 보통의 Python 메소드입니다. 예시를 위해 수정된 메소드를 추가해 보겠습니다:"

#: ../../intro/tutorial02.txt:491
msgid ""
"Note the addition of ``import datetime`` and ``from django.utils import "
"timezone``, to reference Python's standard :mod:`datetime` module and "
"Django's time-zone-related utilities in :mod:`django.utils.timezone`, "
"respectively. If you aren't familiar with time zone handling in Python, you "
"can learn more in the :doc:`time zone support docs "
"</topics/i18n/timezones>`."
msgstr ""
"``import datetime`` 은 Python 의 표준 모듈인 :mod:`datetime` 모듈이며, ``from "
"django.utils import timezone`` 은 Django  의 시간대 관련 유틸리티인 "
":mod:`django.utils.timezone` 을 의미합니다. 만약 Python 에서 시간대를 조작하는 방법에 대해 익숙하지 "
"않다면, :doc:`시간대 지원 문서 </topics/i18n/timezones>` 에서 더 많은것을 배울 수 있습니다."

#: ../../intro/tutorial02.txt:497
msgid ""
"Save these changes and start a new Python interactive shell by running "
"``python manage.py shell`` again::"
msgstr "변경된 사항을 저장하고, ``python manage.py shell`` 를 다시 실행해보세요:"

#: ../../intro/tutorial02.txt:576
msgid ""
"For more information on model relations, see :doc:`Accessing related objects"
" </ref/models/relations>`. For more on how to use double underscores to "
"perform field lookups via the API, see :ref:`Field lookups <field-lookups-"
"intro>`. For full details on the database API, see our :doc:`Database API "
"reference </topics/db/queries>`."
msgstr ""
"모델의 관계에 대한 더 많은 정보는 :doc:`Accessing related objects </ref/models/relations>`"
" 를 참고하세요. API 에서 이중 밑줄(``__``) 을 이용해서 어떻게 필드를 조회할 수 있는지는 :ref:`Field lookups"
" <field-lookups-intro>` 를 읽어보세요.데이터베이스 API 에 대한 자세한 내용을 보시려면, :doc:`Database"
" API reference </topics/db/queries>` 를 읽어보세요."

#: ../../intro/tutorial02.txt:583
msgid "Introducing the Django Admin"
msgstr "Django Admin 모듈 소개"

#: ../../intro/tutorial02.txt:587
msgid ""
"Generating admin sites for your staff or clients to add, change, and delete "
"content is tedious work that doesn't require much creativity. For that "
"reason, Django entirely automates creation of admin interfaces for models."
msgstr ""
"직원들이나 고객들이 컨텐츠의 내용을 수정하기 위한 관리 사이트를 만드는것은 딱히 창의적일 필요없는 지루한 작업입니다. 이런 이유로, "
"Django 는 모델에 대한 관리용 인터페이스를 모두 자동으로 생성합니다."

#: ../../intro/tutorial02.txt:591
msgid ""
"Django was written in a newsroom environment, with a very clear separation "
"between \"content publishers\" and the \"public\" site. Site managers use "
"the system to add news stories, events, sports scores, etc., and that "
"content is displayed on the public site. Django solves the problem of "
"creating a unified interface for site administrators to edit content."
msgstr ""
"Django 는 ``Lawrence Journal-World`` 신문사의 프로그래머가 처음 개발하였습니다. 이런 태생적인 이유 때문에, "
"\"컨텐츠 게시자\" 와 \"공개\" 사이트의 구분이 명확합니다. 사이트 관리자는 뉴스 기사, 사건, 스포츠 경기 결과 같은 것들을 "
"시스템에 추가합니다. 그렇게 추가된 컨텐츠는 \"공개\" 사이트에 노출됩니다. Django 는 사이트 관리자가 컨텐츠를 편집할 수 있는 "
"통합적인 인터페이스를 생성하는 문제를 해결합니다."

#: ../../intro/tutorial02.txt:597
msgid ""
"The admin isn't intended to be used by site visitors. It's for site "
"managers."
msgstr "관리 사이트는 사이트 방문자를 위한 것이 아니라, 사이트 관리자를 위한 것입니다."

#: ../../intro/tutorial02.txt:601
msgid "Creating an admin user"
msgstr "관리자 생성하기"

#: ../../intro/tutorial02.txt:603
msgid ""
"First we'll need to create a user who can login to the admin site. Run the "
"following command:"
msgstr "우선, 관리 사이트에 로그인 할 수 있는 사용자를 생성해 봅시다. 다음과 같은 명령을 수행합니다."

#: ../../intro/tutorial02.txt:610
msgid "Enter your desired username and press enter."
msgstr "원하는 username 을 입력하고 엔터를 누르세요"

#: ../../intro/tutorial02.txt:616
msgid "You will then be prompted for your desired email address:"
msgstr "그런 다음 원하는 이메일 주소를 입력하라는 메시지가 표시됩니다."

#: ../../intro/tutorial02.txt:622
msgid ""
"The final step is to enter your password. You will be asked to enter your "
"password twice, the second time as a confirmation of the first."
msgstr ""
"마지막으로, 암호를 입력하세요. 암호를 두번 물어보게 되는데, 두번째 입력하는 암호를 올바로 입력했는지를 확인하기 위한 암호입니다. "

#: ../../intro/tutorial02.txt:632
msgid "Start the development server"
msgstr "개발 서버를 실행하세요"

#: ../../intro/tutorial02.txt:634
msgid ""
"The Django admin site is activated by default. Let's start the development "
"server and explore it."
msgstr "Django 의 관리 사이트는 기본으로 활성화 되어 있습니다. 개발 서버를 켜고, 탐험해 봅시다."

#: ../../intro/tutorial02.txt:637
msgid "If the server is not running start it like so:"
msgstr "서버가 기동되지 않았다면 다음과 같이 보입니다:"

#: ../../intro/tutorial02.txt:643
msgid ""
"Now, open a Web browser and go to \"/admin/\" on your local domain -- e.g., "
"http://127.0.0.1:8000/admin/. You should see the admin's login screen:"
msgstr ""
"이제, 웹 브라우져를 열고 로컬 도메인의 \"/admin/\" 으로 이동합니다. 예를들면, "
"http://127.0.0.1:8000/admin/ 으로 접근할 수 있습니다. 그럼 다음과 같이 로그인 화면이 보일겁니다."

#: ../../intro/tutorial02.txt:649
msgid ""
"Since :doc:`translation </topics/i18n/translation>` is turned on by default,"
" the login screen may be displayed in your own language, depending on your "
"browser's settings and if Django has a translation for this language."
msgstr ""
":doc:`translation </topics/i18n/translation>` 가 기본으로 켜져 있기 때문에, 로그인 화면은 당신의 "
"브라우저의 설정에 따라 (Django 가 해당 언어의 번역본이 있다면) 번역된 언어로 표시될 것입니다."

#: ../../intro/tutorial02.txt:654
msgid "Enter the admin site"
msgstr "관리자 사이트로 들어가세요"

#: ../../intro/tutorial02.txt:656
msgid ""
"Now, try logging in with the superuser account you created in the previous "
"step. You should see the Django admin index page:"
msgstr ""
"앞서 생성한 슈퍼유저(superuser) 계정으로 로그인 해봅시다. 다음과 같은 Django 관리 인덱스 페이지가 보일것입니다."

#: ../../intro/tutorial02.txt:662
msgid ""
"You should see a few types of editable content: groups and users. They are "
"provided by :mod:`django.contrib.auth`, the authentication framework shipped"
" by Django."
msgstr ""
"편집 가능한 그룹과 사용자와 같은 몇 종류의 컨텐츠를 볼 수 있습니다. 이것들은 :mod:`django.contrib.auth` 모듈에서"
" 제공되는데, Django 에서 제공되는 인증 프레임워크 입니다."

#: ../../intro/tutorial02.txt:667
msgid "Make the poll app modifiable in the admin"
msgstr "관리 사이트에서 poll app 을 변경가능하도록 만들기"

#: ../../intro/tutorial02.txt:669
msgid "But where's our poll app? It's not displayed on the admin index page."
msgstr "그런데, poll app 이 관리 인덱스 페이지에서 보이지 않네요. 어디에 있을까요?"

#: ../../intro/tutorial02.txt:671
msgid ""
"Just one thing to do: we need to tell the admin that ``Question`` objects "
"have an admin interface. To do this, open the :file:`polls/admin.py` file, "
"and edit it to look like this:"
msgstr ""
"여기서 하나만 더 하면 됩니다. 관리 사이트에 ``Question`` 객체가 관리 인터페이스를 가지고 있다는것을 알려주는 것입니다. "
"이것을 하기 위해서는, :file:`polls/admin.py` 파일을 열어 다음과 같이 편집하면 됩니다."

#: ../../intro/tutorial02.txt:685
msgid "Explore the free admin functionality"
msgstr "자유로운 관리 기능을 탐색하기"

#: ../../intro/tutorial02.txt:687
msgid ""
"Now that we've registered ``Question``, Django knows that it should be "
"displayed on the admin index page:"
msgstr "이제, ``Question`` 을 등록시켰으니 Django 는 이를 알아채고 관리 인덱스 페이지에 이를 표시할 것입니다:"

#: ../../intro/tutorial02.txt:693
msgid ""
"Click \"Questions\". Now you're at the \"change list\" page for questions. "
"This page displays all the questions in the database and lets you choose one"
" to change it. There's the \"What's up?\" question we created earlier:"
msgstr ""
"\"Questions\" 을 클릭하십시요. 그러면 질문들을 위한 \"change list\" 로 이동합니다. 이 페이지는 데이터베이스에 "
"저장된 모든 질문들을 보여주며, 그 중 하나를 선택하여 변경할 수 있습니다. 이전에 등록했던 \"What's up?\" 질문이 있을 "
"것입니다."

#: ../../intro/tutorial02.txt:700
msgid "Click the \"What's up?\" question to edit it:"
msgstr "\"What's up?\" 질문을 클릭하여 수정합니다."

#: ../../intro/tutorial02.txt:705
msgid "Things to note here:"
msgstr "여기서 알아둘 것들:"

#: ../../intro/tutorial02.txt:707
msgid "The form is automatically generated from the ``Question`` model."
msgstr "이 서식은 ``Question`` 모델에서 자동으로 생성되었습니다"

#: ../../intro/tutorial02.txt:709
msgid ""
"The different model field types (:class:`~django.db.models.DateTimeField`, "
":class:`~django.db.models.CharField`) correspond to the appropriate HTML "
"input widget. Each type of field knows how to display itself in the Django "
"admin."
msgstr ""
"모델의 각 필드 유형들은 (:class:`~django.db.models.DateTimeField`, "
":class:`~django.db.models.CharField`) 적절한 HTML 입력 위젯으로 표현됩니다. 필드의 각 유형들은 "
"Django 관리 사이트에서 어떻게 표현해되어야 할지 알고 있습니다."

#: ../../intro/tutorial02.txt:714
msgid ""
"Each :class:`~django.db.models.DateTimeField` gets free JavaScript "
"shortcuts. Dates get a \"Today\" shortcut and calendar popup, and times get "
"a \"Now\" shortcut and a convenient popup that lists commonly entered times."
msgstr ""
"각각의 :class:`~django.db.models.DateTimeField` 는 JavaScript 로 작성된 단축 기능과 "
"연결됩니다. 날짜는 \"오늘\"(\"Today\") 버튼과 달력 팝업에서 입력할 수 있으며, 시간은 \"지금\"(\"Now\") 버튼과 "
"일반적으로 입력하는 시간들을 제공하는 편리한 팝업을 통해서도 입력할 수 있습니다."

#: ../../intro/tutorial02.txt:718
msgid "The bottom part of the page gives you a couple of options:"
msgstr "페이지의 아래 부분에서 다음과 같은 몇가지 옵션을 제공합니다."

#: ../../intro/tutorial02.txt:720
msgid ""
"Save -- Saves changes and returns to the change-list page for this type of "
"object."
msgstr "저장(Save) -- 이 유형의 객체에 대한 변경사항을 저장하고, 변경된 목록 페이지를 보여줍니다"

#: ../../intro/tutorial02.txt:723
msgid ""
"Save and continue editing -- Saves changes and reloads the admin page for "
"this object."
msgstr ""
"저장 및 편집 계속(Save and continue editing) -- 이 객체에 대한 변경사항을 저장하고, 현재 편집창을 갱신합니다"

#: ../../intro/tutorial02.txt:726
msgid ""
"Save and add another -- Saves changes and loads a new, blank form for this "
"type of object."
msgstr ""
"저장 및 다른 이름으로 추가(Save and add another) -- 변경사항을 저장하고, 이 유형의 객체에 대한 비어있는 새로운 "
"입력창을 불러옵니다"

#: ../../intro/tutorial02.txt:729
msgid "Delete -- Displays a delete confirmation page."
msgstr "삭제(Delete) -- 삭제를 확인하는 페이지를 띄웁니다."

#: ../../intro/tutorial02.txt:731
msgid ""
"If the value of \"Date published\" doesn't match the time when you created "
"the question in :doc:`Tutorial 1</intro/tutorial01>`, it probably means you "
"forgot to set the correct value for the :setting:`TIME_ZONE` setting. Change"
" it, reload the page and check that the correct value appears."
msgstr ""
"만약 \"Date published\" 의 값이 :doc:`Tutorial 1</intro/tutorial01>` 에서 질문을 "
"생성했을때의 시간과 일치하지 않는다면, :setting:`TIME_ZONE` (시간대) 설정을 깜빡 하신것일지도 모릅니다. 이 설정을 "
"바꾸시고 다시 페이지를 불러오시면 올바른 값이 표현됩니다."

#: ../../intro/tutorial02.txt:736
msgid ""
"Change the \"Date published\" by clicking the \"Today\" and \"Now\" "
"shortcuts. Then click \"Save and continue editing.\" Then click \"History\" "
"in the upper right. You'll see a page listing all changes made to this "
"object via the Django admin, with the timestamp and username of the person "
"who made the change:"
msgstr ""
"\"Date published\" 의 값을 \"오늘\"(\"Today\") 과 \"지금\"(\"Now\") 단축버튼을 눌러 바꾸십시요. "
"그런 후, \"저장 및 편집 계속\"(\"Save and continue editing\") 을 누르십시요. 그런 후, 우측 상단의 "
"\"히스토리\"(\"History\") 버튼을 누르십시요. Django 관리사이트를 통해 누가(username) 언제(timestamp)"
" 무엇을 바꾸었는지 목록을 확인할 수 있습니다."

#: ../../intro/tutorial02.txt:744
msgid ""
"When you're comfortable with the models API and have familiarized yourself "
"with the admin site, read :doc:`part 3 of this tutorial</intro/tutorial03>` "
"to learn about how to add more views to our polls app."
msgstr ""
"모델 API 와 관리 사이트에 익숙해 지셨다면, :doc:`이 튜토리얼의 3번째 파트</intro/tutorial03>` 를 읽어 어떻게"
" polls 앱에 view 를 추가할 수 있는지 배워보세요."

#: ../../intro/tutorial03.txt:3
msgid "Writing your first Django app, part 3"
msgstr "첫 번째 장고 앱 작성하기, part 3"

#: ../../intro/tutorial03.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 2 </intro/tutorial02>` left off. "
"We're continuing the Web-poll application and will focus on creating the "
"public interface -- \"views.\""
msgstr ""
"이 튜토리얼은 :doc:`Tutorial 2 </intro/tutorial02>` 에서 이어집니다. 이제 poll 어플리케이션에 공개 "
"인터페이스인 \"view\" 를 추가해 보겠습니다."

#: ../../intro/tutorial03.txt:10
msgid "Overview"
msgstr "개요"

#: ../../intro/tutorial03.txt:12
msgid ""
"A view is a \"type\" of Web page in your Django application that generally "
"serves a specific function and has a specific template. For example, in a "
"blog application, you might have the following views:"
msgstr ""
"view 는 Django 어플리케이션이 일반적으로 특정 기능과 템플릿을 제공하는 웹페이지의 한 종류 입니다. 예를 들어, 블로그 "
"어플리케이션의 경우 다음과 같은 view 를 가질 수 있습니다."

#: ../../intro/tutorial03.txt:16
msgid "Blog homepage -- displays the latest few entries."
msgstr "Blog 홈페이지 -- 가장 최근의 항목들을 보여줍니다"

#: ../../intro/tutorial03.txt:18
msgid "Entry \"detail\" page -- permalink page for a single entry."
msgstr "항목 \"세부\"(detail) 페이지 -- 하나의 항목에 연결하는 영구적인 링크(permalink)를 제공합니다."

#: ../../intro/tutorial03.txt:20
msgid ""
"Year-based archive page -- displays all months with entries in the given "
"year."
msgstr "년도별 축적 페이지 -- 주어진 연도의 모든 월별 항목들을 표시합니다."

#: ../../intro/tutorial03.txt:23
msgid ""
"Month-based archive page -- displays all days with entries in the given "
"month."
msgstr "월별 축적 페이지 -- 주어진 월의 날짜별 항목들을 표시합니다."

#: ../../intro/tutorial03.txt:26
msgid "Day-based archive page -- displays all entries in the given day."
msgstr "날짜별 축적 페이지 -- 주어진 날짜의 모든 항목들을 표시합니다."

#: ../../intro/tutorial03.txt:28
msgid "Comment action -- handles posting comments to a given entry."
msgstr "댓글 기능 -- 특정 항목의 댓글을 다룰 수 있는 기능"

#: ../../intro/tutorial03.txt:30
msgid "In our poll application, we'll have the following four views:"
msgstr "우리가 만드는 poll 어플리케이션에서 다음과 같은 네개의 view 를 만들어 보겠습니다."

#: ../../intro/tutorial03.txt:32
msgid "Question \"index\" page -- displays the latest few questions."
msgstr "질문 \"색인\" 페이지 -- 최근의 질문들을 표시합니다."

#: ../../intro/tutorial03.txt:34
msgid ""
"Question \"detail\" page -- displays a question text, with no results but "
"with a form to vote."
msgstr "질문 \"세부\" 페이지 -- 질문 내용과, 투표할 수 있는 서식을 표시합니다."

#: ../../intro/tutorial03.txt:37
msgid "Question \"results\" page -- displays results for a particular question."
msgstr "질문 \"결과\" 페이지 -- 특정 질문에 대한 결과를 표시합니다"

#: ../../intro/tutorial03.txt:39
msgid ""
"Vote action -- handles voting for a particular choice in a particular "
"question."
msgstr "투표 기능 -- 특정 질문에 대해 특정 선택을 할 수 있는 투표 기능을 제공합니다."

#: ../../intro/tutorial03.txt:42
msgid ""
"In Django, web pages and other content are delivered by views. Each view is "
"represented by a simple Python function (or method, in the case of class-"
"based views). Django will choose a view by examining the URL that's "
"requested (to be precise, the part of the URL after the domain name)."
msgstr ""
"Django 에서는, 웹 페이지와 기타 내용들이 view 에 의해 제공됩니다. 각 view 는 간단한 Python 함수(혹은 클래스를 "
"사용할 경우엔 메소드) 를 사용하여 작성됩니다. Django 는 요청된 URL 을 조사하여 view 를 선택합니다. (조금 더 정확히 "
"말하자면, 도메인 네임에 따라오는 URL 부분을 이용합니다.)"

#: ../../intro/tutorial03.txt:47
msgid ""
"Now in your time on the web you may have come across such beauties as "
"\"ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B\"."
" You will be pleased to know that Django allows us much more elegant *URL "
"patterns* than that."
msgstr ""
"웹에서 "
"\"ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B\""
" 같은 못생긴 주소를 본 적이 있을겁니다. 다행스럽게도 Django 에서는 적어도 이것보단 훨씬 예쁜 *URL 패턴* 을 만들 수 "
"있습니다."

#: ../../intro/tutorial03.txt:52
msgid ""
"A URL pattern is simply the general form of a URL - for example: "
"``/newsarchive/<year>/<month>/``."
msgstr ""
"URL 패턴은 URL 을 간단하게 일반화 시킨것을 말합니다. 예를 들어, ``/newsarchive/<year>/<month>/`` 같이"
" 표현할 수 있습니다."

#: ../../intro/tutorial03.txt:55
msgid ""
"To get from a URL to a view, Django uses what are known as 'URLconfs'. A "
"URLconf maps URL patterns (described as regular expressions) to views."
msgstr ""
"view 를 URL 에서 얻기위해, Django 는 `URLconfs` 라고 부르는 것을 사용합니다. URLconf 는 URL 패턴(정규"
" 표현식으로 표현)과 view 를 연결한 것입니다."

#: ../../intro/tutorial03.txt:58
msgid ""
"This tutorial provides basic instruction in the use of URLconfs, and you can"
" refer to :mod:`django.urls` for more information."
msgstr ""
"이 튜토리얼은 URLconfs 를 사용하기 위한 기본적인 절차를 안내합니다. 더 자세한 정보를 얻으시려면 "
":mod:`django.urls` 를 참고해 주십시요."

#: ../../intro/tutorial03.txt:62
msgid "Writing more views"
msgstr "조금 더 view 작성하기"

#: ../../intro/tutorial03.txt:64
msgid ""
"Now let's add a few more views to ``polls/views.py``. These views are "
"slightly different, because they take an argument:"
msgstr ""
"이제, ``polls/views.py`` 에 view 를 추가해 봅시다. 이 view 들은 인수를 받기 때문에 조금 모양이 다릅니다."

#: ../../intro/tutorial03.txt:80
msgid ""
"Wire these new views into the ``polls.urls`` module by adding the following "
":func:`~django.conf.urls.url` calls:"
msgstr ""
"``polls.urls`` 모듈에서 새로 작성된 view 들을 연결하기 위해 다음과 같이 "
":func:`~django.conf.urls.url` 함수 호출을 추가합니다."

#: ../../intro/tutorial03.txt:101
msgid ""
"Take a look in your browser, at \"/polls/34/\". It'll run the ``detail()`` "
"method and display whatever ID you provide in the URL. Try "
"\"/polls/34/results/\" and \"/polls/34/vote/\" too -- these will display the"
" placeholder results and voting pages."
msgstr ""
"브라우저에 \"/polls/34/\" 를 입력해 보세요. 이 주소에 접속하면 ``detail()`` 함수를 호출하여 URL 에 입력한 "
"ID 를 출력할 것입니다. \"/polls/34/results/\" 와 \"/polls/34/vote/\" 도 실행해 보세요. 투표 "
"결과와 투표 페이지의 뼈대가 되는 페이지가 출력될 것입니다."

#: ../../intro/tutorial03.txt:106
msgid ""
"When somebody requests a page from your website -- say, \"/polls/34/\", "
"Django will load the ``mysite.urls`` Python module because it's pointed to "
"by the :setting:`ROOT_URLCONF` setting. It finds the variable named "
"``urlpatterns`` and traverses the regular expressions in order. After "
"finding the match at ``'^polls/'``, it strips off the matching text "
"(``\"polls/\"``) and sends the remaining text -- ``\"34/\"`` -- to the "
"'polls.urls' URLconf for further processing. There it matches "
"``r'^(?P<question_id>[0-9]+)/$'``, resulting in a call to the ``detail()`` "
"view like so::"
msgstr ""
"사용자가 웹사이트의 페이지를 요청할때, (\"/polls/34\" 를 입력했다고 가정하겠습니다.) Django 는 "
"``mysite.urls`` 모듈을 불러옵니다. :setting:`ROOT_URLCONF` 설정에 의해 설정되어 있기 때문입니다. "
"``mysite.urls`` 에서 ``urlpatterns`` 이라는 변수를 찾아, 정규표현식을 순서대로 따라갑니다. "
"``'^polls/'`` 를 찾은 후, 일치하는 문자열(``\"polls/\"``)을 버립니다. 이후 남은 문자인 ``\"34/\"`` "
"를 `polls.urls` URLconf 에게 전달하여 남은 처리를 진행합니다. 이제 "
"``r'^(?P<question_id>[0-9]+)/$'`` 에 패턴이 일치하고, 그 결과로 ``detail()`` 함수가 호출됩니다. "

#: ../../intro/tutorial03.txt:117
msgid ""
"The ``question_id='34'`` part comes from ``(?P<question_id>[0-9]+)``. Using "
"parentheses around a pattern \"captures\" the text matched by that pattern "
"and sends it as an argument to the view function; ``?P<question_id>`` "
"defines the name that will be used to identify the matched pattern; and "
"``[0-9]+`` is a regular expression to match a sequence of digits (i.e., a "
"number)."
msgstr ""
"``question_id='34'`` 부분은 ``(?P<question_id>[0-9]+)`` 에서 왔습니다. 패턴을 괄호로 감싸 "
"일치하는 패턴의 문자열을 잡아낸 후, 이를 view 함수의 인수로서 넘깁니다. ``?P<question_id>`` 는 일치하는 패턴을 "
"구별하기 위해 정의한 이름입니다. 그리고 ``[0-9]+`` 는 연속된 숫자의 나열을 잡아내기 위한 정규 표현식입니다."

#: ../../intro/tutorial03.txt:123
msgid ""
"Because the URL patterns are regular expressions, there really is no limit "
"on what you can do with them. And there's no need to add URL cruft such as "
"``.html`` -- unless you want to, in which case you can do something like "
"this::"
msgstr ""
"URL 패턴은 정규 표현식 입니다. 사용하는데에 사실상 거의 제약이 없습니다. 그리고 URL 에 ``.html`` 같은 불필요한 것들을 "
"붙일 필요가 없습니다. 만약 ``.html`` 같은 것을 뒤에 붙이고 싶다면, 아래와 같이 할 수 있습니다."

#: ../../intro/tutorial03.txt:130
msgid "But, don't do that. It's silly."
msgstr "그런데 바보같아 보이니까 하지 마세요."

#: ../../intro/tutorial03.txt:133
msgid "Write views that actually do something"
msgstr "view 가 실제로 뭔가 하도록 만들기"

#: ../../intro/tutorial03.txt:135
msgid ""
"Each view is responsible for doing one of two things: returning an "
":class:`~django.http.HttpResponse` object containing the content for the "
"requested page, or raising an exception such as :exc:`~django.http.Http404`."
" The rest is up to you."
msgstr ""
"각 view 는 두가지중 하나를 하도록 되어 있습니다. 요청된 페이지의 내용이 담긴 "
":class:`~django.http.HttpResponse` 객체를 반환하거나, 혹은 :exc:`~django.http.Http404`"
" 같은 예외를 발생하게 해야합니다. 나머지는 당신에게 달렸습니다."

#: ../../intro/tutorial03.txt:140
msgid ""
"Your view can read records from a database, or not. It can use a template "
"system such as Django's -- or a third-party Python template system -- or "
"not. It can generate a PDF file, output XML, create a ZIP file on the fly, "
"anything you want, using whatever Python libraries you want."
msgstr ""
"당신이 작성한 view 는 데이터베이스의 레코드를 읽을 수도 있습니다. 또한 view 는 Django 나, Python 에서 서드파티로 "
"제공되는 템플릿 시스템을 사용 할 수도 있습니다. view 는 PDF 를 생성하거나, XML 출력을 하거나, 실시간으로 ZIP 파일을 "
"만들 수 있습니다. view 는 당신이 원하는 무엇이든, Python 의 어떤 라이브러리라도 사용할 수 있습니다."

#: ../../intro/tutorial03.txt:145
msgid ""
"All Django wants is that :class:`~django.http.HttpResponse`. Or an "
"exception."
msgstr ""
"모든 Django 는 :class:`~django.http.HttpResponse` 객체나, 혹은 예외(exception) 를 원합니다."

#: ../../intro/tutorial03.txt:147
msgid ""
"Because it's convenient, let's use Django's own database API, which we "
"covered in :doc:`Tutorial 2 </intro/tutorial02>`. Here's one stab at a new "
"``index()`` view, which displays the latest 5 poll questions in the system, "
"separated by commas, according to publication date:"
msgstr ""
"왜냐면, 그렇게 다루는게 편리하기 때문입니다. :doc:`Tutorial 2 </intro/tutorial02>` 의 예제에서 "
"Django 가 자신만의 데이터베이스 API 를 사용해봅시다. 새로운 ``index()`` view 하나를 호출했을 때, 시스템에 저장된"
" 최소한 5 개의 투표 질문이 콤마로 분리되어, 발행일에 따라 출력됩니다."

#: ../../intro/tutorial03.txt:167
msgid ""
"There's a problem here, though: the page's design is hard-coded in the view."
" If you want to change the way the page looks, you'll have to edit this "
"Python code. So let's use Django's template system to separate the design "
"from Python by creating a template that the view can use."
msgstr ""
"여기 몇가지 문제가 있습니다. view 에서 페이지의 디자인이 하드코딩 되어 있습니다. 만약 페이지가 보여지는 방식을 바꾸고 싶다면, 이"
" Python 코드를 편집해야만 할겁니다. 그럼, view 가 사용할 수 있는 템플릿을 작성하여, Python 코드로부터 디자인을 "
"분리하도록 Django 의 템플릿 시스템을 사용해 봅시다."

#: ../../intro/tutorial03.txt:172
msgid ""
"First, create a directory called ``templates`` in your ``polls`` directory. "
"Django will look for templates in there."
msgstr ""
"우선, ``polls`` 디렉토리에 ``templates`` 라는 디렉토리를 만듭니다. Django 는 여기서 템플릿을 찾게될 것입니다."

#: ../../intro/tutorial03.txt:175
msgid ""
"Your project's :setting:`TEMPLATES` setting describes how Django will load "
"and render templates. The default settings file configures a "
"``DjangoTemplates`` backend whose :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` "
"option is set to ``True``. By convention ``DjangoTemplates`` looks for a "
"\"templates\" subdirectory in each of the :setting:`INSTALLED_APPS`."
msgstr ""
"project 의 :setting:`TEMPLATES` 설정에는 Django 가 어떻게 template 을 불러오고 랜더링 할 것인지 를"
" 서술합니다. 기본 설정 파일은 :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 옵션이 ``True`` 로 "
"설정된 ``DjangoTemplates`` 백엔드를 구성합니다 관례에 따라, ``DjangoTemplates`` 은 각 "
":setting:`INSTALLED_APPS` 디렉토리의 \"templates\" 하위 디렉토리를 탐색합니다."

#: ../../intro/tutorial03.txt:181
msgid ""
"Within the ``templates`` directory you have just created, create another "
"directory called ``polls``, and within that create a file called "
"``index.html``. In other words, your template should be at "
"``polls/templates/polls/index.html``. Because of how the ``app_directories``"
" template loader works as described above, you can refer to this template "
"within Django simply as ``polls/index.html``."
msgstr ""
"방금 만든 ``templates`` 디렉토리 내에 ``polls`` 라는 디렉토리를 생성하고, 그 안에 ``index.html`` 을 "
"만듭니다. 즉, template 은 ``polls/templates/polls/index.html`` 과 같은 형태가 됩니다. "
"``app_directories`` template 로더가 그렇게 동작하기 때문에, Django 에서 이 template 을 단순히 "
"``polls/index.html`` 로 참조할 수 있습니다"

#: ../../intro/tutorial03.txt:188
msgid "Template namespacing"
msgstr "템플릿 네임스페이싱"

#: ../../intro/tutorial03.txt:190
msgid ""
"Now we *might* be able to get away with putting our templates directly in "
"``polls/templates`` (rather than creating another ``polls`` subdirectory), "
"but it would actually be a bad idea. Django will choose the first template "
"it finds whose name matches, and if you had a template with the same name in"
" a *different* application, Django would be unable to distinguish between "
"them. We need to be able to point Django at the right one, and the easiest "
"way to ensure this is by *namespacing* them. That is, by putting those "
"templates inside *another* directory named for the application itself."
msgstr ""
"``polls/templates/polls`` 라고 만들 필요 없이, 그냥 ``polls/templates`` 에 넣어도 되지 않을까? "
"라고 생각할지도 모릅니다. 그러나 이것은 별로 좋은 생각이 아닙니다. Django 는 이름이 일치하는 첫번째 template 을 "
"선택하는데, 만약 동일한 template 이름이 다른 어플리케이션에 있을 경우 Django 는 이 둘간의 차이를 구분하지 못합니다. "
"Django 에게 정확한 template 을 지정하기 위해서 가장 편리한 방법은 *이름공간* 으로 구분짓는 것인데, 어플리케이션의 "
"이름으로 된 디렉토리에 이러한 template 들을 넣으면 됩니다."

#: ../../intro/tutorial03.txt:199
msgid "Put the following code in that template:"
msgstr "템플릿에 다음과 같은 코드를 입력합니다."

#: ../../intro/tutorial03.txt:214
msgid ""
"Now let's update our ``index`` view in ``polls/views.py`` to use the "
"template:"
msgstr ""
"이제, template 을 이용하여 ``polls/views.py`` 에 ``index`` view 를 업데이트 해보도록 하겠습니다."

#: ../../intro/tutorial03.txt:233
msgid ""
"That code loads the template called  ``polls/index.html`` and passes it a "
"context. The context is a dictionary mapping template variable names to "
"Python objects."
msgstr ""
"이 코드는 ``polls/index.html`` template 을 불러온 후, context 를 전달합니다. context 는 "
"template 에서 쓰이는 변수명과, Python 의 객체를 연결하는 사전형 값입니다."

#: ../../intro/tutorial03.txt:237
msgid ""
"Load the page by pointing your browser at \"/polls/\", and you should see a "
"bulleted-list containing the \"What's up\" question from :doc:`Tutorial 2 "
"</intro/tutorial02>`. The link points to the question's detail page."
msgstr ""
"브라우저에서 \"/polls/\" 페이지를 불러오면, :doc:`Tutorial 2</intro/tutorial02>` 에서 작성한 "
"\"What's up\" 질문이 포함된 리스트가 표시됩니다. 표시된 질문의 링크는 해당 질문에 대한 세부 페이지를 가르킵니다. "

#: ../../intro/tutorial03.txt:242
msgid "A shortcut: :func:`~django.shortcuts.render`"
msgstr "지름길: :func:`~django.shortcuts.render`"

#: ../../intro/tutorial03.txt:244
msgid ""
"It's a very common idiom to load a template, fill a context and return an "
":class:`~django.http.HttpResponse` object with the result of the rendered "
"template. Django provides a shortcut. Here's the full ``index()`` view, "
"rewritten:"
msgstr ""
"template 에 context 를 채워넣어 표현한 결과를 :class:`~django.http.HttpResponse` 객체와 함께 "
"돌려주는 구문은 자주 쓰는 용법입니다. 따라서 Django 는 이런 표현을 쉽게 표현할 수 있도록 단축 기능(shortcuts)을 "
"제공합니다. ``index()`` view 를 단축 기능으로 작성하면 다음과 같습니다."

#: ../../intro/tutorial03.txt:262
msgid ""
"Note that once we've done this in all these views, we no longer need to "
"import :mod:`~django.template.loader` and :class:`~django.http.HttpResponse`"
" (you'll want to keep ``HttpResponse`` if you still have the stub methods "
"for ``detail``, ``results``, and ``vote``)."
msgstr ""
"모든 view 에 적용한다면, 더 이상 :mod:`~django.template.loader` 와 "
":class:`~django.http.HttpResponse` 를 import 하지 않아도 됩니다. (만약 ``detail``, "
"``results``, ``vote`` 에서 stub 메소드를 가지고 있다면, ``HttpResponse`` 를 유지해야 할 것입니다.)"

#: ../../intro/tutorial03.txt:267
msgid ""
"The :func:`~django.shortcuts.render` function takes the request object as "
"its first argument, a template name as its second argument and a dictionary "
"as its optional third argument. It returns an "
":class:`~django.http.HttpResponse` object of the given template rendered "
"with the given context."
msgstr ""
":func:`~django.shortcuts.render` 함수는 request 객체를 첫번째 인수로 받고, template 이름을 "
"두번째 인수로 받으며, context 사전형 객체를 세전째 선택적(optional) 인수로 받습니다. 인수로 지정된 context 로 "
"표현된 template 의 :class:`~django.http.HttpResponse` 객체가 반환됩니다."

#: ../../intro/tutorial03.txt:273
msgid "Raising a 404 error"
msgstr "404 에러 일으키기"

#: ../../intro/tutorial03.txt:275
msgid ""
"Now, let's tackle the question detail view -- the page that displays the "
"question text for a given poll. Here's the view:"
msgstr ""
"이제, 질문의 detail view 에 태클을 걸어보겠습니다. detail view 는 지정된 투표의 질문 내용을 보여줍니다. 다음과 "
"같습니다: "

#: ../../intro/tutorial03.txt:293
msgid ""
"The new concept here: The view raises the :exc:`~django.http.Http404` "
"exception if a question with the requested ID doesn't exist."
msgstr ""
"여기 새로운 내용이 추가되었습니다. view 는 요청된 질문의 ID 가 없을 경우 :exc:`~django.http.Http404` "
"예외를 발생시킵니다. "

#: ../../intro/tutorial03.txt:296
msgid ""
"We'll discuss what you could put in that ``polls/detail.html`` template a "
"bit later, but if you'd like to quickly get the above example working, a "
"file containing just:"
msgstr ""
"조금 후에 ``polls/detail.html`` template 에 무엇을 넣을 수 있는지 논의하겠지만, 일단 위의 예제를 동작시키기 "
"위해 아래의 내용이 들어있는 파일을 작성하세요."

#: ../../intro/tutorial03.txt:305
msgid "will get you started for now."
msgstr "이제 시작해도 됩니다."

#: ../../intro/tutorial03.txt:308
msgid "A shortcut: :func:`~django.shortcuts.get_object_or_404`"
msgstr "지름길: :func:`~django.shortcuts.get_object_or_404`"

#: ../../intro/tutorial03.txt:310
msgid ""
"It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get`"
" and raise :exc:`~django.http.Http404` if the object doesn't exist. Django "
"provides a shortcut. Here's the ``detail()`` view, rewritten:"
msgstr ""
"만약 객체가 존재하지 않을 때 :meth:`~django.db.models.query.QuerySet.get` 을 사용하여 "
":exc:`~django.http.Http404` 예외를 발생시키는것은 자주 쓰이는 용법입니다. Django 에서 이 기능에 대한 단축 "
"기능을 제공합니다. ``detail()`` view 를 단축 기능으로 작성하면 다음과 같습니다."

#: ../../intro/tutorial03.txt:325
msgid ""
"The :func:`~django.shortcuts.get_object_or_404` function takes a Django "
"model as its first argument and an arbitrary number of keyword arguments, "
"which it passes to the :meth:`~django.db.models.query.QuerySet.get` function"
" of the model's manager. It raises :exc:`~django.http.Http404` if the object"
" doesn't exist."
msgstr ""
":func:`~django.shortcuts.get_object_or_404` 함수는 Django 모델을 첫번째 인자로 받고, 몇개의 "
"키워드 인수를 모델 관리자의 :meth:`~django.db.models.query.QuerySet.get` 함수에 넘깁니다. 만약 "
"객체가 존재하지 않을 경우, :exc:`~django.http.Http404` 예외가 발생합니다."

#: ../../intro/tutorial03.txt:333
msgid ""
"Why do we use a helper function :func:`~django.shortcuts.get_object_or_404` "
"instead of automatically catching the "
":exc:`~django.core.exceptions.ObjectDoesNotExist` exceptions at a higher "
"level, or having the model API raise :exc:`~django.http.Http404` instead of "
":exc:`~django.core.exceptions.ObjectDoesNotExist`?"
msgstr ""
"상위 계층에서 :exc:`~django.core.exceptions.ObjectDoesNotExist` 예외를 자동으로 잡아 내는 대신 "
":func:`~django.shortcuts.get_object_or_404` 도움 함수(helper functoin)를 사용하거나, "
":exc:`~django.core.exceptions.ObjectDoesNotExist` 예외를 사용하는 대신 "
":exc:`~django.http.Http404` 를 사용하는 이유는 무엇일까요?"

#: ../../intro/tutorial03.txt:339
msgid ""
"Because that would couple the model layer to the view layer. One of the "
"foremost design goals of Django is to maintain loose coupling. Some "
"controlled coupling is introduced in the :mod:`django.shortcuts` module."
msgstr ""
"왜냐하면, model 계층을 view 계층에 연결하는 방법이기 때문입니다. Django 의 중요한 설계 목표는, 약결합(loose "
"coupling)을 관리하는데에 있습니다. 일부 제어된 결합이 :mod:`django.shortcuts` 모듈에서 도입되었습니다."

#: ../../intro/tutorial03.txt:343
msgid ""
"There's also a :func:`~django.shortcuts.get_list_or_404` function, which "
"works just as :func:`~django.shortcuts.get_object_or_404` -- except using "
":meth:`~django.db.models.query.QuerySet.filter` instead of "
":meth:`~django.db.models.query.QuerySet.get`. It raises "
":exc:`~django.http.Http404` if the list is empty."
msgstr ""
"또한, :func:`~django.shortcuts.get_object_or_404` 함수 처럼 동작하는 "
":func:`~django.shortcuts.get_list_or_404` 함수가 있습니다. "
":meth:`~django.db.models.query.QuerySet.get` 대신 "
":meth:`~django.db.models.query.QuerySet.filter` 를 쓴다는 것이 다릅니다. 리스트가 비어있을 경우,"
" :exc:`~django.http.Http404` 예외를 발생시킵니다."

#: ../../intro/tutorial03.txt:350
msgid "Use the template system"
msgstr "Template 시스템 사용하기"

#: ../../intro/tutorial03.txt:352
msgid ""
"Back to the ``detail()`` view for our poll application. Given the context "
"variable ``question``, here's what the ``polls/detail.html`` template might "
"look like:"
msgstr ""
"poll 어플리케이션의 ``detail()`` view 로 되돌아 가봅시다. context 변수 ``question`` 이 주어졌을때, "
"``polls/detail.html`` 라는 template 이 어떻게 보이는지 봅시다."

#: ../../intro/tutorial03.txt:366
msgid ""
"The template system uses dot-lookup syntax to access variable attributes. In"
" the example of ``{{ question.question_text }}``, first Django does a "
"dictionary lookup on the object ``question``. Failing that, it tries an "
"attribute lookup -- which works, in this case. If attribute lookup had "
"failed, it would've tried a list-index lookup."
msgstr ""
"template 시스템은 변수의 속성에 접근하기 위해 점-탐색(dot-lookup) 문법을 사용합니다. 예제의 ``{{ "
"question.question_text }}`` 구문을 보면, Django 는 먼저 ``question`` 객체에 대해 사전형으로 "
"탐색합니다. 탐색에 실패하게 되면 속성값으로 탐색합니다. (이 예에서는 속성값에서 탐색이 완료됩니다만) 만약 속성 탐색에도 실패한다면 "
"리스트의 인덱스 탐색을 시도하게 됩니다. "

#: ../../intro/tutorial03.txt:372
msgid ""
"Method-calling happens in the :ttag:`{% for %}<for>` loop: "
"``question.choice_set.all`` is interpreted as the Python code "
"``question.choice_set.all()``, which returns an iterable of ``Choice`` "
"objects and is suitable for use in the :ttag:`{% for %}<for>` tag."
msgstr ""
":ttag:`{% for %}<for>` 반복 구문에서 메소드 호출이 일어납니다. ``question.choice_set.all`` 은 "
"Python 에서 ``question.choice_set.all()`` 코드로 해석되는데, 이때 반환된 ``Choice`` 객체의 "
"반복자는 :ttag:`{% for %}<for>` 에서 사용하기 적당합니다."

#: ../../intro/tutorial03.txt:377
msgid ""
"See the :doc:`template guide </topics/templates>` for more about templates."
msgstr ""
"template 에 대한 더 많은 정보는 :doc:`template 지침서 </topics/templates>` 를 참고하세요"

#: ../../intro/tutorial03.txt:380
msgid "Removing hardcoded URLs in templates"
msgstr "Template 에서 하드코딩된 URL 을 제거하기"

#: ../../intro/tutorial03.txt:382
msgid ""
"Remember, when we wrote the link to a question in the ``polls/index.html`` "
"template, the link was partially hardcoded like this:"
msgstr ""
"기억하셔야 할 것은, ``polls/index.html`` template 에 링크를 적으면, 이 링크는 다음과 같이 부분적으로 하드코딩"
" 됩니다."

#: ../../intro/tutorial03.txt:389
msgid ""
"The problem with this hardcoded, tightly-coupled approach is that it becomes"
" challenging to change URLs on projects with a lot of templates. However, "
"since you defined the name argument in the :func:`~django.conf.urls.url` "
"functions in the ``polls.urls`` module, you can remove a reliance on "
"specific URL paths defined in your url configurations by using the ``{% url "
"%}`` template tag:"
msgstr ""
"이러한 하드코딩된 강결합 접근법의 문제는, 수많은 template 을 가진 project 의 URL 을 바꾸는게 어려운 일이 된다는 "
"점입니다. 그러나, 이미 ``polls.urls`` 모듈의 :func:`~django.conf.urls.url` 함수에서 인수의 이름을 "
"정의 했으므로 이를 ``{% url %}`` template 태그에서 사용하여 특정 URL 경로의 의존성을 제거할 수 있습니다. "

#: ../../intro/tutorial03.txt:399
msgid ""
"The way this works is by looking up the URL definition as specified in the "
"``polls.urls`` module. You can see exactly where the URL name of 'detail' is"
" defined below::"
msgstr ""
"이것이 ``polls.urls`` 모듈에 서술된 URL 의 정의를 탐색하는 식으로 동작합니다. 다음과 같이 'detail' 이라는 이름의"
" URL 이 어떻게 정의되어 있는지 확인할 수 있습니다."

#: ../../intro/tutorial03.txt:408
msgid ""
"If you want to change the URL of the polls detail view to something else, "
"perhaps to something like ``polls/specifics/12/`` instead of doing it in the"
" template (or templates) you would change it in ``polls/urls.py``::"
msgstr ""
"만약 detail view 의 URL 을 ``polls/specifics/12/`` 로 바꾸고 싶다면, template 에서 바꾸는 것이"
" 아니라 ``polls/urls.py`` 에서 바꿔야 합니다.::"

#: ../../intro/tutorial03.txt:418
msgid "Namespacing URL names"
msgstr "URL 의 이름공간(namespace) 나누기"

#: ../../intro/tutorial03.txt:420
msgid ""
"The tutorial project has just one app, ``polls``. In real Django projects, "
"there might be five, ten, twenty apps or more. How does Django differentiate"
" the URL names between them? For example, the ``polls`` app has a ``detail``"
" view, and so might an app on the same project that is for a blog. How does "
"one make it so that Django knows which app view to create for a url when "
"using the ``{% url %}`` template tag?"
msgstr ""
"튜토리얼의 project 는 하나의 ``polls`` 라는 app 하나만 가지고 진행했습니다. 실제 Django 의 project 는 "
"app 이 몇개라도 올 수 있습니다. Django 는 이 app 들의 URL 을 어떻게 구별해 낼까요? 예를 들어, ``polls`` "
"app 은 ``detail`` 이라는 view 를 가지고 있고, 동일한 project 에 블로그를 위한 app 이 있을수도 있습니다. "
"Django 가 ``{% url %}`` template 태그를 사용할 때, 어떤 app 의 view 에서 URL 을 생성할지 알 수 "
"있을까요?"

#: ../../intro/tutorial03.txt:427
msgid ""
"The answer is to add namespaces to your  URLconf. In the ``polls/urls.py`` "
"file, go ahead and add an ``app_name`` to set the application namespace:"
msgstr ""
"정답은 URLconf 에 이름공간(namespace)을 추가하는 것입니다. ``polls/urls.py`` 파일에 ``app_name``"
" 을 추가하여 어플리케이션의 이름공간을 설정할 수 있습니다."

#: ../../intro/tutorial03.txt:445
msgid "Now change your ``polls/index.html`` template from:"
msgstr "이제, ``polls/index.html`` template 의 기존 내용을"

#: ../../intro/tutorial03.txt:452
msgid "to point at the namespaced detail view:"
msgstr "아래와 같이 이름공간으로 나눠진 detail 의 view 를 가르키도록 변경하세요."

#: ../../intro/tutorial03.txt:459
msgid ""
"When you're comfortable with writing views, read :doc:`part 4 of this "
"tutorial </intro/tutorial04>` to learn about simple form processing and "
"generic views."
msgstr ""
"view 를 작성하는 것이 익숙해 지셨다면, :doc:`4장 튜토리얼 </intro/tutorial04>` 에서 간단한 서식 처리와 "
"generic view 를 배워보세요."

#: ../../intro/tutorial04.txt:3
msgid "Writing your first Django app, part 4"
msgstr "첫 번째 장고 앱 작성하기, part 4"

#: ../../intro/tutorial04.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 3 </intro/tutorial03>` left off. "
"We're continuing the Web-poll application and will focus on simple form "
"processing and cutting down our code."
msgstr ""
"이 튜토리얼은 :doc:`Tutorial 3 </intro/tutorial03>` 에서 이어집니다. 웹-튜표 어플리케이션을 다루고 있고,"
" 간단한 폼 처리와 우리의 소스를 줄여가는데 중점을 둘것입니다."

#: ../../intro/tutorial04.txt:10
msgid "Write a simple form"
msgstr "간단한 폼 작성합니다"

#: ../../intro/tutorial04.txt:12
msgid ""
"Let's update our poll detail template (\"polls/detail.html\") from the last "
"tutorial, so that the template contains an HTML ``<form>`` element:"
msgstr ""
" 지난 튜토리얼에서 사용한 HTML ``<form>`` 요소를 포함하고 있는 설문조사 세부 "
"템플릿(\"polls/detail.html\")을 수정합시다:"

#: ../../intro/tutorial04.txt:31
msgid "A quick rundown:"
msgstr "간략하게 설명하면:"

#: ../../intro/tutorial04.txt:33
msgid ""
"The above template displays a radio button for each question choice. The "
"``value`` of each radio button is the associated question choice's ID. The "
"``name`` of each radio button is ``\"choice\"``. That means, when somebody "
"selects one of the radio buttons and submits the form, it'll send the POST "
"data ``choice=#`` where # is the ID of the selected choice. This is the "
"basic concept of HTML forms."
msgstr ""
"위의 템플릿은 각 질문 선택 항목에 대한 라디오 버튼을 표시합니다. 각 라디오 버튼의 ``value`` 는 연관된 질문 선택 항목의 "
"ID입니다. 각 라디오 버튼의 ``name`` 은  ``\"choice\"``입니다. 즉, 누군가가 라디오 버튼 중 하나를 선택하여 폼을"
" 제출하면, POST 데이터 인 ``choice=#`` 을 보낼 것입니다. 여기서 #은 선택한 항목의 ID입니다. 이것은 HTML 폼의 "
"기본 개념입니다."

#: ../../intro/tutorial04.txt:40
msgid ""
"We set the form's ``action`` to ``{% url 'polls:vote' question.id %}``, and "
"we set ``method=\"post\"``. Using ``method=\"post\"`` (as opposed to "
"``method=\"get\"``) is very important, because the act of submitting this "
"form will alter data server-side. Whenever you create a form that alters "
"data server-side, use ``method=\"post\"``. This tip isn't specific to "
"Django; it's just good Web development practice."
msgstr ""
"폼의 ``action`` 을 ``{% url 'polls:vote' question.id %}`` 로 설정하고, "
"``method=\"post\"`` 게 설정하였습니다. 이 폼을 전송하는 행위는 서버측 자료를 변경할 것이므로, "
"``method=\"post\"`` (``method=\"get\"`` 와 대조적인) 를 사용하는 것은 매우 중요합니다. 서버 측 자료를"
" 변경하는 폼을 작성할 때마다, ``method=\"post\"`` 를 사용하세요. 이 팁은 Django에만 국한되지 않습니다. 그것은 "
"좋은 웹 개발 연습입니다."

#: ../../intro/tutorial04.txt:47
msgid ""
"``forloop.counter`` indicates how many times the :ttag:`for` tag has gone "
"through its loop"
msgstr "``forloop.counter`` 는 :ttag:`for` 태그가 반복을 한 횟 수를 나타냅니다."

#: ../../intro/tutorial04.txt:50
msgid ""
"Since we're creating a POST form (which can have the effect of modifying "
"data), we need to worry about Cross Site Request Forgeries. Thankfully, you "
"don't have to worry too hard, because Django comes with a very easy-to-use "
"system for protecting against it. In short, all POST forms that are targeted"
" at internal URLs should use the :ttag:`{% csrf_token %}<csrf_token>` "
"template tag."
msgstr ""
"우리는 POST 폼(자료를 수정하는 효과를 가진)을 만들고 있으므로, 사이트 간 요청 위조 (Cross Site Request "
"Forgeries)에 대해 고민해야합니다. 고맙게도, 장고는 사이트 간 요청 위조(CSRF)에 대항하기위한 사용하기 쉬운 시스템을 가지고"
" 있기 때문에, 너무 심각하게 고민할 필요가 없습니다. 간단히 말하면, 내부 URL들을 향하는 모든 POST 폼에 템플릿 태그 "
":ttag:`{% csrf_token %}<csrf_token>`   사용하면됩니다."

#: ../../intro/tutorial04.txt:57
msgid ""
"Now, let's create a Django view that handles the submitted data and does "
"something with it. Remember, in :doc:`Tutorial 3 </intro/tutorial03>`, we "
"created a URLconf for the polls application that includes this line:"
msgstr ""
"이제 제출된 데이터를 처리하고 그 데이터로 무언가를 수행하는 Django 뷰를 작성하겠습니다.  doc:`튜토리얼 3 "
"</intro/tutorial03>` 에서 설문조사 어플리케이션을 위해 아래에 나와있는 코드를 포함하는 URLconf를 만들었습니다:"

#: ../../intro/tutorial04.txt:66
msgid ""
"We also created a dummy implementation of the ``vote()`` function. Let's "
"create a real version. Add the following to ``polls/views.py``:"
msgstr ""
"또, 우리는 ``vote()`` 함수를 가상으로 만들었습니다. 실제로 구현을 해봅시다. ``polls/views.py`` 에 다음을 "
"추가합시다:"

#: ../../intro/tutorial04.txt:96
msgid ""
"This code includes a few things we haven't covered yet in this tutorial:"
msgstr "위 코드는 이 튜토리얼에서 아직 다루지 않은 몇 가지를 포함하고 있습니다:"

#: ../../intro/tutorial04.txt:98
msgid ""
":attr:`request.POST <django.http.HttpRequest.POST>` is a dictionary-like "
"object that lets you access submitted data by key name. In this case, "
"``request.POST['choice']`` returns the ID of the selected choice, as a "
"string. :attr:`request.POST <django.http.HttpRequest.POST>` values are "
"always strings."
msgstr ""
":attr:`request.POST <django.http.HttpRequest.POST>` 는 키로 전송된 자료에 접근할 수 있도록 "
"해주는 사전과 같은 객체입니다. 이 경우에서, ``request.POST['choice']`` 는 선택된 설문의 ID를 문자열로 "
"반환합니다. :attr:`request.POST <django.http.HttpRequest.POST>` 의 값은 항상 문자열들입니다."

#: ../../intro/tutorial04.txt:104
msgid ""
"Note that Django also provides :attr:`request.GET "
"<django.http.HttpRequest.GET>` for accessing GET data in the same way -- but"
" we're explicitly using :attr:`request.POST <django.http.HttpRequest.POST>` "
"in our code, to ensure that data is only altered via a POST call."
msgstr ""
"Django는 같은 방법으로 GET 자료에 접근하기 위해 :attr:`request.GET "
"<django.http.HttpRequest.GET>` 를 제공합니다 -- 그러나 POST 요청을 통해서만 자료가 수정되게하기 위해서, "
"명시적으로 코드에 :attr:`request.POST <django.http.HttpRequest.POST>` 를 사용하고 있다."

#: ../../intro/tutorial04.txt:110
msgid ""
"``request.POST['choice']`` will raise :exc:`KeyError` if ``choice`` wasn't "
"provided in POST data. The above code checks for :exc:`KeyError` and "
"redisplays the question form with an error message if ``choice`` isn't "
"given."
msgstr ""
"만약 POST 자료에 ``choice`` 가 없으면, ``request.POST['choice']`` 는 :exc:`KeyError` 가"
" 일어납니다. 위의 코드는 :exc:`KeyError` 를 체크하고, choice가 주어지지 않은 경우에는 에러 메시지와 함께 설문조사 "
"폼을 다시보여줍니다."

#: ../../intro/tutorial04.txt:115
msgid ""
"After incrementing the choice count, the code returns an "
":class:`~django.http.HttpResponseRedirect` rather than a normal "
":class:`~django.http.HttpResponse`. "
":class:`~django.http.HttpResponseRedirect` takes a single argument: the URL "
"to which the user will be redirected (see the following point for how we "
"construct the URL in this case)."
msgstr ""
"설문지의 수가 증가한 이후에, 코드는 일반 :class:`~django.http.HttpResponse` 가 아닌 "
":class:`~django.http.HttpResponseRedirect` 를 반환하고, "
":class:`~django.http.HttpResponseRedirect` 는 하나의 인수를 받습니다: 그 인수는 사용자가 재전송할 "
"URL 입니다. (이 경우에 우리가 URL을 어떻게 구성하는지 다음 항목을 보세요)."

#: ../../intro/tutorial04.txt:122
msgid ""
"As the Python comment above points out, you should always return an "
":class:`~django.http.HttpResponseRedirect` after successfully dealing with "
"POST data. This tip isn't specific to Django; it's just good Web development"
" practice."
msgstr ""
"위의 파이썬 주석이 지적했듯이, POST 데이터를 성공적으로 처리 한 후에는 항상 "
":class:`~django.http.HttpResponseRedirect` 를 반환해야합니다. 이 팁은 Django에만 국한되지 "
"않습니다. 그것은 좋은 웹 개발 연습입니다."

#: ../../intro/tutorial04.txt:127
msgid ""
"We are using the :func:`~django.urls.reverse` function in the "
":class:`~django.http.HttpResponseRedirect` constructor in this example. This"
" function helps avoid having to hardcode a URL in the view function. It is "
"given the name of the view that we want to pass control to and the variable "
"portion of the URL pattern that points to that view. In this case, using the"
" URLconf we set up in :doc:`Tutorial 3 </intro/tutorial03>`, this "
":func:`~django.urls.reverse` call will return a string like ::"
msgstr ""
"우리는 이 예제에서 :class:`~django.http.HttpResponseRedirect` 생성자 안의 "
":func:`~django.urls.reverse` 함수를 사용하고 있습니다. 이 함수는 함수에서 URL을 하드코딩하는 행위를 안하게 "
"도와줍니다. 제어를 전달하기 원하는 뷰의 이름을 제공하고, URL패턴의 변수부분이 그 뷰를 가리킵니다. 이 경우에, URLconf를 "
"사용하여 우리는  :doc:`튜토리얼 3 </intro/tutorial03>` 에서 설정하였습니다. 이 "
":func:`~django.urls.reverse` 호출은 아래와 같은 문자열을 반환할 것입니다 :: "

#: ../../intro/tutorial04.txt:138
msgid ""
"where the ``3`` is the value of ``question.id``. This redirected URL will "
"then call the ``'results'`` view to display the final page."
msgstr ""
"여기서 ``3`` 은 ``question.id`` 의 값입니다. 이렇게 리디렉션된 URL은 최종 페이지를 표시하기 위해 "
"``'results'`` 뷰를 호출합니다."

#: ../../intro/tutorial04.txt:141
msgid ""
"As mentioned in :doc:`Tutorial 3 </intro/tutorial03>`, ``request`` is an "
":class:`~django.http.HttpRequest` object. For more on "
":class:`~django.http.HttpRequest` objects, see the :doc:`request and "
"response documentation </ref/request-response>`."
msgstr ""
":doc:`튜토리얼 3 </intro/tutorial03>` 에서 언급했듯이, ``request`` 는 "
":class:`~django.http.HttpRequest` 개체입니다. :class:`~django.http.HttpRequest` "
"개체에 대해 더 알고 싶다면  :doc:`request and response documentation </ref/request-"
"response>` 을 참고하세요."

#: ../../intro/tutorial04.txt:146
msgid ""
"After somebody votes in a question, the ``vote()`` view redirects to the "
"results page for the question. Let's write that view:"
msgstr ""
"어떤 이가 설문조사에 설문을 하고난 뒤에는, ``vote()`` 뷰는 설문조사 결과 페이지로 리다이렉트합니다. 그 뷰를 작성해봅시다"

#: ../../intro/tutorial04.txt:159
msgid ""
"This is almost exactly the same as the ``detail()`` view from :doc:`Tutorial"
" 3 </intro/tutorial03>`. The only difference is the template name. We'll fix"
" this redundancy later."
msgstr ""
":doc:`Tutorial 3 </intro/tutorial03>` 의 ``detail()`` 뷰와 거의 동일합니다. 템플릿 이름만 "
"다릅니다. 나중에 이 중복을 수정할 겁니다."

#: ../../intro/tutorial04.txt:163
msgid "Now, create a ``polls/results.html`` template:"
msgstr "이제, ``polls/results.html`` 템플릿을 만듭니다."

#: ../../intro/tutorial04.txt:178
msgid ""
"Now, go to ``/polls/1/`` in your browser and vote in the question. You "
"should see a results page that gets updated each time you vote. If you "
"submit the form without having chosen a choice, you should see the error "
"message."
msgstr ""
"이제, 웹 브라우저에서 ``/polls/1/`` 페이지로 가서, 투표를 해보세요. 당신이 투표를 할 때마다 값이 반영된 결과 페이지를 볼"
" 수 있을 것입니다. 만약 당신이 설문지를 선택하지 않고 폼을 전송했다면, 오류 메시지를 보게 될 것입니다."

#: ../../intro/tutorial04.txt:183
msgid ""
"The code for our ``vote()`` view does have a small problem. It first gets "
"the ``selected_choice`` object from the database, then computes the new "
"value of ``votes``, and then saves it back to the database. If two users of "
"your website try to vote at *exactly the same time*, this might go wrong: "
"The same value, let's say 42, will be retrieved for ``votes``. Then, for "
"both users the new value of 43 is computed and saved, but 44 would be the "
"expected value."
msgstr ""
"우리의 ``vote()`` 뷰에는 작은 문제가 있습니다. 먼저 데이터베이스에서 ``selected_choice`` 객체를 가져온 다음, "
"``votes`` 의 새 값을 계산하고 나서,  데이터베이스에 다시 저장합니다. 만약 여러분의 웹사이트에 두 명의 사용자가 *정확하게 "
"같은 시간* 에 투표를 할려고 시도할 경우, 잘못될 수 있습니다.  ``votes`` 의 조회값이 42라고 할 경우, 두 명의 사용자에게"
" 새로운 값인 43이 계산 되고, 저장됩니다. 그러나 44가 되야되겠죠."

#: ../../intro/tutorial04.txt:191
msgid ""
"This is called a *race condition*. If you are interested, you can read :ref"
":`avoiding-race-conditions-using-f` to learn how you can solve this issue."
msgstr ""
"이를 *경쟁 상태* 라 합니다. 이 문제를 해결할 수 있는 방법을 알아보려면 :ref:`avoiding-race-conditions-"
"using-f` 를 참고하세요."

#: ../../intro/tutorial04.txt:196
msgid "Use generic views: Less code is better"
msgstr "제레릭 뷰 사용하기: 적은 코드가 더 좋습니다."

#: ../../intro/tutorial04.txt:198
msgid ""
"The ``detail()`` (from :doc:`Tutorial 3 </intro/tutorial03>`) and "
"``results()`` views are very simple -- and, as mentioned above, redundant. "
"The ``index()`` view, which displays a list of polls, is similar."
msgstr ""
"``detail ()``(from:doc:`Tutorial 3 </intro/tutorial03>`)과``results ()``뷰는 매우"
" 간단합니다. polls리스트를 보여주는``index ()``뷰는 비슷하다."

#: ../../intro/tutorial04.txt:202
msgid ""
"These views represent a common case of basic Web development: getting data "
"from the database according to a parameter passed in the URL, loading a "
"template and returning the rendered template. Because this is so common, "
"Django provides a shortcut, called the \"generic views\" system."
msgstr ""
"이러한 뷰는 URL에서 전달 된 매개 변수에 따라 데이터베이스에서 데이터를 가져 오는 것과 템플리트를로드하고 렌더링 된 템플리트를 "
"리턴하는 기본 웹 개발의 일반적인 경우를 나타냅니다. Django는 매우 일반적이기 때문에 \"일반 뷰\"시스템이라는 지름길을 "
"제공합니다."

#: ../../intro/tutorial04.txt:207
msgid ""
"Generic views abstract common patterns to the point where you don't even "
"need to write Python code to write an app."
msgstr "일반 뷰는 일반적인 패턴을 추상화하여 응용 프로그램을 작성하기 위해 Python 코드를 작성하지 않아도됩니다."

#: ../../intro/tutorial04.txt:210
msgid ""
"Let's convert our poll app to use the generic views system, so we can delete"
" a bunch of our own code. We'll just have to take a few steps to make the "
"conversion. We will:"
msgstr ""
"우리의 투표 애플리케이션을 일반 뷰 시스템을 사용하도록 변환하여 우리 자신의 코드를 삭제할 수 있도록하자. 전환을하려면 몇 단계 만 "
"거쳐야합니다. 우리는:"

#: ../../intro/tutorial04.txt:214
msgid "Convert the URLconf."
msgstr "URLconf를 변환하십시오."

#: ../../intro/tutorial04.txt:216
msgid "Delete some of the old, unneeded views."
msgstr "불필요한 오래된보기 중 일부를 삭제하십시오."

#: ../../intro/tutorial04.txt:218
msgid "Introduce new views based on Django's generic views."
msgstr "Django의 일반적인 뷰를 기반으로 새로운 뷰를 도입하십시오."

#: ../../intro/tutorial04.txt:220
msgid "Read on for details."
msgstr "자세한 내용은 계속 읽으십시오."

#: ../../intro/tutorial04.txt:222
msgid "Why the code-shuffle?"
msgstr "왜 코드 셔플인가?"

#: ../../intro/tutorial04.txt:224
msgid ""
"Generally, when writing a Django app, you'll evaluate whether generic views "
"are a good fit for your problem, and you'll use them from the beginning, "
"rather than refactoring your code halfway through. But this tutorial "
"intentionally has focused on writing the views \"the hard way\" until now, "
"to focus on core concepts."
msgstr ""
"일반적으로 Django 응용 프로그램을 작성할 때 일반 뷰가 문제에 적합한 지 여부를 평가할 것이며 코드를 중간에서 다시 리팩토링하지 "
"않고 처음부터 사용하게됩니다. 그러나이 튜토리얼은 의도적으로 현재까지 핵심 개념에 초점을 맞추기 위해 \"어려운 방법\"으로 의견을 "
"작성하는 데 중점을두고 있습니다."

#: ../../intro/tutorial04.txt:230
msgid "You should know basic math before you start using a calculator."
msgstr "계산기를 사용하기 전에 기본 수학을 알아야합니다."

#: ../../intro/tutorial04.txt:233
msgid "Amend URLconf"
msgstr "URLconf 수정"

#: ../../intro/tutorial04.txt:235
msgid "First, open the ``polls/urls.py`` URLconf and change it like so:"
msgstr "먼저,``polls/urls.py`` URLconf를 열어 다음과 같이 변경하십시오:"

#: ../../intro/tutorial04.txt:252
msgid ""
"Note that the name of the matched pattern in the regexes of the second and "
"third patterns has changed from ``<question_id>`` to ``<pk>``."
msgstr ""
"두 번째와 세 번째 패턴의 정규식에서 일치하는 패턴의 이름이``<question_id>``에서``<pk>``로 변경되었습니다."

#: ../../intro/tutorial04.txt:256
msgid "Amend views"
msgstr "조회수 수정"

#: ../../intro/tutorial04.txt:258
msgid ""
"Next, we're going to remove our old ``index``, ``detail``, and ``results`` "
"views and use Django's generic views instead. To do so, open the "
"``polls/views.py`` file and change it like so:"
msgstr ""
"다음으로 이전의``index``,``detail``,``results`` 뷰를 제거하고 장고의 일반적인 뷰를 대신 사용하겠습니다. "
"그렇게하려면``polls/views.py`` 파일을 열고 다음과 같이 변경하십시오:"

#: ../../intro/tutorial04.txt:295
msgid ""
"We're using two generic views here: "
":class:`~django.views.generic.list.ListView` and "
":class:`~django.views.generic.detail.DetailView`. Respectively, those two "
"views abstract the concepts of \"display a list of objects\" and \"display a"
" detail page for a particular type of object.\""
msgstr ""
"class:`~ django.views.generic.list.ListView`와:class:`~ "
"django.views.generic.detail.DetailView`의 두 가지 일반 뷰를 사용하고 있습니다. 이 두보기는 각각 "
"\"개체 목록 표시\"및 \"특정 개체 유형에 대한 세부 정보 페이지 표시\"개념을 추상화합니다."

#: ../../intro/tutorial04.txt:301
msgid ""
"Each generic view needs to know what model it will be acting upon. This is "
"provided using the ``model`` attribute."
msgstr "각 일반 뷰는 어떤 모델이 적용될 것인지를 알아야합니다. 이것은``model`` 속성을 사용하여 제공됩니다."

#: ../../intro/tutorial04.txt:304
msgid ""
"The :class:`~django.views.generic.detail.DetailView` generic view expects "
"the primary key value captured from the URL to be called ``\"pk\"``, so "
"we've changed ``question_id`` to ``pk`` for the generic views."
msgstr ""
":class:`~ django.views.generic.detail.DetailView` 일반 뷰는 URL에서 캡쳐 된 기본 키 값이``"
" \"pk\"``라고 기대하기 때문에``question_id``를` 일반 뷰는 'pk`입니다."

#: ../../intro/tutorial04.txt:309
msgid ""
"By default, the :class:`~django.views.generic.detail.DetailView` generic "
"view uses a template called ``<app name>/<model name>_detail.html``. In our "
"case, it would use the template ``\"polls/question_detail.html\"``. The "
"``template_name`` attribute is used to tell Django to use a specific "
"template name instead of the autogenerated default template name. We also "
"specify the ``template_name`` for the ``results`` list view -- this ensures "
"that the results view and the detail view have a different appearance when "
"rendered, even though they're both a "
":class:`~django.views.generic.detail.DetailView` behind the scenes."
msgstr ""
"기본적으로:class:`~ django.views.generic.detail.DetailView` 일반 뷰는``<app "
"name>/<model name> _detail.html`` 템플릿을 사용합니다. 우리의 경우에는`` "
"\"polls/question_detail.html\"``템플릿을 사용할 것입니다. ``template_name`` 속성은 장고에게 자동"
" 생성 된 기본 템플릿 이름 대신에 특정 템플릿 이름을 사용하도록 알려주기 위해 사용됩니다. ``results``리스트 뷰에 "
"대해서``template_name``을 지정합니다 - 결과 뷰와 상세 뷰가 렌더링 될 때 서로 다른 모습을 갖도록합니다:class:`~ "
"django .views.generic.detail.DetailView`를 사용하십시오."

#: ../../intro/tutorial04.txt:319
msgid ""
"Similarly, the :class:`~django.views.generic.list.ListView` generic view "
"uses a default template called ``<app name>/<model name>_list.html``; we use"
" ``template_name`` to tell :class:`~django.views.generic.list.ListView` to "
"use our existing ``\"polls/index.html\"`` template."
msgstr ""
"마찬가지로, :class:`~django.views.generic.list.ListView` 제네릭 뷰는 ``<app "
"name>/<model name>_list.html`` 템플릿을 기본으로 사용합니다; 이미 있는 "
"``\"polls/index.html\"`` 템플릿을 사용하기 위해 "
":class:`~django.views.generic.list.ListView` 에 ``template_name`` 를 전달했습니다."

#: ../../intro/tutorial04.txt:325
msgid ""
"In previous parts of the tutorial, the templates have been provided with a "
"context that contains the ``question`` and ``latest_question_list`` context "
"variables. For ``DetailView`` the ``question`` variable is provided "
"automatically -- since we're using a Django model (``Question``), Django is "
"able to determine an appropriate name for the context variable. However, for"
" ListView, the automatically generated context variable is "
"``question_list``. To override this we provide the ``context_object_name`` "
"attribute, specifying that we want to use ``latest_question_list`` instead. "
"As an alternative approach, you could change your templates to match the new"
" default context variables -- but it's a lot easier to just tell Django to "
"use the variable you want."
msgstr ""
"이 튜토리얼의 이전 부분에서 템플릿에는 ``question`` 및 ``latest_question_list`` 컨텍스트 변수가 포함 된 "
"컨텍스트가 제공되었습니다. ``DetailView``\\ 의 경우,``question`` 변수가 자동으로 제공됩니다 - Django 모델"
" (``Question``)\\ 을 사용하기 때문에 Django는 컨텍스트 변수의 적절한 이름을 결정할 수 있습니다. 그러나 "
"ListView의 경우 자동 생성 된 컨텍스트 변수는``question_list`` 입니다. 이것을 덮어 쓰려면 "
"``context_object_name`` 속성을 제공하고, 대신에``latest_question_list``\\ 를 사용하도록 "
"지정하십시오. 다른 접근 방법으로, 템플릿을 새로운 기본 컨텍스트 변수와 일치하도록 변경할 수 있습니다. 그러나 원하는 변수를 사용하도록"
" Django에 지시하는 것이 훨씬 쉽습니다."

#: ../../intro/tutorial04.txt:337
msgid "Run the server, and use your new polling app based on generic views."
msgstr "서버를 실행하고 제너릭 뷰를 기반으로한 새 투표 앱을 사용하십시오."

#: ../../intro/tutorial04.txt:339
msgid ""
"For full details on generic views, see the :doc:`generic views documentation"
" </topics/class-based-views/index>`."
msgstr ""
"제너릭 뷰에 대한 자세한 내용은 :doc:`제너릭 뷰 문서 </topics/class-based-views/index>`\\ 를 "
"참조하십시오."

#: ../../intro/tutorial04.txt:342
msgid ""
"When you're comfortable with forms and generic views, read :doc:`part 5 of "
"this tutorial</intro/tutorial05>` to learn about testing our polls app."
msgstr ""
"폼 및 제너릭 뷰가 마음에 들면, 이 투표 앱의 테스트에 대해 :doc:`튜토리얼의 5장</intro/tutorial05>`\\ 을 읽어"
" 배워 보기 바랍니다."

#: ../../intro/tutorial05.txt:3
msgid "Writing your first Django app, part 5"
msgstr "첫 번째 장고 앱 작성하기, part 5"

#: ../../intro/tutorial05.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left off. "
"We've built a Web-poll application, and we'll now create some automated "
"tests for it."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 4장</intro/tutorial04>`\\ 에서 이어집니다. 우리는 웹 투표 애플리케이션을 구축했으며"
" 이제 이를 위한 자동화 된 테스트를 작성할 것입니다."

#: ../../intro/tutorial05.txt:10
msgid "Introducing automated testing"
msgstr "자동화 된 테스트 소개"

#: ../../intro/tutorial05.txt:13
msgid "What are automated tests?"
msgstr "자동화 된 테스트 란 무엇입니까?"

#: ../../intro/tutorial05.txt:15
msgid "Tests are simple routines that check the operation of your code."
msgstr "테스트는 코드의 동작을 체크하는 간단한 일련의 작업들입니다. "

#: ../../intro/tutorial05.txt:17
msgid ""
"Testing operates at different levels. Some tests might apply to a tiny "
"detail (*does a particular model method return values as expected?*) while "
"others examine the overall operation of the software (*does a sequence of "
"user inputs on the site produce the desired result?*). That's no different "
"from the kind of testing you did earlier in :doc:`Tutorial 2 "
"</intro/tutorial02>`, using the :djadmin:`shell` to examine the behavior of "
"a method, or running the application and entering data to check how it "
"behaves."
msgstr ""
"테스트는 다양한 수준에서 작동합니다. 일부 테스트는 작은 세부 사항에 적용될 수 있습니다 (*특정 모델 메서드는 예상대로 값을 "
"반환합니까?*) 또 다른 테스트는 소프트웨어의 전반적인 작동을 검사합니다 (*사이트에서 사용자 입력 시퀀스가 원하는 결과를 "
"생성합니까?*). 이것은 이전 :doc:`튜토리얼 2장 </intro/tutorial02>`\\ 에서 :djadmin:`shell`\\ "
"을 사용하여 메소드의 동작을 검사하거나 애플리케이션을 실행하고 어떻게 작동하는지 확인하기위해 데이터를 입력해서 테스트했던것과 다르지 "
"않습니다."

#: ../../intro/tutorial05.txt:25
msgid ""
"What's different in *automated* tests is that the testing work is done for "
"you by the system. You create a set of tests once, and then as you make "
"changes to your app, you can check that your code still works as you "
"originally intended, without having to perform time consuming manual "
"testing."
msgstr ""
"*자동화 된* 테스트에서 다른 점은 테스트 작업이 시스템에서 수행된다는 것입니다. 한 번 테스트 세트를 작성한 이후에는 앱을 변경할 때 "
"수동 테스트를 수행하지 않아도 원래 의도대로 코드가 작동하는지 확인할 수 있습니다."

#: ../../intro/tutorial05.txt:31
msgid "Why you need to create tests"
msgstr "테스트를 만들어야하는 이유"

#: ../../intro/tutorial05.txt:33
msgid "So why create tests, and why now?"
msgstr "그래서 왜 테스트를 만들어야하고, 굳이 지금 해야할까요?"

#: ../../intro/tutorial05.txt:35
msgid ""
"You may feel that you have quite enough on your plate just learning "
"Python/Django, and having yet another thing to learn and do may seem "
"overwhelming and perhaps unnecessary. After all, our polls application is "
"working quite happily now; going through the trouble of creating automated "
"tests is not going to make it work any better. If creating the polls "
"application is the last bit of Django programming you will ever do, then "
"true, you don't need to know how to create automated tests. But, if that's "
"not the case, now is an excellent time to learn."
msgstr ""
"아마 당신은 Python/Django를 배우는 것 만으로도 충분하다고 느낄수 있고 또 다른것을 배우고 써보는것은 지나치거나 불필요해 "
"보일수 있습니다. 어쨋든 간에 우리의 투표 어플리케이션은 지금 꽤 잘 돌아고 있습니다. 문제들을 해쳐 나가며 자동화된 테스트를 만드는게 "
"이 어플리케이션을 작동하게 하거나 더 좋게 하지는 않습니다. 만약 투표 어플리케이션을 만드는게 Django 프로그래밍의 최종 단계라면, "
"자동화된 테스트를 어떻게 만드는지 알 필요는 없습니다. 하지만 아직 더 많은것을 하려 한다면 지금이 자동화된 테스트 작성을 배우기 딱 "
"좋은 시간입니다."

#: ../../intro/tutorial05.txt:45
msgid "Tests will save you time"
msgstr "테스트를 통해 시간을 절약 할 수 있습니다."

#: ../../intro/tutorial05.txt:47
msgid ""
"Up to a certain point, 'checking that it seems to work' will be a "
"satisfactory test. In a more sophisticated application, you might have "
"dozens of complex interactions between components."
msgstr ""
"특정 시점까지는 '제대로 작동하는지 확인' 하는것이 테스트로서 충분할 것 입니다. 더 정교한 응용 프로그램에서는 구성 요소간에 수십 개의"
" 복잡한 상호 작용이있을 수 있습니다."

#: ../../intro/tutorial05.txt:51
msgid ""
"A change in any of those components could have unexpected consequences on "
"the application's behavior. Checking that it still 'seems to work' could "
"mean running through your code's functionality with twenty different "
"variations of your test data just to make sure you haven't broken something "
"- not a good use of your time."
msgstr ""
"이들 컴포넌트들에 어떠한 변경이라도 생기게 되면 어플리케이션의 동작에 예상치 못했던 결과가 발생할수 있습니다. 이 상황에서 '제대로 "
"작동하는지 확인'한다는 것은 20개의 서로 다른 테스트 데이터를 가지고 코드의 기능들을 돌려보는것입니다. 단지 당신이 뭔가를 망가뜨리지 "
"않았다는것을 확인하기 위해서 말이죠 - 시간은 귀한데 말입니다."

#: ../../intro/tutorial05.txt:57
msgid ""
"That's especially true when automated tests could do this for you in "
"seconds. If something's gone wrong, tests will also assist in identifying "
"the code that's causing the unexpected behavior."
msgstr ""
"이 수동 테스트 작업을 자동화된 테스트가 몇초만에 해낼수 있다면 귀한시간을 많이 아낄수 있겠죠?. 무언가가 잘못되어도 테스트를 통해 "
"예기치 않은 동작을 일으키는 코드를 식별하는 데 도움이됩니다."

#: ../../intro/tutorial05.txt:61
msgid ""
"Sometimes it may seem a chore to tear yourself away from your productive, "
"creative programming work to face the unglamorous and unexciting business of"
" writing tests, particularly when you know your code is working properly."
msgstr ""
"때로는 코드가 제대로 작동하고 있음을 알 때 테스트를 작성하는 것은 허드렛일로 보여서 당신의 생산적이고 창의적인 프로그래밍 작업에서 떠나"
" 매력적이지도 흥분되지도 않는 테스트 작성이라는 일을 하는게 어려울수도 있습니다. "

#: ../../intro/tutorial05.txt:65
msgid ""
"However, the task of writing tests is a lot more fulfilling than spending "
"hours testing your application manually or trying to identify the cause of a"
" newly-introduced problem."
msgstr ""
"그러나 테스트를 작성하는 작업은 응용 프로그램을 수동으로 테스트하거나 새로 발견된 문제의 원인을 확인하는 데 많은 시간을 투자하는 것보다"
" 훨씬 더 효과적입니다."

#: ../../intro/tutorial05.txt:70
msgid "Tests don't just identify problems, they prevent them"
msgstr "테스트는 문제를 그저 식별하는 것이 아니라 예방합니다."

#: ../../intro/tutorial05.txt:72
msgid ""
"It's a mistake to think of tests merely as a negative aspect of development."
msgstr "테스트를 그저 개발의 부정적 측면으로 생각하는 것은 실수입니다."

#: ../../intro/tutorial05.txt:74
msgid ""
"Without tests, the purpose or intended behavior of an application might be "
"rather opaque. Even when it's your own code, you will sometimes find "
"yourself poking around in it trying to find out what exactly it's doing."
msgstr ""
"테스트가 없으면 응용 프로그램의 목적 또는 의도 된 동작이 다소 불투명 할 수 있습니다. 심지어 자신의 코드 일 때도, 정확히 무엇을하고"
" 있는지 알아 내려고 노력하게 됩니다."

#: ../../intro/tutorial05.txt:78
msgid ""
"Tests change that; they light up your code from the inside, and when "
"something goes wrong, they focus light on the part that has gone wrong - "
"*even if you hadn't even realized it had gone wrong*."
msgstr ""
"테스트는 이 불투명함을 바꿉니다. 그들은 내부에서 코드를 밝혀 내고, 어떤 것이 잘못 될 때, *그것이 잘못되었다는 것을 깨닫지 못했다고"
" 할지라도, 잘못된 부분에 빛을 집중시킵니다*."

#: ../../intro/tutorial05.txt:83
msgid "Tests make your code more attractive"
msgstr "테스트가 코드를 더 매력적으로 만듭니다."

#: ../../intro/tutorial05.txt:85
msgid ""
"You might have created a brilliant piece of software, but you will find that"
" many other developers will simply refuse to look at it because it lacks "
"tests; without tests, they won't trust it. Jacob Kaplan-Moss, one of "
"Django's original developers, says \"Code without tests is broken by "
"design.\""
msgstr ""
"당신이 화려한 소프트웨어를 만들더라도, 다른 많은 개발자들은 그저 테스트가 부족하기 때문에 그것을 사용하려 하지 않을 것입니다. 테스트 "
"없이 그들은 그것을 신뢰하지 않을 것입니다. Django의 원 개발자 중 한 명인 Jacob Kaplan-Moss는 \"테스트없는 코드는"
" 설계상 망가져 있는것\" 이라고 말합니다."

#: ../../intro/tutorial05.txt:90
msgid ""
"That other developers want to see tests in your software before they take it"
" seriously is yet another reason for you to start writing tests."
msgstr ""
"테스트 작성을 시작해야하는 또다른 이유는 다른 개발자들이 당신의 소프트웨어를 사용하는것을 진지하게 고려하기 전에 테스트 코드를 보기를 "
"원하기 때문입니다."

#: ../../intro/tutorial05.txt:94
msgid "Tests help teams work together"
msgstr "테스트는 팀이 함께 일하는것을 돕습니다"

#: ../../intro/tutorial05.txt:96
msgid ""
"The previous points are written from the point of view of a single developer"
" maintaining an application. Complex applications will be maintained by "
"teams. Tests guarantee that colleagues don't inadvertently break your code "
"(and that you don't break theirs without knowing). If you want to make a "
"living as a Django programmer, you must be good at writing tests!"
msgstr ""
"이전의 내용은 응용 프로그램을 유지 관리하는 단일 개발자의 관점에서 작성되었습니다. 복잡한 애플리케이션은 팀별로 유지 관리됩니다. "
"테스트는 동료가 실수로 코드를 손상시키지 않는다는 것을 보증합니다 (그리고 당신이 동료의 코드를 모르는새에 망가트리는것도). 장고 "
"프로그래머로서 생계를 꾸려 나가려면 테스트를 잘해야합니다!"

#: ../../intro/tutorial05.txt:103
msgid "Basic testing strategies"
msgstr "기초 테스팅 전략"

#: ../../intro/tutorial05.txt:105
msgid "There are many ways to approach writing tests."
msgstr "테스트 작성에 대한 많은 접근법이 있습니다."

#: ../../intro/tutorial05.txt:107
msgid ""
"Some programmers follow a discipline called \"`test-driven development`_\"; "
"they actually write their tests before they write their code. This might "
"seem counter-intuitive, but in fact it's similar to what most people will "
"often do anyway: they describe a problem, then create some code to solve it."
" Test-driven development simply formalizes the problem in a Python test "
"case."
msgstr ""
"어떤 프로그래머들은 \"`테스트 주도 개발`_\"이라는 원칙을 따릅니다. 그들은 정말로 코드를 작성하기도 전에 테스트를 먼저 작성합니다."
" 이는 직관에 위배되는 것처럼 보일 수 있지만, 사실은 대부분의 사람들이 자주 하는 방식과 비슷합니다. 문제를 서술한 뒤, 코드를 "
"만들어서 그것을 풀어내는 것이죠. 테스트 주도 개발은 파이썬 테스트 케이스로 문제를 간추려 공식화합니다."

#: ../../intro/tutorial05.txt:113
msgid ""
"More often, a newcomer to testing will create some code and later decide "
"that it should have some tests. Perhaps it would have been better to write "
"some tests earlier, but it's never too late to get started."
msgstr ""
"더 흔하게는, 테스팅 입문자들은 코드를 작성하고 시간이 흐른 뒤에 테스트들이 필요하다고 판단할 것입니다. 아마도 몇몇의 테스트는 더 빨리"
" 작성하는 것이 나을지도 모릅니다. 하지만 시작하기에 너무 늦어서는 안 됩니다."

#: ../../intro/tutorial05.txt:117
msgid ""
"Sometimes it's difficult to figure out where to get started with writing "
"tests. If you have written several thousand lines of Python, choosing "
"something to test might not be easy. In such a case, it's fruitful to write "
"your first test the next time you make a change, either when you add a new "
"feature or fix a bug."
msgstr ""
"어디서부터 테스트를 작성해야 할지 종잡을 수 없을 때가 있습니다. 당신이 수천 줄의 파이썬 코드를 작성해 놓았다면, 테스트할 것을 고르는"
" 것이 쉽지 않을지도 모릅니다. 그럴 때는 다음에 새로운 기능을 넣거나 버그를 수정하는 등, 코드를 변경할 일이 있을 때, 당신의 첫 "
"테스트를 작성하는 것이 유익할 것입니다."

#: ../../intro/tutorial05.txt:122
msgid "So let's do that right away."
msgstr "그러니 지금 당장 해봅시다."

#: ../../intro/tutorial05.txt:127
msgid "Writing our first test"
msgstr "우리의 첫 테스트 작성하기"

#: ../../intro/tutorial05.txt:130
msgid "We identify a bug"
msgstr "우리는 버그를 확인합니다."

#: ../../intro/tutorial05.txt:132
msgid ""
"Fortunately, there's a little bug in the ``polls`` application for us to fix"
" right away: the ``Question.was_published_recently()`` method returns "
"``True`` if the ``Question`` was published within the last day (which is "
"correct) but also if the ``Question``’s ``pub_date`` field is in the future "
"(which certainly isn't)."
msgstr ""
"다행스럽게도 ``polls`` 어플리케이션에는 우리가 즉시 해결할수있는 약간의 버그가 있습니다. "
"``Question.was_published_recently()`` 메소드는 ``Question``\\ 이 어제 안에 게시 된 경우 "
"``True``\\ 를 반환하며(올바른 동작) 그뿐 아니라 ``Question``\\ 의``pub_date`` 필드가 미래로 설정되어 "
"있을때도 그렇습니다(틀린 동작)."

#: ../../intro/tutorial05.txt:137
msgid ""
"To check if the bug really exists, using the Admin create a question whose "
"date lies in the future and check the method using the :djadmin:`shell`::"
msgstr ""
"버그가 실제로 존재하는지 확인하기위해 Admin을 사용하여 미래의 날짜로 질문을 만들고 :djadmin:`shell`\\ 을 사용해서 "
"확인합니다."

#: ../../intro/tutorial05.txt:149
msgid "Since things in the future are not 'recent', this is clearly wrong."
msgstr "미래는 '최근(recent)'가 아니기 때문에 이는 분명히 틀린 말입니다."

#: ../../intro/tutorial05.txt:152
msgid "Create a test to expose the bug"
msgstr "버그를 노출하는 테스트 만들기"

#: ../../intro/tutorial05.txt:154
msgid ""
"What we've just done in the :djadmin:`shell` to test for the problem is "
"exactly what we can do in an automated test, so let's turn that into an "
"automated test."
msgstr ""
"문제를 테스트하기 위해 :djadmin:`shell` 에서 방금 수행 한 작업은 자동화 된 테스트에서 수행 할 수있는 작업이므로 자동화 "
"된 테스트로 바꾸도록 합시다."

#: ../../intro/tutorial05.txt:157
msgid ""
"A conventional place for an application's tests is in the application's "
"``tests.py`` file; the testing system will automatically find tests in any "
"file whose name begins with ``test``."
msgstr ""
"애플리케이션 테스트는 일반적으로 애플리케이션의 ``tests.py`` 파일에 있습니다. 테스트 시스템은 ``test`` 로 시작하는 "
"파일에서 테스트를 자동으로 찾습니다."

#: ../../intro/tutorial05.txt:161
msgid ""
"Put the following in the ``tests.py`` file in the ``polls`` application:"
msgstr "``polls`` 어플리케이션의 ``tests.py`` 파일에 다음을 입력하십시오:"

#: ../../intro/tutorial05.txt:185
msgid ""
"What we have done here is created a :class:`django.test.TestCase` subclass "
"with a method that creates a ``Question`` instance with a ``pub_date`` in "
"the future. We then check the output of ``was_published_recently()`` - which"
" *ought* to be False."
msgstr ""
"우리가 여기서 한 것은 미래로 설정된 ``pub_date``\\ 를 가진 ``Question``\\ 인스턴스를 생성하는 메소드를 가진 "
"class:`django.test.TestCase` 서브 클래스를 생성 한 것입니다. 그런 "
"다음``was_published_recently()``\\ 의 결과를 확인합니다. - 이는 *반드시* False가 되어야 합니다."

#: ../../intro/tutorial05.txt:191
msgid "Running tests"
msgstr "테스트 실행"

#: ../../intro/tutorial05.txt:193
msgid "In the terminal, we can run our test::"
msgstr "터미널에서 테스트를 실행할 수 있습니다::"

#: ../../intro/tutorial05.txt:197
msgid "and you'll see something like::"
msgstr "그러면 다음과 같은 것을 볼 수 있습니다::"

#: ../../intro/tutorial05.txt:215
msgid "What happened is this:"
msgstr "무슨 일이 일어 났습니까?"

#: ../../intro/tutorial05.txt:217
msgid ""
"``python manage.py test polls`` looked for tests in the ``polls`` "
"application"
msgstr "``python manage.py test polls``\\ 는``polls`` 어플리케이션에서 테스트를 찾았습니다"

#: ../../intro/tutorial05.txt:219
msgid "it found a subclass of the :class:`django.test.TestCase` class"
msgstr ":class:`django.test.TestCase` 클래스의 서브 클래스를 찾았습니다."

#: ../../intro/tutorial05.txt:221
msgid "it created a special database for the purpose of testing"
msgstr "테스트 목적으로 특별한 데이터베이스를 만들었습니다."

#: ../../intro/tutorial05.txt:223
msgid "it looked for test methods - ones whose names begin with ``test``"
msgstr "테스트 메소드 - 이름이 ``test``\\ 로 시작하는 것들을 찾습니다."

#: ../../intro/tutorial05.txt:225
msgid ""
"in ``test_was_published_recently_with_future_question`` it created a "
"``Question`` instance whose ``pub_date`` field is 30 days in the future"
msgstr ""
"``test_was_published_recently_with_future_question``\\ 에서 ``pub_date``\\ 필드가"
" 30일 미래인 ``Question`` 인스턴스를 생성했습니다"

#: ../../intro/tutorial05.txt:228
msgid ""
"... and using the ``assertIs()`` method, it discovered that its "
"``was_published_recently()`` returns ``True``, though we wanted it to return"
" ``False``"
msgstr ""
"... ``assertIs()`` 메소드를 사용하여, 우리가 ``False``\\ 가 반환되기를 원함에도 불구하고 "
"``was_published_recently()`` 가 ``True``\\ 를 반환한다는 것을 발견했습니다."

#: ../../intro/tutorial05.txt:232
msgid ""
"The test informs us which test failed and even the line on which the failure"
" occurred."
msgstr "테스트는 어떤 테스트가 실패했는지와 실패가 발생한 행까지 알려줍니다."

#: ../../intro/tutorial05.txt:236
msgid "Fixing the bug"
msgstr "버그 수정"

#: ../../intro/tutorial05.txt:238
msgid ""
"We already know what the problem is: ``Question.was_published_recently()`` "
"should return ``False`` if its ``pub_date`` is in the future. Amend the "
"method in ``models.py``, so that it will only return ``True`` if the date is"
" also in the past:"
msgstr ""
"우리는 이미 문제가 무엇인지 알고 있습니다: ``Question.was_published_recently()``\\ 는 "
"``pub_date`` 가 미래에 있다면 ``False`` 를 반환해야합니다. ``models.py``\\ 에서 메소드를 수정하십시오. "
"그래서 날짜가 과거에 있을 때에만 ``True``\\ 를 반환 할 것입니다:"

#: ../../intro/tutorial05.txt:250
msgid "and run the test again::"
msgstr "이제 테스트를 다시 실행하십시오::"

#: ../../intro/tutorial05.txt:260
msgid ""
"After identifying a bug, we wrote a test that exposes it and corrected the "
"bug in the code so our test passes."
msgstr "버그를 확인한 후에 우리는 이를 드러내는 테스트를 작성 하였으며 코드에서 버그를 수정하고 테스트를 통과했습니다."

#: ../../intro/tutorial05.txt:263
msgid ""
"Many other things might go wrong with our application in the future, but we "
"can be sure that we won't inadvertently reintroduce this bug, because simply"
" running the test will warn us immediately. We can consider this little "
"portion of the application pinned down safely forever."
msgstr ""
"앞으로는 다른 많은 것들이 우리 어플리케이션에 잘못 될 수도 있지만 단순히 테스트를 실행하면 우리에게 즉시 경고 하므로 실수로 이 버그가"
" 재발 하지는 않을 것입니다. 우리는 애플리케이션의이 작은 부분을 영원히 안전한상태로 고정 시켰다고 생각할 수 있습니다."

#: ../../intro/tutorial05.txt:269
msgid "More comprehensive tests"
msgstr "보다 포괄적인 테스트"

#: ../../intro/tutorial05.txt:271
msgid ""
"While we're here, we can further pin down the ``was_published_recently()`` "
"method; in fact, it would be positively embarrassing if in fixing one bug we"
" had introduced another."
msgstr ""
"우리가 여기있는 동안, 우리는 ``was_published_recently()``\\ 메소드를 고정하는것 이상을 할수 있습니다; 사실 "
"하나의 버그를 고치면서 다른 새로운 버그를 만들어 낸다면 분명 곤란할것입니다."

#: ../../intro/tutorial05.txt:275
msgid ""
"Add two more test methods to the same class, to test the behavior of the "
"method more comprehensively:"
msgstr "메소드의 동작을보다 포괄적으로 테스트하기 위해 동일한 클래스에 두 가지 테스트 메소드를 추가하십시오:"

#: ../../intro/tutorial05.txt:299
msgid ""
"And now we have three tests that confirm that "
"``Question.was_published_recently()`` returns sensible values for past, "
"recent, and future questions."
msgstr ""
"이제 우리는 ``Question.was_published_recently()``\\ 가 과거, 최근, 미래의 질문에 대해 올바른 값을 "
"반환한다는걸 확인시켜주는 세가지 테스트를 가졌습니다."

#: ../../intro/tutorial05.txt:302
msgid ""
"Again, ``polls`` is a simple application, but however complex it grows in "
"the future and whatever other code it interacts with, we now have some "
"guarantee that the method we have written tests for will behave in expected "
"ways."
msgstr ""
"다시 말하지만 ``설문조사 (polls)`` 는 단순한 프로그램이지만 추후에 복잡도가 증가되고 다른 어떤 코드들과 상호작용을 하더라도 "
"테스트를 작성한 메소드가 예상대로 동작 할 것이라는 보장을 할수있습니다."

#: ../../intro/tutorial05.txt:307
msgid "Test a view"
msgstr "뷰 테스트"

#: ../../intro/tutorial05.txt:309
msgid ""
"The polls application is fairly undiscriminating: it will publish any "
"question, including ones whose ``pub_date`` field lies in the future. We "
"should improve this. Setting a ``pub_date`` in the future should mean that "
"the Question is published at that moment, but invisible until then."
msgstr ""
"설문조사 어플리케이션은 상당히 대충대충 만들어져 있습니다. 이 어플리케이션은 ``pub_date``\\ 필드가 미래에있는 질문 까지도 "
"포함하여 게시합니다. 이것을 개선 해야합니다. 미래로 ``pub_date``\\ 를 설정하는 것은 그 시기가 되면 질문이 게시되지만 "
"그때까지는 보이지 않는 것을 의미 해야 합니다."

#: ../../intro/tutorial05.txt:315
msgid "A test for a view"
msgstr "뷰에 대한 테스트"

#: ../../intro/tutorial05.txt:317
msgid ""
"When we fixed the bug above, we wrote the test first and then the code to "
"fix it. In fact that was a simple example of test-driven development, but it"
" doesn't really matter in which order we do the work."
msgstr ""
"위의 버그를 수정했을 때 먼저 테스트를 작성한 다음 코드 수정을 했습니다. 사실 그것은 테스트 주도 개발의 간단한 예제 였지만 어떤 "
"순서로 작업하는지는 중요하지 않습니다."

#: ../../intro/tutorial05.txt:321
msgid ""
"In our first test, we focused closely on the internal behavior of the code. "
"For this test, we want to check its behavior as it would be experienced by a"
" user through a web browser."
msgstr ""
"첫 번째 테스트에서 코드의 내부 동작에 대해 자세히 설명했습니다. 이 테스트에서는 웹 브라우저를 통해 사용자가 경험하는대로 동작을 "
"확인하려고합니다."

#: ../../intro/tutorial05.txt:325
msgid ""
"Before we try to fix anything, let's have a look at the tools at our "
"disposal."
msgstr "버그를 수정하기 전에 우리가 사용 할 수있는 도구를 살펴 보겠습니다."

#: ../../intro/tutorial05.txt:328
msgid "The Django test client"
msgstr "장고 테스트 클라이언트"

#: ../../intro/tutorial05.txt:330
msgid ""
"Django provides a test :class:`~django.test.Client` to simulate a user "
"interacting with the code at the view level.  We can use it in ``tests.py`` "
"or even in the :djadmin:`shell`."
msgstr ""
"Django는 :class:`~django.test.Client` 테스트를 제공하여 뷰 레벨에서 코드와 상호 작용하는 사용자를 "
"시뮬레이트합니다. 우리는 ``tests.py``\\ 또는 :djadmin:`shell`\\ 에서 사용할 수 있습니다."

#: ../../intro/tutorial05.txt:334
msgid ""
"We will start again with the :djadmin:`shell`, where we need to do a couple "
"of things that won't be necessary in ``tests.py``. The first is to set up "
"the test environment in the :djadmin:`shell`::"
msgstr ""
"우리는 :djadmin:`shell`\\ 로 다시 시작하면서 ``tests.py`` 에서 필요하지 않았던 것들을 몇 가지 해야합니다. 첫"
" 번째는 :djadmin:`shell`\\ 에서 테스트 환경을 설정하는 것입니다::"

#: ../../intro/tutorial05.txt:341
msgid ""
":meth:`~django.test.utils.setup_test_environment` installs a template "
"renderer which will allow us to examine some additional attributes on "
"responses such as ``response.context`` that otherwise wouldn't be available."
" Note that this method *does not* setup a test database, so the following "
"will be run against the existing database and the output may differ slightly"
" depending on what questions you already created. You might get unexpected "
"results if your ``TIME_ZONE`` in ``settings.py`` isn't correct. If you don't"
" remember setting it earlier, check it before continuing."
msgstr ""
"`response.context`\\ 와 같은 `response`\\ 의 추가적인 속성을 사용할수 있게 하기위해서 "
":meth:`~django.test.utils.setup_test_environment`\\ 를 사용하여 템플릿 렌더러를 설치합니다. 이"
" 메소드는 테스트 데이터베이스를 셋업하지 *않습니다*. 그렇기때문에 테스트는 현재 사용중인 데이터베이스위에서 돌게되며 결과는 "
"데이터베이스에 이미 만들어져있는 질문들에 따라서 조금씩 달라질수 있습니다. 또한 ``settings.py``\\ "
"의``TIME_ZONE``\\ 이 올바르지 않으면 예기치 않은 결과가 발생할 수 있습니다. 초기에 어떻게 설정해놨는지 기억나지 않는다면 "
"진행하기전에 먼저 확인하십시오."

#: ../../intro/tutorial05.txt:350
msgid ""
"Next we need to import the test client class (later in ``tests.py`` we will "
"use the :class:`django.test.TestCase` class, which comes with its own "
"client, so this won't be required)::"
msgstr ""
"다음으로 우리는 테스트 클라이언트 클래스를 import 해야합니다. (나중에 ``tests.py``\\ 에서는 "
":class:`django.test.TestCase` 클래스에 같이 딸려오는 클라이언트를 사용할 것이므로 이것은 필요하지 않을 "
"것입니다)::"

#: ../../intro/tutorial05.txt:358
msgid "With that ready, we can ask the client to do some work for us::"
msgstr "이런것들이 준비가 되었다면 이제 우리는 클라이언트에세 우리를 위해 일을 하라고 시킬수 있습니다."

#: ../../intro/tutorial05.txt:379
msgid "Improving our view"
msgstr "뷰를 개선시키기"

#: ../../intro/tutorial05.txt:381
msgid ""
"The list of polls shows polls that aren't published yet (i.e. those that "
"have a ``pub_date`` in the future). Let's fix that."
msgstr ""
"설문 조사 목록에는 아직 게시되지 않은 설문 조사 (즉, 장래에 ``pub_date``\\가 있는 설문 조사)가 표시됩니다. 그것을 "
"수정합시다."

#: ../../intro/tutorial05.txt:384
msgid ""
"In :doc:`Tutorial 4 </intro/tutorial04>` we introduced a class-based view, "
"based on :class:`~django.views.generic.list.ListView`:"
msgstr ""
":doc:`Tutorial 4 </intro/tutorial04>`\\에서 "
":class:`~django.views.generic.list.ListView` 클래스 기반의 뷰를 소개했습니다:"

#: ../../intro/tutorial05.txt:398
msgid ""
"We need to amend the ``get_queryset()`` method and change it so that it also"
" checks the date by comparing it with ``timezone.now()``. First we need to "
"add an import:"
msgstr ""
"우리는``get_queryset()`` 메소드를 수정하여 ``timezone.now()`` 와 비교하여 날짜를 검사하도록 변경해야합니다."
" 먼저 가져 오기를 추가해야합니다:"

#: ../../intro/tutorial05.txt:407
msgid "and then we must amend the ``get_queryset`` method like so:"
msgstr "그리고 다음과 같이 ``get_queryset`` 메소드를 수정해야합니다:"

#: ../../intro/tutorial05.txt:421
msgid ""
"``Question.objects.filter(pub_date__lte=timezone.now())`` returns a queryset"
" containing ``Question``\\s whose ``pub_date`` is less than or equal to - "
"that is, earlier than or equal to - ``timezone.now``."
msgstr ""
"``Question.objects.filter (pub_date__lte = timezone.now ())`` 는 "
"``timezone.now`` 보다 ``pub_date`` 가 작거나 같은 ``Question``\\s 를 포함하는 queryset을 "
"리턴합니다."

#: ../../intro/tutorial05.txt:426
msgid "Testing our new view"
msgstr "새로운 뷰 테스트"

#: ../../intro/tutorial05.txt:428
msgid ""
"Now you can satisfy yourself that this behaves as expected by firing up the "
"runserver, loading the site in your browser, creating ``Questions`` with "
"dates in the past and future, and checking that only those that have been "
"published are listed.  You don't want to have to do that *every single time "
"you make any change that might affect this* - so let's also create a test, "
"based on our :djadmin:`shell` session above."
msgstr ""
" runserver를 가동하고, 브라우저에 사이트를 로드하고, 과거와 미래의 날짜가 포함 된 ``Questions``\\를 작성하고, "
"게시 된 것만 나열되는 것이 예상대로 동작하니 이제 좋습니다. *여러분이 이것에 영향을 줄 수있는 변경을 할 때마다* 그렇게하지 "
"않으려합니다 - 위의 :djadmin:`shell` 세션을 기반으로 테스트를 만들어 봅시다."

#: ../../intro/tutorial05.txt:435
msgid "Add the following to ``polls/tests.py``:"
msgstr "``polls/tests.py``\\에 다음을 추가하십시오:"

#: ../../intro/tutorial05.txt:442
msgid ""
"and we'll create a shortcut function to create questions as well as a new "
"test class:"
msgstr "새로운 테스트 클래스와 함께 질문들을 생성하는 함수를 만들것입니다:"

#: ../../intro/tutorial05.txt:516
msgid "Let's look at some of these more closely."
msgstr "이 중 일부를 더 자세히 살펴 보겠습니다."

#: ../../intro/tutorial05.txt:518
msgid ""
"First is a question shortcut function, ``create_question``, to take some "
"repetition out of the process of creating questions."
msgstr "먼저, 질문 생성 함수인 ``create_question`` 은 테스트 과정 중 설문을 생성하는 부분에서 반복 사용합니다."

#: ../../intro/tutorial05.txt:521
msgid ""
"``test_index_view_with_no_questions`` doesn't create any questions, but "
"checks the message: \"No polls are available.\" and verifies the "
"``latest_question_list`` is empty. Note that the "
":class:`django.test.TestCase` class provides some additional assertion "
"methods. In these examples, we use "
":meth:`~django.test.SimpleTestCase.assertContains()` and "
":meth:`~django.test.TransactionTestCase.assertQuerysetEqual()`."
msgstr ""
"``test_index_view_with_no_questions``는 질문을 작성하지 않지만, \"설문조사가 없습니다.\" 라는 메시지를"
" 확인하고, ``latest_question_list``가 비어 있음을 확인합니다. :class:`django.test.TestCase`"
" 클래스는 몇 가지 추가적인 선언 메소드를 제공합니다. 이 예제에서 우리는:meth:`~ "
"django.test.SimpleTestCase.assertContains ()` 와 :meth:`~ "
"django.test.TransactionTestCase.assertQuerysetEqual ()`\\을 사용합니다."

#: ../../intro/tutorial05.txt:528
msgid ""
"In ``test_index_view_with_a_past_question``, we create a question and verify"
" that it appears in the list."
msgstr ""
"``test_index_view_with_a_past_question``\\에서는, 설문을 만들고 그것이 목록에 나타나는지 확인합니다."

#: ../../intro/tutorial05.txt:531
msgid ""
"In ``test_index_view_with_a_future_question``, we create a question with a "
"``pub_date`` in the future. The database is reset for each test method, so "
"the first question is no longer there, and so again the index shouldn't have"
" any questions in it."
msgstr ""
"``test_index_view_with_a_future_question``\\에서는 미래의 ``pub_date``\\로 질문을 "
"만듭니다. 데이터베이스는 각 테스트 메소드마다 재설정되므로, 첫 번째 질문은 더 이상 존재하지 않으며, 인덱스에는 질문이 없어야합니다."

#: ../../intro/tutorial05.txt:536
msgid ""
"And so on. In effect, we are using the tests to tell a story of admin input "
"and user experience on the site, and checking that at every state and for "
"every new change in the state of the system, the expected results are "
"published."
msgstr ""
"요컨데, 사이트에서 관리자 입력 및 사용자 경험에 대한 이야기를 하는 테스트를 만들었고, 모든 상태와 시스템 상태의 모든 새로운 변경 "
"사항에 대해 예상하는 결과가 출력되는지 확인합니다."

#: ../../intro/tutorial05.txt:541
msgid "Testing the ``DetailView``"
msgstr "``DetailView`` 테스트하기"

#: ../../intro/tutorial05.txt:543
msgid ""
"What we have works well; however, even though future questions don't appear "
"in the *index*, users can still reach them if they know or guess the right "
"URL. So we need to add a similar  constraint to ``DetailView``:"
msgstr ""
"우리가 만든 것이 잘 작동합니다; 그러나 미래의 설문들은 *목록*\\에 나타나지는 않지만, 사용자가 URL을 알고 있거나, 추측하면 "
"접근할 수 있습니다. 그래서 우리는``DetailView``\\에 비슷한 제약 조건을 추가 할 필요가 있습니다:"

#: ../../intro/tutorial05.txt:558
msgid ""
"And of course, we will add some tests, to check that a ``Question`` whose "
"``pub_date`` is in the past can be displayed, and that one with a "
"``pub_date`` in the future is not:"
msgstr ""
"물론, 우리는 시간이 지난 ``pub_date`` 값을 가지고 있는 ``설문``\\은 표시 되고, 미래의 ``pub_date``\\는 "
"표시되지 않게 몇 가지 검사를 추가 할 것입니다:"

#: ../../intro/tutorial05.txt:587
msgid "Ideas for more tests"
msgstr "더 많은 테스트를위한 아이디어"

#: ../../intro/tutorial05.txt:589
msgid ""
"We ought to add a similar ``get_queryset`` method to ``ResultsView`` and "
"create a new test class for that view. It'll be very similar to what we have"
" just created; in fact there will be a lot of repetition."
msgstr ""
"우리는 비슷한 ``get_queryset`` 메소드를 ``ResultsView``\\에 추가하고 그 뷰에 대한 새로운 테스트 클래스를 "
"생성해야합니다. 그것은 우리가 방금 만든 것과 매우 유사합니다. 사실 계속 반복 작업을 할 것입니다."

#: ../../intro/tutorial05.txt:593
msgid ""
"We could also improve our application in other ways, adding tests along the "
"way. For example, it's silly that ``Questions`` can be published on the site"
" that have no ``Choices``. So, our views could check for this, and exclude "
"such ``Questions``. Our tests would create a ``Question`` without "
"``Choices`` and then test that it's not published, as well as create a "
"similar ``Question`` *with* ``Choices``, and test that it *is* published."
msgstr ""
"테스트를 추가하면서 다른 방법으로 애플리케이션을 개선 할 수도 있습니다. 예를 들어, ``선택 사항``\\이 없는 사이트에 "
"``설문``\\을 게시 할 수 있다는 것은 바보같은 일입니다. 그래서 우리의 뷰는 이를 확인하고 그러한 질문을 배제 할 것입니다. 우리의"
" 테스트는 ``선택사항``\\이 없는``설문``\\을 생성 한 다음, 실제로 게시되지 않는지 테스트하고, ``선택사항``\\이 "
"있는``설문``\\을 작성하고 게시 여부를 테스트합니다."

#: ../../intro/tutorial05.txt:600
msgid ""
"Perhaps logged-in admin users should be allowed to see unpublished "
"``Questions``, but not ordinary visitors. Again: whatever needs to be added "
"to the software to accomplish this should be accompanied by a test, whether "
"you write the test first and then make the code pass the test, or work out "
"the logic in your code first and then write a test to prove it."
msgstr ""
"아마도 일반 사용자가 아닌 로그인 한 관리자는 게시되지 않은 ``설문``\\을 볼 수 있어야합니다. 다시 말하면: 소프트웨어를 추가하기 "
"위해 필요한 것은 무엇이든 테스트를 수반해야합니다, 먼저 테스트를 작성한 다음 코드가 테스트를 통과하게 만들 것인지, 아니면 먼저 "
"코드에서 로직을 처리 한 다음 이를 증명할 테스트를 작성하십시오."

#: ../../intro/tutorial05.txt:606
msgid ""
"At a certain point you are bound to look at your tests and wonder whether "
"your code is suffering from test bloat, which brings us to:"
msgstr "어느 순간엔가 너무 많은 테스트 코드들을 보고 관리하기 힘들도록 너무 비대해 지는것은 아닌가 생각할수도 있습니다."

#: ../../intro/tutorial05.txt:610
msgid "When testing, more is better"
msgstr "테스트 할 때는, 많이 할 수록 좋습니다."

#: ../../intro/tutorial05.txt:612
msgid ""
"It might seem that our tests are growing out of control. At this rate there "
"will soon be more code in our tests than in our application, and the "
"repetition is unaesthetic, compared to the elegant conciseness of the rest "
"of our code."
msgstr ""
"우리의 테스트가 통제 불능으로 성장하고있는 것처럼 보일 수 있습니다. 이 속도라면 곧 우리의 응용 프로그램에서 보다 우리의 테스트의 "
"코드가 더 많아질 것이고,  나머지 코드의 우아한 간결함과 비교했을 때, 반복하는 것은 미학적입니다."

#: ../../intro/tutorial05.txt:616
msgid ""
"**It doesn't matter**. Let them grow. For the most part, you can write a "
"test once and then forget about it. It will continue performing its useful "
"function as you continue to develop your program."
msgstr ""
"**사실 비대해지는것은 중요하지 않습니다**. 테스트 코드들이 늘어나게 하십시오. 대부분의 경우 테스트를 한 번 작성한 다음 신경을 끄게"
" 됩니다. 그래도 이 테스트 코드의 유용한 기능들은 프로그램을 개발하는 동안 계속 해서 작동할것입니다."

#: ../../intro/tutorial05.txt:620
msgid ""
"Sometimes tests will need to be updated. Suppose that we amend our views so "
"that only ``Questions`` with ``Choices`` are published. In that case, many "
"of our existing tests will fail - *telling us exactly which tests need to be"
" amended to bring them up to date*, so to that extent tests help look after "
"themselves."
msgstr ""
"때로는 테스트를 업데이트해야합니다. 우리가 ``선택지``를 가진 ``설문들``만 출력되도록 뷰를 수정한다고 가정 해 보겠습니다. 이 경우"
" 기존 테스트 중 상당수가 실패 할 것입니다. *테스트 결과를 최신으로 유지하기 위해 어떤 테스트를 수정해야하는지 정확하게 알려주므로* "
"테스트가 스스로를 돌보는 데 도움이됩니다."

#: ../../intro/tutorial05.txt:625
msgid ""
"At worst, as you continue developing, you might find that you have some "
"tests that are now redundant. Even that's not a problem; in testing "
"redundancy is a *good* thing."
msgstr ""
"최악의 경우 개발을 계속할 때 중복되는 테스트가 있을 수 있습니다. 그것은 문제가 아닙니다.  테스팅에서 반복하는 것은 *좋은* "
"일입니다."

#: ../../intro/tutorial05.txt:629
msgid ""
"As long as your tests are sensibly arranged, they won't become unmanageable."
" Good rules-of-thumb include having:"
msgstr ""
"테스트들이 현명하게 배열되어있는 한 관리가 어려워지지 않을 것입니다. 경험에 근거한 좋은 방법 중에는 다음과 같은 내용이 있습니다."

#: ../../intro/tutorial05.txt:632
msgid "a separate ``TestClass`` for each model or view"
msgstr "각 모델이나 뷰에 대한 별도의``TestClass``"

#: ../../intro/tutorial05.txt:633
msgid "a separate test method for each set of conditions you want to test"
msgstr "테스트하려는 각 조건 집합에 대해 분리된 테스트 방법"

#: ../../intro/tutorial05.txt:634
msgid "test method names that describe their function"
msgstr "기능를 설명하는 테스트 메소드 이름 "

#: ../../intro/tutorial05.txt:637
msgid "Further testing"
msgstr "추가 테스팅"

#: ../../intro/tutorial05.txt:639
msgid ""
"This tutorial only introduces some of the basics of testing. There's a great"
" deal more you can do, and a number of very useful tools at your disposal to"
" achieve some very clever things."
msgstr ""
"이 튜토리얼에서는 테스트의 기본 사항에 대해서만 소개합니다. 여러분은 더 많은 것을 할 수도 있고,  또 사용할 수 있는 똑똑한 도구들이"
" 많이 있습니다."

#: ../../intro/tutorial05.txt:643
msgid ""
"For example, while our tests here have covered some of the internal logic of"
" a model and the way our views publish information, you can use an \"in-"
"browser\" framework such as Selenium_ to test the way your HTML actually "
"renders in a browser. These tools allow you to check not just the behavior "
"of your Django code, but also, for example, of your JavaScript. It's quite "
"something to see the tests launch a browser, and start interacting with your"
" site, as if a human being were driving it! Django includes "
":class:`~django.test.LiveServerTestCase` to facilitate integration with "
"tools like Selenium."
msgstr ""
"예를 들어, 이 전에 수행 한 테스트에서는 모델의 내부 로직과 뷰에서 정보를 게시하는 방법을 다루었지만 Selenium_과 같은 "
"\"브라우저 내\" 프레임 워크를 사용하여 HTML이 브라우저에서 실제로 렌더링되는 방식을 테스트 할 수 있습니다. 이러한 도구를 "
"사용하면 장고 코드의 동작뿐만 아니라 JavaScript도 확인할 수 있습니다. 테스트가 브라우저를 시작하고 인간이 그것을 다루는 것처럼"
" 사이트와 상호 작용 것은 매우 중요합니다! Django에는 "
":class:`~django.test.LiveServerTestCase`\\가 포함되어있어 Selenium과 같은 도구와 쉽게 통합할 수"
" 있게 해줍니다."

#: ../../intro/tutorial05.txt:652
msgid ""
"If you have a complex application, you may want to run tests automatically "
"with every commit for the purposes of `continuous integration`_, so that "
"quality control is itself - at least partially - automated."
msgstr ""
"복잡한 응용 프로그램을 사용하는 경우 `연속적으로 통합`_ 하기 위해 모든 커밋마다 자동으로 테스트를 실행하여 품질 제어가 적어도 "
"부분적으로 자동화되도록 할 수 있습니다."

#: ../../intro/tutorial05.txt:656
msgid ""
"A good way to spot untested parts of your application is to check code "
"coverage. This also helps identify fragile or even dead code. If you can't "
"test a piece of code, it usually means that code should be refactored or "
"removed. Coverage will help to identify dead code. See :ref:`topics-testing-"
"code-coverage` for details."
msgstr ""
"응용 프로그램에서 테스트되지 않은 부분을 탐지하는 좋은 방법은 코드 커버리지를 확인하는 것입니다. 이것은 또한 깨지기 쉬운 코드나 "
"심지어는 죽은 코드를 식별하는 데 도움이됩니다. 코드를 테스트 할 수 없다는 것은 대개 코드가 리팩터링해야하거나 제거해야 함을 "
"의미합니다. 커버리지는 죽은 코드를 확인하는 데 도움이됩니다. 자세한 내용은 :ref:`topics-testing-code-"
"coverage` 를 참조하십시오."

#: ../../intro/tutorial05.txt:662
msgid ""
":doc:`Testing in Django </topics/testing/index>` has comprehensive "
"information about testing."
msgstr ":doc:`장고 테스트 </topics/testing/index>`\\는 테스트에 대한 포괄적인 정보를 제공합니다."

#: ../../intro/tutorial05.txt:671
msgid ""
"For full details on testing, see :doc:`Testing in Django "
"</topics/testing/index>`."
msgstr "테스트에 대한 자세한 내용은 :doc:`장고 테스트 </topics/testing/index>`\\를 참조하십시오."

#: ../../intro/tutorial05.txt:674
msgid ""
"When you're comfortable with testing Django views, read :doc:`part 6 of this"
" tutorial</intro/tutorial06>` to learn about static files management."
msgstr ""
"Django 뷰를 테스트하는 것이 익숙해졌으면, 정적 파일 관리에 대해 배울 수 있는 :doc:`이 튜토리얼의 "
"6장</intro/tutorial06>`\\을 보세요."

#: ../../intro/tutorial06.txt:3
msgid "Writing your first Django app, part 6"
msgstr "첫 번째 장고 앱 작성하기, part 6"

#: ../../intro/tutorial06.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 5 </intro/tutorial05>` left off. "
"We've built a tested Web-poll application, and we'll now add a stylesheet "
"and an image."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 5장 </intro/tutorial05>`\\에 이어서 시작합니다. 우리는 테스트 된 웹 설문조사 "
"애플리케이션을 구축했으며, 이제 스타일 시트와 이미지를 추가 할 것입니다."

#: ../../intro/tutorial06.txt:9
msgid ""
"Aside from the HTML generated by the server, web applications generally need"
" to serve additional files — such as images, JavaScript, or CSS — necessary "
"to render the complete web page. In Django, we refer to these files as "
"\"static files\"."
msgstr ""
"서버에서 생성 된 HTML을 제외하고,  웹 응용 프로그램은 일반적으로 전체 웹 페이지를 렌더링하는 데 필요한 추가 파일 — 예:이미지,"
" JavaScript 또는 CSS — 을 제공해야합니다. Django에서는 이러한 파일을 \"정적 파일\" 이라고 부릅니다. "

#: ../../intro/tutorial06.txt:14
msgid ""
"For small projects, this isn't a big deal, because you can just keep the "
"static files somewhere your web server can find it. However, in bigger "
"projects -- especially those comprised of multiple apps -- dealing with the "
"multiple sets of static files provided by each application starts to get "
"tricky."
msgstr ""
"소규모 프로젝트의 경우, 웹 서버가 정적 파일을 보관할 수 있기 때문에 큰 문제는 아닙니다. 그러나 더 큰 프로젝트 -- 특히 여러 응용"
" 프로그램으로 구성된 프로젝트 -- 의 경우각 응용 프로그램에서 제공하는 여러 정적 파일 세트를 다루는 것이 까다로워지기 시작합니다."

#: ../../intro/tutorial06.txt:20
msgid ""
"That's what ``django.contrib.staticfiles`` is for: it collects static files "
"from each of your applications (and any other places you specify) into a "
"single location that can easily be served in production."
msgstr ""
"이것이``django.contrib.staticfiles``\\의 목적입니다: 이것은 각 응용 프로그램(및 여러분이 지정한 다른 위치)의"
" 정적 파일들을 프로덕션 환경에서 쉽게 제공 할 수있는 단일 위치로 수집합니다."

#: ../../intro/tutorial06.txt:25
msgid "Customize your *app's* look and feel"
msgstr "*앱*\\의 모양과 느낌을 원하는 대로 바꿔보세요."

#: ../../intro/tutorial06.txt:27
msgid ""
"First, create a directory called ``static`` in your ``polls`` directory. "
"Django will look for static files there, similarly to how Django finds "
"templates inside ``polls/templates/``."
msgstr ""
"먼저, ``polls`` 디렉토리에 ``static`` 디렉토리를 만듭니다.  ``polls/templates/``안의 템플릿을 찾는 "
"것과 비슷하게 정적 파일을 찾습니다."

#: ../../intro/tutorial06.txt:31
msgid ""
"Django's :setting:`STATICFILES_FINDERS` setting contains a list of finders "
"that know how to discover static files from various sources. One of the "
"defaults is ``AppDirectoriesFinder`` which looks for a \"static\" "
"subdirectory in each of the :setting:`INSTALLED_APPS`, like the one in "
"``polls`` we just created. The admin site uses the same directory structure "
"for its static files."
msgstr ""
"Django의 :setting:`STATICFILES_FINDERS`  설정은 다양한 소스에서 정적 파일을 찾는 방법을 알고 있는 파인더"
" 목록을 가지고 있습니다. 기본값 중 하나는 ``AppDirectoriesFinder`` 인데,  "
":setting:`INSTALLED_APPS` 에서 \"정적\" 하위 디렉토리를 찾습니다, 방금 생성 한 ``polls`` 의 "
"경우입니다. 관리 사이트는 정적 파일에 대해 동일한 디렉토리 구조를 사용합니다."

#: ../../intro/tutorial06.txt:38
msgid ""
"Within the ``static`` directory you have just created, create another "
"directory called ``polls`` and within that create a file called "
"``style.css``. In other words, your stylesheet should be at "
"``polls/static/polls/style.css``. Because of how the "
"``AppDirectoriesFinder`` staticfile finder works, you can refer to this "
"static file in Django simply as ``polls/style.css``, similar to how you "
"reference the path for templates."
msgstr ""
"방금 생성 한 ``static`` 디렉토리 안에 ``polls`` 라는 또 다른 디렉토리를 만들고 그 안에 ``style.css`` 라는"
" 파일을 만듭니다. 즉, 스타일 시트는``polls/static/polls/style.css``\\에 있어야합니다. "
"``AppDirectoriesFinder`` 정적 파일 파인더가 작동하는 방식에 따라 Django의 정적 파일을 "
"``polls/style.css`` 라고 간단하게 참조 할 수 있습니다. 이것은 템플릿 경로를 참조하는 것과 유사합니다."

#: ../../intro/tutorial06.txt:45
msgid "Static file namespacing"
msgstr "정적 파일 네임스페이싱"

#: ../../intro/tutorial06.txt:47
msgid ""
"Just like templates, we *might* be able to get away with putting our static "
"files directly in ``polls/static`` (rather than creating another ``polls`` "
"subdirectory), but it would actually be a bad idea. Django will choose the "
"first static file it finds whose name matches, and if you had a static file "
"with the same name in a *different* application, Django would be unable to "
"distinguish between them. We need to be able to point Django at the right "
"one, and the easiest way to ensure this is by *namespacing* them. That is, "
"by putting those static files inside *another* directory named for the "
"application itself."
msgstr ""
"템플릿과 마찬가지로, 정적 파일을 ``polls/static``\\에 직접 둘 수도 있습니다(``polls`` 하위 디렉토리를 만들지 "
"않고). 하지만 실제로는 좋지 않습니다. Django는 이름이 일치하는 첫 번째 정적 파일을 선택할 것입니다, 그런데 만약 *다른* 응용"
" 프로그램에 같은 이름의 정적 파일이있는 경우에는 이들을 구별하지 못합니다. Django가 올바른 것을 가리킬 수 있게 해야합니다,  "
"이것을 보장하는 가장 쉬운 방법은 *네임스페이싱* 입니다. 즉, 정적 파일을 응용 프로그램 자체의 *다른*  디렉토리에 두는 것입니다."

#: ../../intro/tutorial06.txt:57
msgid ""
"Put the following code in that stylesheet "
"(``polls/static/polls/style.css``):"
msgstr "그 스타일 시트 (``polls/static/polls/style.css``)에 다음 코드를 넣으십시오:"

#: ../../intro/tutorial06.txt:66
msgid ""
"Next, add the following at the top of ``polls/templates/polls/index.html``:"
msgstr "다음으로, ``polls/templates/polls/index.html``의 맨 위에 다음을 추가하십시오:"

#: ../../intro/tutorial06.txt:75
msgid ""
"The ``{% static %}`` template tag generates the absolute URL of static "
"files."
msgstr "``{% static %}`` 템플릿 태그는 정적 파일의 절대 URL을 생성합니다."

#: ../../intro/tutorial06.txt:77
msgid ""
"That's all you need to do for development. Reload "
"``http://localhost:8000/polls/`` and you should see that the question links "
"are green (Django style!) which means that your stylesheet was properly "
"loaded."
msgstr ""
"개발할 때 이것만 하면 됩니다. ``http://localhost:8000/polls/``\\를 새로 고침하면, 질문 링크가 녹색 "
"(Django 스타일!) 인 것을 볼 수 있습니다. 이는 스타일 시트가 제대로 로드되었음을 의미합니다."

#: ../../intro/tutorial06.txt:82
msgid "Adding a background-image"
msgstr "백그라운드 이미지를 추가합니다."

#: ../../intro/tutorial06.txt:84
msgid ""
"Next, we'll create a subdirectory for images. Create an ``images`` "
"subdirectory in the ``polls/static/polls/`` directory. Inside this "
"directory, put an image called ``background.gif``. In other words, put your "
"image in ``polls/static/polls/images/background.gif``."
msgstr ""
"다음으로, 이미지 용 하위 디렉토리를 만듭니다. ``polls/static/polls/`` 디렉토리에``images`` 서브 디렉토리를 "
"만듭니다. 이 디렉토리 안에 ``background.gif``\\라는 이미지를 넣으십시오. 즉, 이미지를 "
"``polls/static/polls/images/background.gif``\\에 넣으십시오."

#: ../../intro/tutorial06.txt:89
msgid "Then, add to your stylesheet (``polls/static/polls/style.css``):"
msgstr "그런 다음, 스타일 시트에 추가하십시오 (``polls/static/polls/style.css``):"

#: ../../intro/tutorial06.txt:98
msgid ""
"Reload ``http://localhost:8000/polls/`` and you should see the background "
"loaded in the bottom right of the screen."
msgstr "``http://localhost:8000/polls/``\\을 새로 고침하면 화면의 오른쪽 하단에 배경이 표시됩니다. "

#: ../../intro/tutorial06.txt:103
msgid ""
"Of course the ``{% static %}`` template tag is not available for use in "
"static files like your stylesheet which aren't generated by Django. You "
"should always use **relative paths** to link your static files between each "
"other, because then you can change :setting:`STATIC_URL` (used by the "
":ttag:`static` template tag to generate its URLs) without having to modify a"
" bunch of paths in your static files as well."
msgstr ""
"물론 장고가 생성하지 않은 스타일 시트 같은 정적 파일에는 ``{% static %}`` 템플릿 태그는 사용할 수 없습니다. 정적 파일 "
"사이에서 링크는 **상대 경로**\\ 를 사용해야합니다. :setting:`STATIC_URL`  (:ttag:`static` 템플릿 "
"태그가 URL을 생성하기 위해 사용)을 변경할 수 있기 때문에 정적 파일에서 여러 경로를 수정할 필요가 없습니다."

#: ../../intro/tutorial06.txt:110
msgid ""
"These are the **basics**. For more details on settings and other bits "
"included with the framework see :doc:`the static files howto </howto/static-"
"files/index>` and :doc:`the staticfiles reference "
"</ref/contrib/staticfiles>`. :doc:`Deploying static files </howto/static-"
"files/deployment>` discusses how to use static files on a real server."
msgstr ""
"지금까지 내용은 **기본**\\입니다. 프레임 워크에 포함된 설정 및 다른 것들에 대한 자세한 내용은 doc:`정적 파일 howto "
"</howto/static-files/index>` 와 :doc:`정적파일 레퍼런스 </ref/contrib/staticfiles> '를"
" 참조하십시오. :doc:`정적 파일 배포 </howto/static-files/deployment>`는 실제 서버에서 정적 파일을 "
"사용하는 방법을 설명합니다."

#: ../../intro/tutorial06.txt:117
msgid ""
"When you're comfortable with the static files, read :doc:`part 7 of this "
"tutorial </intro/tutorial07>` to learn how to customize Django's "
"automatically-generated admin site."
msgstr ""
"정적 파일에 익숙해졌으면, Django의 자동 생성되는 관리자 사이트를 커스터마이징하는 법에 대해 배울 수 있는 :doc:`이 튜토리얼의"
" 7장 </intro/tutorial07>`\\을 보세요."

#: ../../intro/tutorial07.txt:3
msgid "Writing your first Django app, part 7"
msgstr "첫 번째 장고 앱 작성하기, part 7"

#: ../../intro/tutorial07.txt:5
msgid ""
"This tutorial begins where :doc:`Tutorial 6 </intro/tutorial06>` left off. "
"We're continuing the Web-poll application and will focus on customizing "
"Django's automatically-generated admin site that we first explored in "
":doc:`Tutorial 2 </intro/tutorial02>`."
msgstr ""
"이 튜토리얼은  :doc:`튜토리얼 6장 </intro/tutorial06>`\\에 이어서 시작합니다. 우리는 웹 설문조사 응용 "
"프로그램을 계속 사용하고 있으며, :doc:`튜토리얼 2장 </intro/tutorial02>`\\에서 봤었던 자동으로 생성된 관리자 "
"사이트를 커스터마이징하는 데 초점을 맞출 것입니다."

#: ../../intro/tutorial07.txt:11
msgid "Customize the admin form"
msgstr "관리자 폼 커스터마이징"

#: ../../intro/tutorial07.txt:13
msgid ""
"By registering the ``Question`` model with "
"``admin.site.register(Question)``, Django was able to construct a default "
"form representation. Often, you'll want to customize how the admin form "
"looks and works. You'll do this by telling Django the options you want when "
"you register the object."
msgstr ""
"``Question`` 모델을 ``admin.site.register(Question)``\\에 등록함으로써, Django는 디폴트 폼 "
"표현을 구성 할 수있었습니다. 관리 폼이 보이고 작동하는 방법을 커스터마이징하려는 경우가 있습니다. 객체를 등록 할 때 Django에 "
"원하는 옵션을 알려주면 커스터마이징 할 수 있습니다."

#: ../../intro/tutorial07.txt:18
msgid ""
"Let's see how this works by reordering the fields on the edit form. Replace "
"the ``admin.site.register(Question)`` line with:"
msgstr ""
"수정 폼의 필드를 재정렬하여 이것이 작동하는법을 보겠습니다. ``admin.site.register(Question)`` 줄을 다음과 "
"같이 바꾸세요:"

#: ../../intro/tutorial07.txt:34
msgid ""
"You'll follow this pattern -- create a model admin class, then pass it as "
"the second argument to ``admin.site.register()`` -- any time you need to "
"change the admin options for a model."
msgstr ""
"모델의 관리자 옵션을 변경해야 할 때마다 이 패턴 -- 모델 어드민 클래스를 만든 다음, "
"``admin.site.register()``\\에 두 번째 인수로 전달합니다 -- 을 따라하면 됩니다."

#: ../../intro/tutorial07.txt:38
msgid ""
"This particular change above makes the \"Publication date\" come before the "
"\"Question\" field:"
msgstr "여기서 특별한 변경 사항은 \"발행일\"이 \"설문\" 필드 앞에 오게 만듭니다."

#: ../../intro/tutorial07.txt:44
msgid ""
"This isn't impressive with only two fields, but for admin forms with dozens "
"of fields, choosing an intuitive order is an important usability detail."
msgstr ""
"단지 2개의 필드만으로는 인상적이지는 않지만, 수십 개의 필드가 있는 관리 폼의 경우에는 직관적인 순서을 선택하는 것이 사용 편리성의 "
"중요한 부분입니다."

#: ../../intro/tutorial07.txt:47
msgid ""
"And speaking of forms with dozens of fields, you might want to split the "
"form up into fieldsets:"
msgstr "수십 개의 필드가 있는 폼에 관해서는 폼을 fieldset으로 분할하는 것이 좋습니다."

#: ../../intro/tutorial07.txt:66
msgid ""
"The first element of each tuple in "
":attr:`~django.contrib.admin.ModelAdmin.fieldsets` is the title of the "
"fieldset. Here's what our form looks like now:"
msgstr ""
":attr:`~django.contrib.admin.ModelAdmin.fieldsets`\\의 각 튜플의 첫 번째 요소는 "
"fieldset의 제목입니다. 우리의 폼이 다음과 같이 변했네요:"

#: ../../intro/tutorial07.txt:74
msgid "Adding related objects"
msgstr "관련된 객체 추가"

#: ../../intro/tutorial07.txt:76
msgid ""
"OK, we have our Question admin page, but a ``Question`` has multiple "
"``Choice``\\s, and the admin page doesn't display choices."
msgstr ""
"OK, 우리는 Question 관리자 페이지를 가지고 있습니다. 그러나, ``Question``\\은 여러 개의``Choice``\\들을"
" 가지고 있음에도, admin 페이지는 선택 사항을 표시하지 않습니다."

#: ../../intro/tutorial07.txt:79
msgid "Yet."
msgstr "아직."

#: ../../intro/tutorial07.txt:81
msgid ""
"There are two ways to solve this problem. The first is to register "
"``Choice`` with the admin just as we did with ``Question``. That's easy:"
msgstr ""
"이 문제를 해결하는 데는 두 가지 방법이 있습니다. 첫 번째는 ``Question``\\에서 했던 것처럼 관리자에 "
"``Choice``\\를 등록하는 것입니다. 간단합니다:"

#: ../../intro/tutorial07.txt:93
msgid ""
"Now \"Choices\" is an available option in the Django admin. The \"Add "
"choice\" form looks like this:"
msgstr "이제 \"Choices\"\\는 Django 관리자가 사용할 수 있는 옵션입니다. \"Add choice\" 폼은 다음과 같습니다."

#: ../../intro/tutorial07.txt:99
msgid ""
"In that form, the \"Question\" field is a select box containing every "
"question in the database. Django knows that a "
":class:`~django.db.models.ForeignKey` should be represented in the admin as "
"a ``<select>`` box. In our case, only one question exists at this point."
msgstr ""
"이 양식에서 \"Question\" 필드는 데이터베이스의 모든 질문을 포함하는 select box입니다. Django는 "
":class:`~django.db.models.ForeignKey`\\가 admin에서``<select>``\\로 표현되어야 함을 알고 "
"있습니다. 우리의 경우, 지금은 단 하나의 질문 만이 존재합니다."

#: ../../intro/tutorial07.txt:104
msgid ""
"Also note the \"Add Another\" link next to \"Question.\" Every object with a"
" ``ForeignKey`` relationship to another gets this for free. When you click "
"\"Add Another\", you'll get a popup window with the \"Add question\" form. "
"If you add a question in that window and click \"Save\", Django will save "
"the question to the database and dynamically add it as the selected choice "
"on the \"Add choice\" form you're looking at."
msgstr ""
"또한 \"Question\" 옆의 \"Add Another\" 링크를 주목하세요. ``ForeignKey`` 관계를 가진 모든 객체는 저"
" 링크가 붙습니다. \"Add Another\"를 클릭하면 \"Add question\" 폼이 있는 팝업 창이 나타납니다. 해당 창에 "
"질문을 추가하고 \"Save\"를 클릭하면 장고는 질문을 데이터베이스에 저장하고, 동적으로 이를 선택된 항목으로 당신이 보고있는 "
"\"Add choice\" 폼에 추가합니다."

#: ../../intro/tutorial07.txt:111
msgid ""
"But, really, this is an inefficient way of adding ``Choice`` objects to the "
"system. It'd be better if you could add a bunch of Choices directly when you"
" create the ``Question`` object. Let's make that happen."
msgstr ""
"그러나 실제로 이것은``Choice`` 객체를 시스템에 추가하는 비효율적 인 방법입니다. ``Question`` 객체를 생성 할 때 "
"여러개의 Choices를 직접 추가 할 수 있다면 더 좋을 것입니다. 그 것을 만들어 봅시다."

#: ../../intro/tutorial07.txt:115
msgid ""
"Remove the ``register()`` call for the ``Choice`` model. Then, edit the "
"``Question`` registration code to read:"
msgstr ""
"``Choice`` 모델에 대한 ``register ()`` 호출을 제거하십시오. 그런 다음 ``Question`` 등록 코드를 다음과 "
"같이 편집하십시오:"

#: ../../intro/tutorial07.txt:140
msgid ""
"This tells Django: \"``Choice`` objects are edited on the ``Question`` admin"
" page. By default, provide enough fields for 3 choices.\""
msgstr ""
"위 소소는 Django에게  \" ``Choice`` 객체는``Question`` 관리자 페이지에서 편집됩니다. 기본적으로 3 가지 선택"
" 항목을 제공합니다.\"라고 알려줍니다."

#: ../../intro/tutorial07.txt:143
msgid "Load the \"Add question\" page to see how that looks:"
msgstr "모양을 보려면 \"Add question\" 페이지를로드하십시오."

#: ../../intro/tutorial07.txt:148
msgid ""
"It works like this: There are three slots for related Choices -- as "
"specified by ``extra`` -- and each time you come back to the \"Change\" page"
" for an already-created object, you get another three extra slots."
msgstr ""
"그것은 다음과 같이 작동합니다: 관련된 선택 사항을 위한 슬롯이 세 개 있습니다 -- ``extra``로 지정됨 -- 이미 생성된 객체의"
" \"Change\" 페이지의 경우에도 빈 세 개의 슬롯이 생깁니다."

#: ../../intro/tutorial07.txt:152
msgid ""
"At the end of the three current slots you will find an \"Add another "
"Choice\" link.  If you click on it, a new slot will be added. If you want to"
" remove the added slot, you can click on the X to the top right of the added"
" slot. Note that you can't remove the original three slots. This image shows"
" an added slot:"
msgstr ""
"3 개의 현재 슬롯 끝에 \"Add another Choice\" 링크가 있습니다. 그것을 클릭하면 새로운 슬롯이 추가됩니다. 추가 된 "
"슬롯을 제거하려면 추가 된 슬롯의 오른쪽 상단에있는 X를 클릭하십시오. 원래의 세 슬롯은 제거 할 수 없습니다.  아래 이미지는 추가 된"
" 슬롯을 보여줍니다."

#: ../../intro/tutorial07.txt:160
msgid ""
"One small problem, though. It takes a lot of screen space to display all the"
" fields for entering related ``Choice`` objects. For that reason, Django "
"offers a tabular way of displaying inline related objects; you just need to "
"change the ``ChoiceInline`` declaration to read:"
msgstr ""
"하나의 작은 문제. 관련 ``Choice`` 객체를 입력하기위한 모든 필드를 표시하는 데는 많은 화면 공간이 필요합니다. 이런 이유로 "
"Django는 인라인 관련 객체를 표시하는 표 형식의 방법을 제공합니다. 다음과 같이 ``ChoiceInline`` 선언을 "
"변경하면됩니다:"

#: ../../intro/tutorial07.txt:171
msgid ""
"With that ``TabularInline`` (instead of ``StackedInline``), the related "
"objects are displayed in a more compact, table-based format:"
msgstr ""
"``StackedInline`` 대신에``TabularInline``을 사용하여, 관련된 객체는 좀 더 조밀하고 테이블 기반 형식으로 "
"표시됩니다:"

#: ../../intro/tutorial07.txt:177
msgid ""
"Note that there is an extra \"Delete?\" column that allows removing rows "
"added using the \"Add Another Choice\" button and rows that have already "
"been saved."
msgstr "참고로 \"Delete?\" 열은  \"Add Another Choice\" 버튼으로 추가된 행과 이미 저장된 행을 삭제하는데 사용합니다."

#: ../../intro/tutorial07.txt:181
msgid "Customize the admin change list"
msgstr "관리자 변경 목록--change list-- 커스터마이징"

#: ../../intro/tutorial07.txt:183
msgid ""
"Now that the Question admin page is looking good, let's make some tweaks to "
"the \"change list\" page -- the one that displays all the questions in the "
"system."
msgstr "이제 질문 관리 페이지가 그럴싸해보이므로, 시스템의 모든 질문을 표시하는 \"변경 목록\" 페이지를 약간 조정하십시오."

#: ../../intro/tutorial07.txt:186
msgid "Here's what it looks like at this point:"
msgstr "다음은 이 시점의 모습입니다."

#: ../../intro/tutorial07.txt:191
msgid ""
"By default, Django displays the ``str()`` of each object. But sometimes it'd"
" be more helpful if we could display individual fields. To do that, use the "
":attr:`~django.contrib.admin.ModelAdmin.list_display` admin option, which is"
" a tuple of field names to display, as columns, on the change list page for "
"the object:"
msgstr ""
"기본적으로 Django는 각 객체의 ``str()``\\을 표시합니다. 그러나 개별 필드를 표시 할 수 있는 경우 가끔 도움이 될 수 "
"있습니다. 이렇게 하려면 :attr:`~django.contrib.admin.ModelAdmin.list_display` 관리 옵션을 "
"사용합니다. 이 옵션은 객체의 변경 목록 페이지에서 열로 표시 할 필드 이름의 튜플입니다."

#: ../../intro/tutorial07.txt:204
msgid ""
"Just for good measure, let's also include the ``was_published_recently()`` "
"method from :doc:`Tutorial 2 </intro/tutorial02>`:"
msgstr ""
":doc:`Tutorial 2 </intro/tutorial02>``\\에서 사용한  "
"``was_published_recently()``\\를 추가해봅시다:"

#: ../../intro/tutorial07.txt:214
msgid "Now the question change list page looks like this:"
msgstr "이제 질문 변경 목록 페이지는 다음과 같습니다."

#: ../../intro/tutorial07.txt:219
msgid ""
"You can click on the column headers to sort by those values -- except in the"
" case of the ``was_published_recently`` header, because sorting by the "
"output of an arbitrary method is not supported. Also note that the column "
"header for ``was_published_recently`` is, by default, the name of the method"
" (with underscores replaced with spaces), and that each line contains the "
"string representation of the output."
msgstr ""
"``was_published_recently`` 헤더의 경우를 제외하고 그 값으로 정렬하기 위해 열 머리글을 클릭 할 수 있습니다. "
"왜냐하면 임의의 메서드의 출력에 의한 정렬은 지원되지 않기 때문입니다. 또한 ``was_published_recently``\\에 대한 "
"열 머리글은 기본적으로 메서드 이름 (밑줄을 공백으로 대체)이며 각 줄에는 출력의 문자열 표현이 포함되어 있습니다."

#: ../../intro/tutorial07.txt:226
msgid ""
"You can improve that by giving that method (in :file:`polls/models.py`) a "
"few attributes, as follows:"
msgstr "다음과 같이 해당 메소드 (:file:`polls/models.py`)에 몇 가지 속성을 부여하여 향상시킬 수 있습니다:"

#: ../../intro/tutorial07.txt:241
msgid ""
"For more information on these method properties, see "
":attr:`~django.contrib.admin.ModelAdmin.list_display`."
msgstr ""
"이러한 메소드 속성들에 대한 더 자세한 정보는 "
":attr:`~django.contrib.admin.ModelAdmin.list_display`\\를 참조하십시오."

#: ../../intro/tutorial07.txt:244
msgid ""
"Edit your :file:`polls/admin.py` file again and add an improvement to the "
"``Question`` change list page: filters using the "
":attr:`~django.contrib.admin.ModelAdmin.list_filter`. Add the following line"
" to ``QuestionAdmin``::"
msgstr ""
":file:`polls/admin.py` 파일을 다시 편집하고 `Question`  변경 목록 페이지에 개선점을 추가하십시오: "
":attr:`~django.contrib.admin.ModelAdmin.list_filter`를 사용하는 필터. "
"``QuestionAdmin``에 다음 줄을 추가하십시오::"

#: ../../intro/tutorial07.txt:251
msgid ""
"That adds a \"Filter\" sidebar that lets people filter the change list by "
"the ``pub_date`` field:"
msgstr "``pub_date`` 필드에 의해 사람들이 변경 목록을 필터링 할 수 있게 해주는 \"Filter\" 사이드 바가 추가되었습니다:"

#: ../../intro/tutorial07.txt:257
msgid ""
"The type of filter displayed depends on the type of field you're filtering "
"on. Because ``pub_date`` is a :class:`~django.db.models.DateTimeField`, "
"Django knows to give appropriate filter options: \"Any date\", \"Today\", "
"\"Past 7 days\", \"This month\", \"This year\"."
msgstr ""
"표시되는 필터의 유형은 필터링중인 필드의 유형에 따라 다릅니다. ``pub_date``\\는 "
":class:`~django.db.models.DateTimeField`\\이므로, Django는 \"Any date\", "
"\"Today\", \"Past 7 days\", \"This month\", \"This year\" 등의 적절한 필터 옵션을 "
"제공합니다."

#: ../../intro/tutorial07.txt:262
msgid "This is shaping up well. Let's add some search capability::"
msgstr "잘 만들어지고 있습니다. 이제 검색 기능을 추가해 보겠습니다::"

#: ../../intro/tutorial07.txt:266
msgid ""
"That adds a search box at the top of the change list. When somebody enters "
"search terms, Django will search the ``question_text`` field. You can use as"
" many fields as you'd like -- although because it uses a ``LIKE`` query "
"behind the scenes, limiting the number of search fields to a reasonable "
"number will make it easier for your database to do the search."
msgstr ""
"그러면 변경 목록 맨 위에 검색 창이 추가됩니다. 누군가가 검색어를 입력하면, 장고는``question_text`` 필드를 검색합니다. "
"당신이 원하는만큼의 필드를 사용할 수 있습니다 -- 그것은 내부적으로 ``LIKE`` 쿼리를 사용하기 때문에 검색 필드의 수를 적당한 "
"수로 제한하면 데이터베이스가 검색을 더 쉽게 할 수 있습니다."

#: ../../intro/tutorial07.txt:272
msgid ""
"Now's also a good time to note that change lists give you free pagination. "
"The default is to display 100 items per page. :attr:`Change list pagination "
"<django.contrib.admin.ModelAdmin.list_per_page>`, :attr:`search boxes "
"<django.contrib.admin.ModelAdmin.search_fields>`, :attr:`filters "
"<django.contrib.admin.ModelAdmin.list_filter>`, :attr:`date-hierarchies "
"<django.contrib.admin.ModelAdmin.date_hierarchy>`, and :attr:`column-header-"
"ordering <django.contrib.admin.ModelAdmin.list_display>` all work together "
"like you think they should."
msgstr ""
"이제 변경 목록이 자동 페이징 기능을 제공한다는 점을 기억하십시오. 기본값은 페이지 당 100 개의 항목을 표시하는 것입니다. "
":attr:`변경 목록 페이지내이션 <django.contrib.admin.ModelAdmin.list_per_page>`, "
":attr:`검색 상자 <django.contrib.admin.ModelAdmin.search_fields>`, :attr:`필터 "
"<django.contrib.admin.ModelAdmin.list_filter>`, :attr:`날짜-"
"계층구조<django.contrib.admin.ModelAdmin.date_hierarchy>`, and :attr:`열-머리말-정렬 "
"<django.contrib.admin.ModelAdmin.list_display>` 모두 함께 작동합니다."

#: ../../intro/tutorial07.txt:282
msgid "Customize the admin look and feel"
msgstr "관리자 모양 및 느낌 커스터마이징"

#: ../../intro/tutorial07.txt:284
msgid ""
"Clearly, having \"Django administration\" at the top of each admin page is "
"ridiculous. It's just placeholder text."
msgstr ""
"분명히, 모든 관리자 페이지 상단에 \"Django administration\"\\이 있다는 것은 어리 석다. 그냥 자리 표시 "
"문자열입니다."

#: ../../intro/tutorial07.txt:287
msgid ""
"That's easy to change, though, using Django's template system. The Django "
"admin is powered by Django itself, and its interfaces use Django's own "
"template system."
msgstr ""
"Django의 템플릿 시스템을 사용하면 쉽게 변경할 수 있습니다. Django 관리자는 Django 자체에 의해 구동되며 인터페이스는 "
"Django 자신의 템플릿 시스템을 사용합니다."

#: ../../intro/tutorial07.txt:294
msgid "Customizing your *project's* templates"
msgstr "*프로젝트의* 템플릿 커스터마이징"

#: ../../intro/tutorial07.txt:296
msgid ""
"Create a ``templates`` directory in your project directory (the one that "
"contains ``manage.py``). Templates can live anywhere on your filesystem that"
" Django can access. (Django runs as whatever user your server runs.) "
"However, keeping your templates within the project is a good convention to "
"follow."
msgstr ""
"프로젝트 디렉토리 (``manage.py``를 포함하고있는)에``templates`` 디렉토리를 만듭니다. 템플릿은 장고가 액세스 할 "
"수있는 파일 시스템 어디에서나 사용할 수 있습니다. (Django는 서버가 실행되는 사용자로 실행됩니다.) 그러나 프로젝트 내에 템플릿을"
" 유지하는 것은 따라야 할 좋은 규칙입니다."

#: ../../intro/tutorial07.txt:301
msgid ""
"Open your settings file (:file:`mysite/settings.py`, remember) and add a "
":setting:`DIRS <TEMPLATES-DIRS>` option in the :setting:`TEMPLATES` setting:"
msgstr ""
"설정 파일 (:file:`mysite/settings.py`\\를 기억하세요)을 열고 :setting:`DIRS <TEMPLATES-"
"DIRS>` 옵션을 :setting:`TEMPLATES` 설정에 추가하십시오:"

#: ../../intro/tutorial07.txt:323
msgid ""
":setting:`DIRS <TEMPLATES-DIRS>` is a list of filesystem directories to "
"check when loading Django templates; it's a search path."
msgstr ""
":setting:`DIRS <TEMPLATES-DIRS>`\\는 Django 템플릿을 로드 할 때 검사 할 파일 시스템 디렉토리 "
"목록입니다. 바로 검색 경로입니다."

#: ../../intro/tutorial07.txt:326
msgid "Organizing templates"
msgstr "템플릿 구성"

#: ../../intro/tutorial07.txt:328
msgid ""
"Just like the static files, we *could* have all our templates together, in "
"one big templates directory, and it would work perfectly well. However, "
"templates that belong to a particular application should be placed in that "
"application’s template directory (e.g. ``polls/templates``) rather than the "
"project’s (``templates``). We'll discuss in more detail in the "
":doc:`reusable apps tutorial </intro/reusable-apps>` *why* we do this."
msgstr ""
"정적 파일과 마찬가지로, 하나의 커다란 템플릿 디렉토리에 모든 템플릿을 함께 넣을 수 있습니다. 그렇게해도 완벽하게 잘 작동할것입니다. "
"그러나 특정 애플리케이션에 속한 템플릿은 프로젝트(``templates``)가 아닌 해당 애플리케이션의 템플릿 디렉토리 "
"(예:``polls/templates``)에 있어야합니다. 우리는 더 자세한 내용을:doc:`reusable apps tutorial "
"</intro/reusable-apps>`\\에서 논의할 것입니다."

#: ../../intro/tutorial07.txt:335
msgid ""
"Now create a directory called ``admin`` inside ``templates``, and copy the "
"template ``admin/base_site.html`` from within the default Django admin "
"template directory in the source code of Django itself "
"(``django/contrib/admin/templates``) into that directory."
msgstr ""
"이제``templates` 디렉토리에``admin`이라는 디렉토리를 만들고 장고 자체 소스 코드 "
"(``django/contrib/admin/templates``)을 해당 디렉토리에 복사합니다."

#: ../../intro/tutorial07.txt:340
msgid "Where are the Django source files?"
msgstr "Django 소스 파일은 어디에 있습니까?"

#: ../../intro/tutorial07.txt:342
msgid ""
"If you have difficulty finding where the Django source files are located on "
"your system, run the following command:"
msgstr "Django 소스 파일이 시스템에있는 위치를 찾는 데 어려움이있는 경우 다음 명령을 실행하십시오."

#: ../../intro/tutorial07.txt:349
msgid ""
"Then, just edit the file and replace ``{{ site_header|default:_('Django "
"administration') }}`` (including the curly braces) with your own site's name"
" as you see fit. You should end up with a section of code like:"
msgstr ""
"그런 다음, 파일을 편집하고 ``{{site_header|default:_ ('Django administration' }}``\\ "
"(중괄호를 포함하여)를 자신의 사이트 이름으로 바꿉니다. 다음과 같은 코드 섹션을 작성해야합니다."

#: ../../intro/tutorial07.txt:360
msgid ""
"We use this approach to teach you how to override templates. In an actual "
"project, you would probably use the "
":attr:`django.contrib.admin.AdminSite.site_header` attribute to more easily "
"make this particular customization."
msgstr ""
"이 방법을 사용하여 템플릿을 재정의하는 방법을 학습합니다. 실제 프로젝트에서는 아마 "
":attr:`django.contrib.admin.AdminSite.site_header` 속성을 사용하여이 개별 커스터마이징을보다 쉽게"
" 만들 수 있습니다."

#: ../../intro/tutorial07.txt:365
msgid ""
"This template file contains lots of text like ``{% block branding %}`` and "
"``{{ title }}``. The ``{%`` and ``{{`` tags are part of Django's template "
"language. When Django renders ``admin/base_site.html``, this template "
"language will be evaluated to produce the final HTML page, just like we saw "
"in :doc:`Tutorial 3 </intro/tutorial03>`."
msgstr ""
"이 템플릿 파일에는``{% block branding %}``및 {`{{title}}` '과 같은 텍스트가 많이 포함되어 있습니다. "
"``{%``와``{{``태그들은 장고의 템플릿 언어의 일부입니다. Django가``admin/base_site.html``을 렌더링 할 "
"때,이 템플릿 언어는:doc:`Tutorial 3 </intro/tutorial03>에서 보았 듯이 최종 HTML 페이지를 생성하기 위해"
" 평가 될 것입니다."

#: ../../intro/tutorial07.txt:371
msgid ""
"Note that any of Django's default admin templates can be overridden. To "
"override a template, just do the same thing you did with ``base_site.html`` "
"-- copy it from the default directory into your custom directory, and make "
"changes."
msgstr ""
"Django의 기본 admin 템플릿 중 어떤 것도 무시할 수 있습니다. 템플릿을 덮어 쓰려면, ``base_site.html``\\ "
"로했던 것과 똑같은 일을 하면 됩니다 - 기본 디렉토리에서 그것을 커스텀 디렉토리로 복사하고 변경하십시오."

#: ../../intro/tutorial07.txt:377
msgid "Customizing your *application's* templates"
msgstr "*어플리케이션의* 템플릿 사용자 정의"

#: ../../intro/tutorial07.txt:379
msgid ""
"Astute readers will ask: But if :setting:`DIRS <TEMPLATES-DIRS>` was empty "
"by default, how was Django finding the default admin templates? The answer "
"is that, since :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is set to ``True``, "
"Django automatically looks for a ``templates/`` subdirectory within each "
"application package, for use as a fallback (don't forget that "
"``django.contrib.admin`` is an application)."
msgstr ""
"그러나 :settings:`DIRS <TEMPLATES-DIRS>`\\ 가 기본설정으로 비어 있다면, 장고는 기본 관리자 템플릿을 어떻게"
" 찾을까요? 그 해답은 :settings:`APP_DIRS <TEMPLATES-APP_DIRS>` 설정이 ``True``\\ 로 설정되어"
" 있기 때문에 Django는 각 어플리케이션 패키지 내에서 ``templates/`` 서브 디렉토리를 자동으로 찾아서 대체하게 됩니다. "
"(``django.contrib.admin``\\ 이 어플리케이션 임을 잊지 마십시오.)"

#: ../../intro/tutorial07.txt:386
msgid ""
"Our poll application is not very complex and doesn't need custom admin "
"templates. But if it grew more sophisticated and required modification of "
"Django's standard admin templates for some of its functionality, it would be"
" more sensible to modify the *application's* templates, rather than those in"
" the *project*. That way, you could include the polls application in any new"
" project and be assured that it would find the custom templates it needed."
msgstr ""
"설문 조사 어플리케이션은 너무 복잡하지 않으며 사용자 정의 admin 템플릿이 필요하지 않습니다. 그러나 Django의 표준 admin "
"템플릿을 좀더 정교하게 필요에 맞게 수정 할 경우 *프로젝트* 템플릿 대신 *어플리케이션의* 템플릿을 수정하는 것이 더 현명합니다. "
"그렇게 하면 다른 새 프로젝트에 설문 조사 애플리케이션을 포함시킬 수 있고 필요할경우 사용자 정의 템플릿을 탐색해서 사용할거란걸 보장할수"
" 있습니다."

#: ../../intro/tutorial07.txt:393
msgid ""
"See the :ref:`template loading documentation <template-loading>` for more "
"information about how Django finds its templates."
msgstr ""
"Django가 템플릿을 찾는 방법에 대한 자세한 정보는 :ref:`템플릿 로딩 문서 <template-loading>`\\ 를 보십시오."

#: ../../intro/tutorial07.txt:397
msgid "Customize the admin index page"
msgstr "admin 인덱스 페이지 수정하기"

#: ../../intro/tutorial07.txt:399
msgid ""
"On a similar note, you might want to customize the look and feel of the "
"Django admin index page."
msgstr "제목과 같이, Django admin 인덱스 페이지의 모양과 느낌을 수정하고 싶을 수도 있습니다."

#: ../../intro/tutorial07.txt:402
msgid ""
"By default, it displays all the apps in :setting:`INSTALLED_APPS` that have "
"been registered with the admin application, in alphabetical order. You may "
"want to make significant changes to the layout. After all, the index is "
"probably the most important page of the admin, and it should be easy to use."
msgstr ""
"기본적으로 admin 어플리케이션과 함께 등록 된 :settings:`INSTALLED_APPS`\\ 의 모든 어플리케이션을 사전 순으로"
" 표시합니다. 어쩌면 레이아웃을 크게 변경하고자 할 수 있습니다. 설사 그렇게 하더라도 인덱스는 admin의 가장 중요한 페이지이고, "
"사용하기 쉬워야합니다."

#: ../../intro/tutorial07.txt:407
msgid ""
"The template to customize is ``admin/index.html``. (Do the same as with "
"``admin/base_site.html`` in the previous section -- copy it from the default"
" directory to your custom template directory). Edit the file, and you'll see"
" it uses a template variable called ``app_list``. That variable contains "
"every installed Django app. Instead of using that, you can hard-code links "
"to object-specific admin pages in whatever way you think is best."
msgstr ""
"커스터마이징 할 템플릿은 ``admin/index.html``\\ 입니다. (이전 섹션의 ``admin/base_site.html``\\"
" 와 같은 작업을 합니다 - 기본 디렉토리에서 커스텀 템플릿 디렉토리로 복사하십시오). 파일을 편집하면 ``app_list``\\ 라는 "
"템플릿 변수를 사용하는 것을 볼 수 있습니다. 이 변수는 설치된 모든 장고 앱을 포함합니다. 이를 사용하는 대신 최선의 방법이라고 "
"생각한다면  개체 별 admin 페이지에 대한 링크를 하드 코딩 할 수 있습니다."

#: ../../intro/tutorial07.txt:417
msgid ""
"The beginner tutorial ends here. In the meantime, you might want to check "
"out some pointers on :doc:`where to go from here </intro/whatsnext>`."
msgstr ""
"초보 자습서는 여기서 끝납니다. 아울러 :doc:`앞으로 무엇을 해야할지 </intro/whatsnext>`\\ 문서를 좀더 읽어볼수 "
"있습니다."

#: ../../intro/tutorial07.txt:420
msgid ""
"If you are familiar with Python packaging and interested in learning how to "
"turn polls into a \"reusable app\", check out :doc:`Advanced tutorial: How "
"to write reusable apps</intro/reusable-apps>`."
msgstr ""
"파이썬 패키징에 익숙하고 설문 조사를 \"재사용 가능한 앱\"으로 바꾸는 방법을 배우고 싶다면 :doc:`심화 튜토리얼:재사용 가능한 "
"애플리케이션을 만드는 법 </intro/reusable-apps>`\\ 을 읽어보십시오."

#: ../../intro/whatsnext.txt:3
msgid "What to read next"
msgstr "다음에 읽을 내용"

#: ../../intro/whatsnext.txt:5
msgid ""
"So you've read all the :doc:`introductory material </intro/index>` and have "
"decided you'd like to keep using Django. We've only just scratched the "
"surface with this intro (in fact, if you've read every single word, you've "
"read about 5% of the overall documentation)."
msgstr ""
"그래서 당신은 모든 :doc:`소개 자료 </intro/index>'\\ 를 읽었으며 Django를 계속 사용하기로 결정했습니다. 우리는"
" 이 소개 자료로 그저 걷핥기를 했습니다. (실제로 모든 단어를 읽은 경우 전체 문서의 약 5%를 읽은것 입니다.)."

#: ../../intro/whatsnext.txt:10
msgid "So what's next?"
msgstr "그럼 다음은 뭐니?"

#: ../../intro/whatsnext.txt:12
msgid ""
"Well, we've always been big fans of learning by doing. At this point you "
"should know enough to start a project of your own and start fooling around. "
"As you need to learn new tricks, come back to the documentation."
msgstr ""
"글쎄, 우리는 항상 학습을 통해 큰 팬이되어 왔습니다. 이 시점에서 자신의 프로젝트를 시작하고 바보짓을 칠 정도로 충분히 알아야합니다. "
"새로운 트릭을 배워야 할 때 문서로 돌아가십시오."

#: ../../intro/whatsnext.txt:16
msgid ""
"We've put a lot of effort into making Django's documentation useful, easy to"
" read and as complete as possible. The rest of this document explains more "
"about how the documentation works so that you can get the most out of it."
msgstr ""
"장고의 문서를 유용하고 읽기 쉽고 가능한 한 완벽하게 만들기 위해 많은 노력을 기울였습니다. 이 문서의 나머지 부분에서는 설명서가 어떻게"
" 작동하는지에 대해 자세히 설명하므로 사용자가 최대한 활용할 수 있습니다."

#: ../../intro/whatsnext.txt:20
msgid ""
"(Yes, this is documentation about documentation. Rest assured we have no "
"plans to write a document about how to read the document about "
"documentation.)"
msgstr "(예, 이것은 문서에 대한 문서입니다. 문서에 대한 문서를 읽는 방법에 대한 문서를 작성할 계획이 없으니 안심하십시오.)"

#: ../../intro/whatsnext.txt:24
msgid "Finding documentation"
msgstr "문서 찾기"

#: ../../intro/whatsnext.txt:26
msgid ""
"Django's got a *lot* of documentation -- almost 450,000 words and counting "
"-- so finding what you need can sometimes be tricky. A few good places to "
"start are the :ref:`search` and the :ref:`genindex`."
msgstr ""
"Django는 많은 문서를 가지고 있습니다. 거의 450,000 단어가 포함되어 있습니다. 그래서 당신이 필요로하는 것이 때때로 까다로울"
" 수 있습니다. 시작하기 좋은 곳은:ref:`search`와:ref:`genindex`입니다."

#: ../../intro/whatsnext.txt:30
msgid "Or you can just browse around!"
msgstr "아니면 둘러 볼 수 있습니다!"

#: ../../intro/whatsnext.txt:33
msgid "How the documentation is organized"
msgstr "이 문서의 구조"

#: ../../intro/whatsnext.txt:35
msgid ""
"Django's main documentation is broken up into \"chunks\" designed to fill "
"different needs:"
msgstr "Django의 주요 문서는 서로 다른 필요를 채우기 위해 설계된 \"덩어리\"로 나뉩니다."

#: ../../intro/whatsnext.txt:38
msgid ""
"The :doc:`introductory material </intro/index>` is designed for people new "
"to Django -- or to Web development in general. It doesn't cover anything in "
"depth, but instead gives a high-level overview of how developing in Django "
"\"feels\"."
msgstr ""
":doc:`소개 자료 </intro/index>`는 Django를 처음 접하는 사람들이나 일반적으로 웹 개발을 위해 고안되었습니다. "
"깊이있는 내용은 다루지 않지만 대신 장고의 개발이 어떻게 느껴지는 지에 대한 고차원적인 개요를 제공합니다."

#: ../../intro/whatsnext.txt:43
msgid ""
"The :doc:`topic guides </topics/index>`, on the other hand, dive deep into "
"individual parts of Django. There are complete guides to Django's "
":doc:`model system </topics/db/index>`, :doc:`template engine "
"</topics/templates>`, :doc:`forms framework </topics/forms/index>`, and much"
" more."
msgstr ""
"반면에:doc:`주제 가이드 </topics/index>`는 장고의 각 부분에 깊이 들어가 있습니다. Django에 대한 완전한 가이드가"
" 있습니다:doc:`모델 시스템 </topics/db/index>``,``doc engine``/forms/forms/`, 그리고 훨씬 "
"더."

#: ../../intro/whatsnext.txt:49
msgid ""
"This is probably where you'll want to spend most of your time; if you work "
"your way through these guides you should come out knowing pretty much "
"everything there is to know about Django."
msgstr ""
"아마도 대부분의 시간을 보내고 싶어 할 것입니다. 이 가이드를 통해 길을 찾으면 장고에 대해 알아야 할 모든 것을 알게됩니다."

#: ../../intro/whatsnext.txt:53
msgid ""
"Web development is often broad, not deep -- problems span many domains. "
"We've written a set of :doc:`how-to guides </howto/index>` that answer "
"common \"How do I ...?\" questions. Here you'll find information about "
":doc:`generating PDFs with Django </howto/outputting-pdf>`, :doc:`writing "
"custom template tags </howto/custom-template-tags>`, and more."
msgstr ""
"웹 개발은 종종 광범위하지 않고 심층적이지 않은 문제는 많은 영역에 걸쳐 있습니다. 우리는 공통적 인 \"어떻게해야합니까?\"라고 답하는"
" doc:`how-to 가이드 </howto/index> '세트를 작성했습니다. 질문. doc:`Django로 PDF 생성하기 "
"</howto/outputs-pdf>`,:doc:`사용자 정의 템플릿 태그 작성하기 </howto/custom-template-tags>"
" '등의 정보를 찾을 수 있습니다."

#: ../../intro/whatsnext.txt:59
msgid ""
"Answers to really common questions can also be found in the :doc:`FAQ "
"</faq/index>`."
msgstr "정말로 일반적인 질문에 대한 답은:doc:`FAQ </faq/index>`에서도 찾을 수 있습니다."

#: ../../intro/whatsnext.txt:62
msgid ""
"The guides and how-to's don't cover every single class, function, and method"
" available in Django -- that would be overwhelming when you're trying to "
"learn. Instead, details about individual classes, functions, methods, and "
"modules are kept in the :doc:`reference </ref/index>`. This is where you'll "
"turn to find the details of a particular function or whatever you need."
msgstr ""
"가이드와 하우투는 장고에서 사용 가능한 모든 클래스, 함수 및 메소드를 다루지는 않습니다. 배우려고 할 때 압도적 인 것입니다. 대신 "
"개별 클래스, 함수, 메소드 및 모듈에 대한 세부 정보는:doc:`reference </ref/index> '에 보관됩니다. 여기서 특정"
" 기능 또는 원하는 기능의 세부 정보를 찾을 수 있습니다."

#: ../../intro/whatsnext.txt:69
msgid ""
"If you are interested in deploying a project for public use, our docs have "
":doc:`several guides</howto/deployment/index>` for various deployment setups"
" as well as a :doc:`deployment checklist</howto/deployment/checklist>` for "
"some things you'll need to think about."
msgstr ""
"공개용으로 프로젝트를 배포하는 데 관심이있는 경우, doc::deployment checklist "
"</howto/deployment/index>뿐만 아니라 다양한 배포 설정을위한 doc:`여러 가이드 "
"</howto/deployment/index> 체크리스트>를 선택하십시오."

#: ../../intro/whatsnext.txt:74
msgid ""
"Finally, there's some \"specialized\" documentation not usually relevant to "
"most developers. This includes the :doc:`release notes </releases/index>` "
"and :doc:`internals documentation </internals/index>` for those who want to "
"add code to Django itself, and a :doc:`few other things that simply don't "
"fit elsewhere </misc/index>`."
msgstr ""
"마지막으로, 대부분의 개발자와 관련이없는 \"전문화 된\"문서가 있습니다. 이것은 장고 자체에 코드를 추가하고자하는 사람들을 "
"위해:doc:`release notes </releases/index>`와:doc:`internals documentation "
"</internals/index> '를 포함하고 있습니다:단순히 다른 곳에 적합하지 않은 </misc/index>`."

#: ../../intro/whatsnext.txt:82
msgid "How documentation is updated"
msgstr "설명서 업데이트 방법"

#: ../../intro/whatsnext.txt:84
msgid ""
"Just as the Django code base is developed and improved on a daily basis, our"
" documentation is consistently improving. We improve documentation for "
"several reasons:"
msgstr ""
"Django 코드 기반이 매일 개발되고 개선되는 것처럼 우리의 문서는 지속적으로 개선되고 있습니다. 몇 가지 이유로 문서를 개선합니다."

#: ../../intro/whatsnext.txt:88
msgid "To make content fixes, such as grammar/typo corrections."
msgstr "문법/오타 수정과 같은 내용 수정."

#: ../../intro/whatsnext.txt:90
msgid ""
"To add information and/or examples to existing sections that need to be "
"expanded."
msgstr "확장해야 할 기존 섹션에 정보 및/또는 예제를 추가합니다."

#: ../../intro/whatsnext.txt:93
msgid ""
"To document Django features that aren't yet documented. (The list of such "
"features is shrinking but exists nonetheless.)"
msgstr "아직 문서화되지 않은 Django 기능을 문서화합니다. (이러한 기능 목록은 줄어들지 만 그럼에도 불구하고 존재합니다.)"

#: ../../intro/whatsnext.txt:96
msgid ""
"To add documentation for new features as new features get added, or as "
"Django APIs or behaviors change."
msgstr "새로운 기능이 추가되거나 Django API 또는 동작이 변경됨에 따라 새로운 기능에 대한 문서를 추가 할 수 있습니다."

#: ../../intro/whatsnext.txt:99
msgid ""
"Django's documentation is kept in the same source control system as its "
"code. It lives in the `docs`_ directory of our Git repository. Each document"
" online is a separate text file in the repository."
msgstr ""
"Django의 문서는 코드와 동일한 소스 제어 시스템에 보관됩니다. 그것은 Git 저장소의`docs`_ 디렉토리에 있습니다. 온라인상의 "
"각 문서는 저장소에있는 별도의 텍스트 파일입니다."

#: ../../intro/whatsnext.txt:106
msgid "Where to get it"
msgstr "어디서 구할 수 있습니까?"

#: ../../intro/whatsnext.txt:108
msgid ""
"You can read Django documentation in several ways. They are, in order of "
"preference:"
msgstr "Django 문서는 여러 가지 방법으로 읽을 수 있습니다. 그들은 선호 순서대로:"

#: ../../intro/whatsnext.txt:112
msgid "On the Web"
msgstr "웹에서"

#: ../../intro/whatsnext.txt:114
msgid ""
"The most recent version of the Django documentation lives at "
"https://docs.djangoproject.com/en/dev/. These HTML pages are generated "
"automatically from the text files in source control. That means they reflect"
" the \"latest and greatest\" in Django -- they include the very latest "
"corrections and additions, and they discuss the latest Django features, "
"which may only be available to users of the Django development version. (See"
" \"Differences between versions\" below.)"
msgstr ""
"가장 최신 버전의 Django 문서는 https://docs.djangoproject.com/en/dev/에 있습니다. 이러한 HTML "
"페이지는 소스 제어의 텍스트 파일에서 자동으로 생성됩니다. 즉, Django에서 \"가장 최신이고 최고의\"것을 반영합니다. 최신 수정 "
"사항과 추가 사항이 포함되어 있으며 Django 개발 버전 사용자 만 사용할 수있는 최신 Django 기능에 대해 논의합니다. 아래 "
"\"버전 간 차이점\"을 참조하십시오."

#: ../../intro/whatsnext.txt:122
msgid ""
"We encourage you to help improve the docs by submitting changes, corrections"
" and suggestions in the `ticket system`_. The Django developers actively "
"monitor the ticket system and use your feedback to improve the documentation"
" for everybody."
msgstr ""
"'티켓 시스템'_에서 변경 사항, 수정 사항 및 제안 사항을 제출하여 문서 개선에 도움을 받으시기 바랍니다. Django 개발자는 티켓 "
"시스템을 적극적으로 모니터링하고 여러분의 피드백을 사용하여 모든 사람의 문서를 개선합니다."

#: ../../intro/whatsnext.txt:126
msgid ""
"Note, however, that tickets should explicitly relate to the documentation, "
"rather than asking broad tech-support questions. If you need help with your "
"particular Django setup, try the |django-users| mailing list or the `#django"
" IRC channel`_ instead."
msgstr ""
"그러나 티켓은 광범위한 기술 지원 질문을하기보다는 문서와 명시 적으로 관련되어야합니다. 특정 장고 설정에 대한 도움이 필요하면 "
"django-users | 메일 링리스트 또는`"

#: ../../intro/whatsnext.txt:135
msgid "In plain text"
msgstr "일반 텍스트"

#: ../../intro/whatsnext.txt:137
msgid ""
"For offline reading, or just for convenience, you can read the Django "
"documentation in plain text."
msgstr "오프라인 읽기 또는 편의를 위해 Django 문서를 일반 텍스트로 읽을 수 있습니다."

#: ../../intro/whatsnext.txt:140
msgid ""
"If you're using an official release of Django, note that the zipped package "
"(tarball) of the code includes a ``docs/`` directory, which contains all the"
" documentation for that release."
msgstr ""
"Django의 공식 릴리스를 사용하는 경우 코드의 압축 패키지 (tarball)에는 해당 릴리스의 모든 설명서가 들어있는 "
"\"docs/\"디렉토리가 포함되어 있습니다."

#: ../../intro/whatsnext.txt:144
msgid ""
"If you're using the development version of Django (aka \"trunk\"), note that"
" the ``docs/`` directory contains all of the documentation. You can update "
"your Git checkout to get the latest changes."
msgstr ""
"Django (일명 \"트렁크\")의 개발 버전을 사용하고 있다면,``docs/``디렉토리에는 모든 문서가 들어 있습니다. Git 체크 "
"아웃을 업데이트하여 최신 변경 사항을 적용 할 수 있습니다."

#: ../../intro/whatsnext.txt:148
msgid ""
"One low-tech way of taking advantage of the text documentation is by using "
"the Unix ``grep`` utility to search for a phrase in all of the "
"documentation. For example, this will show you each mention of the phrase "
"\"max_length\" in any Django document:"
msgstr ""
"텍스트 문서를 활용하는 하나의 최첨단 기술은 Unix의``grep`` 유틸리티를 사용하여 모든 문서에서 문구를 검색하는 것입니다. 예를 "
"들어 Django 문서에서 \"max_length\"라는 문구를 볼 수 있습니다:"

#: ../../intro/whatsnext.txt:158
msgid "As HTML, locally"
msgstr "로컬 HTML"

#: ../../intro/whatsnext.txt:160
msgid ""
"You can get a local copy of the HTML documentation following a few easy "
"steps:"
msgstr "몇 가지 간단한 단계를 거치면 HTML 문서의 로컬 복사본을 얻을 수 있습니다."

#: ../../intro/whatsnext.txt:162
msgid ""
"Django's documentation uses a system called Sphinx__ to convert from plain "
"text to HTML. You'll need to install Sphinx by either downloading and "
"installing the package from the Sphinx website, or with ``pip``:"
msgstr ""
"Django의 문서에서는 Sphinx__이라는 시스템을 사용하여 일반 텍스트를 HTML로 변환합니다. Sphinx 웹 사이트에서 패키지를"
" 다운로드하고 설치하거나 \"pip\"로 설치해야합니다:"

#: ../../intro/whatsnext.txt:170
msgid ""
"Then, just use the included ``Makefile`` to turn the documentation into "
"HTML:"
msgstr "그런 다음, 포함 된``Makefile``을 사용하여 문서를 HTML로 변환하십시오:"

#: ../../intro/whatsnext.txt:178
msgid "You'll need `GNU Make`__ installed for this."
msgstr "이것을 위해`GNU Make`__가 설치되어 있어야합니다."

#: ../../intro/whatsnext.txt:180
msgid ""
"If you're on Windows you can alternatively use the included batch file:"
msgstr "Windows를 사용하는 경우 포함 된 배치 파일을 대신 사용할 수 있습니다."

#: ../../intro/whatsnext.txt:187
msgid "The HTML documentation will be placed in ``docs/_build/html``."
msgstr "HTML 문서는``docs/_build/html``에 있습니다."

#: ../../intro/whatsnext.txt:195
msgid "Differences between versions"
msgstr "버전 간 차이점"

#: ../../intro/whatsnext.txt:197
msgid ""
"As previously mentioned, the text documentation in our Git repository "
"contains the \"latest and greatest\" changes and additions. These changes "
"often include documentation of new features added in the Django development "
"version -- the Git (\"trunk\") version of Django. For that reason, it's "
"worth pointing out our policy on keeping straight the documentation for "
"various versions of the framework."
msgstr ""
"앞에서 언급했듯이 Git 저장소의 텍스트 문서에는 \"최신의 가장 큰 변경 사항 및 추가 사항\"이 포함되어 있습니다. 이러한 변경 "
"사항에는 Django 개발 버전 (Django의 Git ( \"trunk\") 버전)에 추가 된 새로운 기능에 대한 문서가 포함되어 "
"있습니다. 이러한 이유로 여러 버전의 프레임 워크에 대한 문서를 곧바로 유지하는 정책을 지적하는 것이 중요합니다."

#: ../../intro/whatsnext.txt:204
msgid "We follow this policy:"
msgstr "우리는이 정책을 따른다."

#: ../../intro/whatsnext.txt:206
msgid ""
"The primary documentation on djangoproject.com is an HTML version of the "
"latest docs in Git. These docs always correspond to the latest official "
"Django release, plus whatever features we've added/changed in the framework "
"*since* the latest release."
msgstr ""
"djangoproject.com의 기본 문서는 Git의 최신 문서의 HTML 버전입니다. 이 문서들은 항상 최신 공식 Django "
"릴리즈와, 최신 릴리즈 이후 프레임 워크에서 추가/변경 한 기능에 해당합니다."

#: ../../intro/whatsnext.txt:211
msgid ""
"As we add features to Django's development version, we try to update the "
"documentation in the same Git commit transaction."
msgstr "Django의 개발 버전에 기능을 추가 할 때 동일한 Git commit 트랜잭션으로 문서를 업데이트하려고합니다."

#: ../../intro/whatsnext.txt:214
msgid ""
"To distinguish feature changes/additions in the docs, we use the phrase: "
"\"New in version X.Y\", being X.Y the next release version (hence, the one "
"being developed)."
msgstr ""
"문서에서 기능 변경/추가를 구별하기 위해 \"버전 X.Y의 새로운 기능\"이라는 문구를 사용합니다. 다음 릴리스 버전 (따라서 개발되는 "
"버전)은 X.Y입니다."

#: ../../intro/whatsnext.txt:218
msgid ""
"Documentation fixes and improvements may be backported to the last release "
"branch, at the discretion of the committer, however, once a version of "
"Django is :ref:`no longer supported<backwards-compatibility-policy>`, that "
"version of the docs won't get any further updates."
msgstr ""
"그러나 Django 버전이 ref:`더 이상 지원되지 않는 <backwards-compatibility-policy> '가되면, 그 "
"문서의 원 버전은 마지막 릴리즈 지점으로 백 포트 될 수 있습니다. 더 이상의 업데이트가 없습니다."

#: ../../intro/whatsnext.txt:223
msgid ""
"The `main documentation Web page`_ includes links to documentation for all "
"previous versions. Be sure you are using the version of the docs "
"corresponding to the version of Django you are using!"
msgstr ""
"`주요 문서 웹 페이지`_에는 모든 이전 버전의 문서에 대한 링크가 포함되어 있습니다. 사용중인 장고 버전에 해당하는 문서 버전을 "
"사용하고 있는지 확인하십시오!"
