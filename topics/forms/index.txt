==================
폼을 가지고 작업하기
==================

.. admonition:: 이 문서에 대하여

    이 문서는 Django의 폼 처리 기능에 대해 안내합니다.
    폼 API의 특정한 부분에 대해 자세히 살펴보려면 
    :doc:`/ref/forms/api`, :doc:`/ref/forms/fields`,
    :doc:`/ref/forms/validation`\ 를 참고하세요.

.. highlightlang:: html+django

``django.forms``\ 은 Django의 폼 처리 라이브러리입니다.

Django의 :class:`~django.http.HttpRequest` 클래스를 사용하여 폼 제출을 처리할 수도 있기는 하지만, 폼 라이브러리를 사용하려면 폼에 관련된 많은 일반적인 작업에 신경을 써야 합니다. 그것을 사용하면,

1. 자동으로 생성된 폼 위젯을 통해 HTML 폼을 표시할 수 있습니다.
2. 제출된 데이터를 검증 규칙에 비추어 확인할 수 있습니다.
3. 검증 오류의 경우에는 폼을 다시 표시합니다.
4. 제출된 폼 데이터를 그에 관련된 파이썬 자료형으로 변환합니다.

개요
========

폼 라이브러리는 이러한 개념을 다룹니다.

.. glossary::

    Widget
        ``<input type="text">`` 또는 ``<textarea>``\ 와 같이 HTML 폼 위젯에 대응되는 클래스. 위젯을 HTML로 렌더링하는 것을 처리.

    Field
        유효성 검증을 담당하는 클래스. 예를 들어, ``EmailField``\ 는 데이터가 유효한 이메일 주소인지 확인함.

    Form
        그 자체에 대한 유효성 검증 규칙 및 HTML로서의 표시 방법을 알고 있는 필드의 모음.

    Form Media
        폼을 렌더하기 위해 필요한 CSS와 JavaScript 자원.

폼 라이브러리는 데이터베이스 계층, 뷰 및 템플릿과 같은 Django 구성요소로부터 분리되어 있습니다. 의존성을 갖는 것은 Django 설정과, 두 개의
``django.utils`` 도움 함수와 Django의 국제화 훅 뿐입니다(하지만 이 라이브러리를 사용하기 위해서 국제화 기능을 사용하여야하는 것은 아닙니다).

폼 개체
============

폼 개체는, 폼이 받아들여지기 위해 반드시 갖추어야 하는 폼 필드의 순서와 유효성 검증 규칙의 모음을 캡슐화합니다.
폼 클래스는 ``django.forms.Form``\ 의 하위 클래스로서 생성되며 선언적인 스타일을 사용합니다. 이러한 스타일은 Django의 데이터베이스 모델을 사용해보았다면 익숙할 것입니다.

예로서, "contact me" 기능을 구현하기 위해서 폼을 사용하는 것을 고려해봅시다.

.. code-block:: python

    from django import forms

    class ContactForm(forms.Form):
        subject = forms.CharField(max_length=100)
        message = forms.CharField()
        sender = forms.EmailField()
        cc_myself = forms.BooleanField(required=False)

폼은 ``Field`` 개체들로 구성됩니다. 예제에서는 폼에 ``subject``, ``message``, ``sender`` 그리고 ``cc_myself``\ 까지 네 개의 필드가 있습니다. ``CharField``, ``EmailField`` 그리고 ``BooleanField``\ 의 세 가지 필드 유형을 사용할 수 있습니다. 전체 목록은 :doc:`/ref/forms/fields`\ 에서 찾을 수 있습니다.

폼을 Django 모델에 직접적으로 추가 또는 수정하는 데에 사용하려면, :doc:`ModelForm </topics/forms/modelforms>`\ 을 사용하여 모델 설명의 중복을 피할 수 있습니다.

뷰에서 폼을 사용하기
----------------------

뷰에서 폼을 처리하기 위한 일반적인 패턴은 다음과 같습니다.

.. code-block:: python

   def contact(request):
       if request.method == 'POST': # If the form has been submitted...
           form = ContactForm(request.POST) # A form bound to the POST data
           if form.is_valid(): # All validation rules pass
               # Process the data in form.cleaned_data
               # ...
               return HttpResponseRedirect('/thanks/') # Redirect after POST
       else:
           form = ContactForm() # An unbound form

       return render_to_response('contact.html', {
           'form': form,
       })


다음과 같은 세 코드 경로가 있습니다.

1. 폼이 아직 제출되지 않았을 경우, 바인드되지 않은 ContactForm이 생성되어 템플릿에 전달됩니다.
2. 폼이 제출된 경우, 폼의 바인드된 인스턴스가 ``request.POST``\ 를 사용하여 생성됩니다. 제출된 자료가 유효한 경우에는 처리되어 사용자에게 "thanks" 페이지가 리다이렉트됩니다.
3. 폼이 제출되었지만 유효하지 않은 경우, 바인드된 폼 인스턴스가 템플릿에 전달됩니다.

**바인드된(bound)** 폼과 **바인드되지 않은(unbound)** 폼의 차이는 중요합니다. 바인드되지 않은 폼은 그에 연관된 어떠한 데이터도 갖지 않으며, 사용자에게 렌더될 때에는 비어 있거나 기본값을 갖습니다. 바인드된 폼은 제출된 자료를 갖고 있으며, 자료가 유효한지 사용자에게 알려줄 수 있습니다. 유효하지 않은 바인드된 폼이 렌더될 때는, 사용자에게 무엇이 잘못되었는지 알리는 오류 메시지를 포함할 수 있습니다.

바인드된 폼과 바인드되지 않은 폼 사이의 차이점에 대한 자세한 정보는 :ref:`ref-forms-api-bound-unbound`\ 를 참고하세요.

폼으로 파일 업로드 다루기
---------------------------------

폼을 통해 파일 업로드를 다루는 방법은 :ref:`binding-uploaded-files`\ 에서 볼 수 있습니다.

Processing the data from a form
-------------------------------

Once ``is_valid()`` returns ``True``, you can process the form submission safe
in the knowledge that it conforms to the validation rules defined by your form.
While you could access ``request.POST`` directly at this point, it is better to
access ``form.cleaned_data``. This data has not only been validated but will
also be converted in to the relevant Python types for you. In the above example,
``cc_myself`` will be a boolean value. Likewise, fields such as ``IntegerField``
and ``FloatField`` convert values to a Python int and float respectively. Note
that read-only fields are not available in ``form.cleaned_data`` (and setting
a value in a custom ``clean()`` method won't have any effect) because these
fields are displayed as text rather than as input elements, and thus are not
posted back to the server.

Extending the above example, here's how the form data could be processed:

.. code-block:: python

    if form.is_valid():
        subject = form.cleaned_data['subject']
        message = form.cleaned_data['message']
        sender = form.cleaned_data['sender']
        cc_myself = form.cleaned_data['cc_myself']

        recipients = ['info@example.com']
        if cc_myself:
            recipients.append(sender)

        from django.core.mail import send_mail
        send_mail(subject, message, sender, recipients)
        return HttpResponseRedirect('/thanks/') # Redirect after POST

For more on sending email from Django, see :doc:`/topics/email`.

Displaying a form using a template
----------------------------------

Forms are designed to work with the Django template language. In the above
example, we passed our ``ContactForm`` instance to the template using the
context variable ``form``. Here's a simple example template::

    <form action="/contact/" method="post">{% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="Submit" />
    </form>

The form only outputs its own fields; it is up to you to provide the surrounding
``<form>`` tags and the submit button.

.. admonition:: Forms and Cross Site Request Forgery protection

   Django ships with an easy-to-use :doc:`protection against Cross Site Request
   Forgeries </ref/contrib/csrf>`. When submitting a form via POST with
   CSRF protection enabled you must use the :ttag:`csrf_token` template tag
   as in the preceding example. However, since CSRF protection is not
   directly tied to forms in templates, this tag is omitted from the
   following examples in this document.

``form.as_p`` will output the form with each form field and accompanying label
wrapped in a paragraph. Here's the output for our example template::

   <form action="/contact/" method="post">
   <p><label for="id_subject">Subject:</label>
       <input id="id_subject" type="text" name="subject" maxlength="100" /></p>
   <p><label for="id_message">Message:</label>
       <input type="text" name="message" id="id_message" /></p>
   <p><label for="id_sender">Sender:</label>
       <input type="text" name="sender" id="id_sender" /></p>
   <p><label for="id_cc_myself">Cc myself:</label>
       <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>
   <input type="submit" value="Submit" />
   </form>

Note that each form field has an ID attribute set to ``id_<field-name>``, which
is referenced by the accompanying label tag. This is important for ensuring
forms are accessible to assistive technology such as screen reader software. You
can also :ref:`customize the way in which labels and ids are generated
<ref-forms-api-configuring-label>`.

You can also use ``form.as_table`` to output table rows (you'll need to provide
your own ``<table>`` tags) and ``form.as_ul`` to output list items.

Customizing the form template
-----------------------------

If the default generated HTML is not to your taste, you can completely customize
the way a form is presented using the Django template language. Extending the
above example::

    <form action="/contact/" method="post">
        {{ form.non_field_errors }}
        <div class="fieldWrapper">
            {{ form.subject.errors }}
            <label for="id_subject">Email subject:</label>
            {{ form.subject }}
        </div>
        <div class="fieldWrapper">
            {{ form.message.errors }}
            <label for="id_message">Your message:</label>
            {{ form.message }}
        </div>
        <div class="fieldWrapper">
            {{ form.sender.errors }}
            <label for="id_sender">Your email address:</label>
            {{ form.sender }}
        </div>
        <div class="fieldWrapper">
            {{ form.cc_myself.errors }}
            <label for="id_cc_myself">CC yourself?</label>
            {{ form.cc_myself }}
        </div>
        <p><input type="submit" value="Send message" /></p>
    </form>

Each named form-field can be output to the template using
``{{ form.name_of_field }}``, which will produce the HTML needed to display the
form widget. Using ``{{ form.name_of_field.errors }}`` displays a list of form
errors, rendered as an unordered list. This might look like::

   <ul class="errorlist">
       <li>Sender is required.</li>
   </ul>

The list has a CSS class of ``errorlist`` to allow you to style its appearance.
If you wish to further customize the display of errors you can do so by looping
over them::

    {% if form.subject.errors %}
        <ol>
        {% for error in form.subject.errors %}
            <li><strong>{{ error|escape }}</strong></li>
        {% endfor %}
        </ol>
    {% endif %}

Looping over the form's fields
------------------------------

If you're using the same HTML for each of your form fields, you can reduce
duplicate code by looping through each field in turn using a ``{% for %}``
loop::

    <form action="/contact/" method="post">
        {% for field in form %}
            <div class="fieldWrapper">
                {{ field.errors }}
                {{ field.label_tag }}: {{ field }}
            </div>
        {% endfor %}
        <p><input type="submit" value="Send message" /></p>
    </form>

Within this loop, ``{{ field }}`` is an instance of :class:`BoundField`.
``BoundField`` also has the following attributes, which can be useful in your
templates:

``{{ field.label }}``
    The label of the field, e.g. ``Email address``.

``{{ field.label_tag }}``
    The field's label wrapped in the appropriate HTML ``<label>`` tag,
    e.g. ``<label for="id_email">Email address</label>``

``{{ field.value }}`` 
    The value of the field. e.g ``someone@example.com``

``{{ field.html_name }}``
    The name of the field that will be used in the input element's name
    field. This takes the form prefix into account, if it has been set.

``{{ field.help_text }}``
    Any help text that has been associated with the field.

``{{ field.errors }}``
    Outputs a ``<ul class="errorlist">`` containing any validation errors
    corresponding to this field. You can customize the presentation of
    the errors with a ``{% for error in field.errors %}`` loop. In this
    case, each object in the loop is a simple string containing the error
    message.

``field.is_hidden``
    This attribute is ``True`` if the form field is a hidden field and
    ``False`` otherwise. It's not particularly useful as a template
    variable, but could be useful in conditional tests such as::

        {% if field.is_hidden %}
           {# Do something special #}
        {% endif %}

Looping over hidden and visible fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're manually laying out a form in a template, as opposed to relying on
Django's default form layout, you might want to treat ``<input type="hidden">``
fields differently than non-hidden fields. For example, because hidden fields
don't display anything, putting error messages "next to" the field could cause
confusion for your users -- so errors for those fields should be handled
differently.

Django provides two methods on a form that allow you to loop over the hidden
and visible fields independently: ``hidden_fields()`` and
``visible_fields()``. Here's a modification of an earlier example that uses
these two methods::

    <form action="/contact/" method="post">
        {# Include the hidden fields #}
        {% for hidden in form.hidden_fields %}
        {{ hidden }}
        {% endfor %}
        {# Include the visible fields #}
        {% for field in form.visible_fields %}
            <div class="fieldWrapper">
                {{ field.errors }}
                {{ field.label_tag }}: {{ field }}
            </div>
        {% endfor %}
        <p><input type="submit" value="Send message" /></p>
    </form>

This example does not handle any errors in the hidden fields. Usually, an
error in a hidden field is a sign of form tampering, since normal form
interaction won't alter them. However, you could easily insert some error
displays for those form errors, as well.

Reusable form templates
-----------------------

If your site uses the same rendering logic for forms in multiple places, you
can reduce duplication by saving the form's loop in a standalone template and
using the :ttag:`include` tag to reuse it in other templates::

    <form action="/contact/" method="post">
        {% include "form_snippet.html" %}
        <p><input type="submit" value="Send message" /></p>
    </form>

    # In form_snippet.html:

    {% for field in form %}
        <div class="fieldWrapper">
            {{ field.errors }}
            {{ field.label_tag }}: {{ field }}
        </div>
    {% endfor %}

If the form object passed to a template has a different name within the
context, you can alias it using the ``with`` argument of the :ttag:`include`
tag::

    <form action="/comments/add/" method="post">
        {% include "form_snippet.html" with form=comment_form %}
        <p><input type="submit" value="Submit comment" /></p>
    </form>

If you find yourself doing this often, you might consider creating a custom
:ref:`inclusion tag<howto-custom-template-tags-inclusion-tags>`.

Further topics
==============

This covers the basics, but forms can do a whole lot more:

.. toctree::
   :maxdepth: 2

   formsets
   modelforms
   media

.. seealso::

    :doc:`The Forms Reference </ref/forms/index>`
        Covers the full API reference, including form fields, form widgets,
        and form and field validation.
