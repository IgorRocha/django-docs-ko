=====================================
첫번째 장고 앱 만들기! part 4
====================================

본 자습서는 :doc:`Tutorial 3 </intro/tutorial03>`\ 에 이어서 계속 됩니다. 우리는 웹 설문조사 어플리케이션을 만들고 있고,  우리 코드의 양을 줄이고, 간단한 폼처리를 하는데 초점을 맞출 것 입니다.

간단한 폼 사용하기.
===================

HTML ``<form>`` 요소를 포함하고 있는 앞 장에서 사용한 설문조사 세부 템플릿을 수정하자:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>

    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

    <form action="/polls/{{ poll.id }}/vote/" method="post">
    {% csrf_token %}
    {% for choice in poll.choice_set.all %}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
        <label for="choice{{ forloop.counter }}">{{ choice.choice }}</label><br />
    {% endfor %}
    <input type="submit" value="Vote" />
    </form>

간략하게 설명하면:

* 위의 템플릿은 각 설문 선택지의 라디오버튼을 표시한다. The
  ``value`` of each radio button is the associated poll choice's ID. The
  ``name`` of each radio button is ``"choice"``. That means, when somebody
  selects one of the radio buttons and submits the form, it'll send the
  POST data ``choice=3``. 이것이 HTML Forms 101 이다.

* We set the form's ``action`` to ``/polls/{{ poll.id }}/vote/``, and we
  set ``method="post"``. Using ``method="post"`` (as opposed to
  ``method="get"``) is very important, because the act of submitting this
  form will alter data server-side. Whenever you create a form that alters
  data server-side, use ``method="post"``. This tip isn't specific to
  Django; it's just good Web development practice.

* ``forloop.counter`` indicates how many times the :ttag:`for` tag has gone
  through its loop

* Since we're creating a POST form (which can have the effect of modifying
  data), we need to worry about Cross Site Request Forgeries.
  Thankfully, you don't have to worry too hard, because Django comes with
  a very easy-to-use system for protecting against it. In short, all POST
  forms that are targeted at internal URLs should use the
  :ttag:`{% csrf_token %}<csrf_token>` template tag.

The :ttag:`{% csrf_token %}<csrf_token>` tag requires information from the
request object, which is not normally accessible from within the template
context. To fix this, a small adjustment needs to be made to the ``detail``
view, so that it looks like the following::

    from django.template import RequestContext
    # ...
    def detail(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        return render_to_response('polls/detail.html', {'poll': p},
                                   context_instance=RequestContext(request))

이것이 작동하는 것에 대한 자세한 내용은 :ref:`RequestContext <subclassing-context-requestcontext>` 부분의 문서를 참고하라.

이제 전송된 자료를 다룰 장고 뷰를 만들고, 그것을 가지고 무엇인가를 해보자. :doc:`자습서 3 </intro/tutorial03>`\ 에서 이 라인을 포함하는 설물조사 어플리케이션을 위해 URLconf를 만들것을 기억하라::

    (r'^(?P<poll_id>\d+)/vote/$', 'vote'),

또, 우리는 ``vote()``\ 더미의 실행 함수를 만들었다. 실제 버전을 만들어보자. ``polls/views.py``\ 에 다음을 추가하자::

    from django.shortcuts import get_object_or_404, render_to_response
    from django.http import HttpResponseRedirect, HttpResponse
    from django.core.urlresolvers import reverse
    from django.template import RequestContext
    from polls.models import Choice, Poll
    # ...
    def vote(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        try:
            selected_choice = p.choice_set.get(pk=request.POST['choice'])
        except (KeyError, Choice.DoesNotExist):
            # 설문조사 폼을 다시 보여주기.
            return render_to_response('polls/detail.html', {
                'poll': p,
                'error_message': "You didn't select a choice.",
            }, context_instance=RequestContext(request))
        else:
            selected_choice.votes += 1
            selected_choice.save()
            # 전송된 POST 자료를 성공적으로 처리한 뒤에는 항상 HttpResponseRedirect를 반환하라.
            # with POST data. This prevents data from being posted twice if a
            # 자료가 두 번 전송되는 경우를 막아준다.
            return HttpResponseRedirect(reverse('polls.views.results', args=(p.id,)))

위 코드는 이 자습서에서 아직 다루지 않은 몇 가지를 포함하고 있다:

* :attr:`request.POST <django.http.HttpRequest.POST>` is a dictionary-like
  object that lets you access submitted data by key name. In this case,
  ``request.POST['choice']`` returns the ID of the selected choice, as a
  string. :attr:`request.POST <django.http.HttpRequest.POST>` values are
  always strings.

  Note that Django also provides :attr:`request.GET
  <django.http.HttpRequest.GET>` for accessing GET data in the same way --
  but we're explicitly using :attr:`request.POST
  <django.http.HttpRequest.POST>` in our code, to ensure that data is only
  altered via a POST call.

* 만약 POST 자료에 ``choice``\ 가 없으면, ``request.POST['choice']``\
  는 :exc:`KeyError`\ 를 일으킨다. 위의 코드는 :exc:`KeyError`\ 를 체크하고, ``choice``\ 가 주어지지 않은 경우에는
  설문조사 양식을 다시보여준다.

* 설문지의 수가 증가한 이후에, 코드는 평범한 
  :class:`~django.http.HttpResponse` 보다는 
  :class:`~django.http.HttpResponseRedirect`\ 를 반환한다  :class:`~django.http.HttpResponseRedirect`\ 는 하나의 인수를 받는다: 
  사용자가 재전송할 URL. (이 경우에 우리가 URL을 
  어떻게 구성하는지 다음 항목을 보라).

  위 소스안의 파이썬 주석내용대로, POST 자료를 성공적으로 처리한 후에는 항상
  :class:`~django.http.HttpResponseRedirect` after successfully dealing with
  POST data. 이것은 장고에만 특정한 팁이 아니다,
  좋은 웹 개발관례일 뿐이다.

* 우리는 이 예제에서  :class:`~django.http.HttpResponseRedirect` 생성자 안의 
  :func:`~django.core.urlresolvers.reverse` 함수를 사용하고 있다.
  이 함수는  함수에서 URL을 하드코딩하는 행위를 안하게 도와준다.
  제어를 전달하기 원하는 view의 이름을 제공하고, URL패턴의 변수부분이 그 뷰를 가리킨다.
  이 경우에, URLconf를 사용하여 우리는 자습서 3에서 설정하였다. In this
  case, using the URLconf we set up in Tutorial 3, this
  아래와 같은 문자열을 반환할 것이다.
  ::

    '/polls/3/results/'

  ... ``3``\ 은 ``p.id``\ 의 값이다. 이 리다이렉트된 URL은
  마지막 페이지를 보여주기위해 ``'results'`` 뷰를 호출한다. 뷰 이름(풀네임)을
   사용해야한다는 것을 주의하라(접두사를 포함하여).

자습서 3에서 언급했듯이, ``request``\ 은 :class:`~django.http.HttpRequest`\ 개체이다. :class:`~django.http.HttpRequest` 개체에 대해 더 알고 싶다면 :doc:`request and response documentation </ref/request-response>`\ 을 보라.

어떤 이가 설문조사에 설문을 하고난 뒤에는, ``vote()`` 뷰는 설문조사 결과 페이지로 리다이렉트한다. 그 뷰를 작성해보자::

    def results(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        return render_to_response('polls/results.html', {'poll': p})

이것은 :doc:`Tutorial 3</intro/tutorial03>`\ 의 ``detail()`` view와 거의 동일하다. 다른점은 템플릿 이름밖에 없다. 우리는 후에 이 쓸데없는 것들을 수정할 것이다.

이제, ``results.html`` 템플릿을 만들자:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>

    <ul>
    {% for choice in poll.choice_set.all %}
        <li>{{ choice.choice }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
    {% endfor %}
    </ul>

    <a href="/polls/{{ poll.id }}/">Vote again?</a>

이제, 웹브라주여에서 ``/polls/1/`` 페이지로 가자, 그리고 설문조사를 해보자. 당신이 설문조사를 할 때마다 값이 반영된 결과페이지를 볼것이다. 만약 당신이 설문지를 선택하지 않고 폼을 전송했다면, 에러메시지를 보게될 것이다.

제네릭 뷰 사용하기 : 적은 코드가 더 좋음
======================================

``detail()`` ( :doc:`자습 3 </intro/tutorial03>`\ 에서의) 과 ``results()``
뷰는 매우 비슷하다. -- 그리고, 위에서 언급한 것 처럼 장황하다. 설문 목록들을 보여주는 ``index()`` 뷰(이것도 자습서 3에서), 는 비슷하다.

이 뷰들은 기본적인 웹 개발의 일반적인 케이스들:(URL로 전달된 매개변수로부터 데이터베이스에서 자료를 얻고, 템플릿을 불러오며, 처리된 템플릿을 반환하는)을 제공한다. 매우 일반적인 것들이기 때문에, 장고는 "제네릭 뷰" 시스템이라 불리는 지름길을 제공한다.

앱을 쓰기위해 파이썬 코드를 쓸 필요가 없을 정도로 제네릭 뷰는 일반적인(역자주-중복되고, 장황한) 패턴들을 제거한다.

제네릭 뷰 시스템을 사용해서 우리의 설문자 앱을 바꿔보자. 그리고 우리의 코드를 삭제할 수도 있다. 변환하기에는 몇 단계를 거쳐야 한다. 우리는:

1. URLconf를 변환한다.

2. 오래되고 불필요한 뷰들 일부를 삭제한다.

3. 새로운 뷰들을 위해 URL 다루기를 수정한다.

자세한 내용을 읽어보라.

.. admonition:: 왜 코드 섞기(code-shuffle)(역자주:코드를 이렇게 저렇게 수정하는 것)인가?

    일반적으로, 장고 앱을 작성할 때, 당신은 제네릭 뷰가 당신의 문제에 
    잘 맞는지 평가할 것이고, 절반정도 작성된 당신의 코드를 
    리펙토링 하기보다는 처음부터 제네릭 뷰를 사용할 것이다. 그러나 이 자습서는
    지금까지 핵심개념들을 배우기위해 의도적으로 "힘든 방법으로",
    뷰 작성하기에 초점을 맞춰왔다.

    계산기를 사용하기전에 기본적인 산수를 알아야하지 않겠는가.

먼저, ``polls/urls.py``\ 의 URLconf를 보라. 지금까지의 자습서 내용대로라면 아래와 같은 내용이 보일것이다.

    from django.conf.urls import patterns, include, url

    urlpatterns = patterns('polls.views',
        url(r'^$', 'index'),
        url(r'^(?P<poll_id>\d+)/$', 'detail'),
        url(r'^(?P<poll_id>\d+)/results/$', 'results'),
        url(r'^(?P<poll_id>\d+)/vote/$', 'vote'),
    )

아래와 같이 변경하라::

    from django.conf.urls import patterns, include, url
    from django.views.generic import DetailView, ListView
    from polls.models import Poll

    urlpatterns = patterns('',
        url(r'^$',
            ListView.as_view(
                queryset=Poll.objects.order_by('-pub_date')[:5],
                context_object_name='latest_poll_list',
                template_name='polls/index.html')),
        url(r'^(?P<pk>\d+)/$',
            DetailView.as_view(
                model=Poll,
                template_name='polls/detail.html')),
        url(r'^(?P<pk>\d+)/results/$',
            DetailView.as_view(
                model=Poll,
                template_name='polls/results.html'),
            name='poll_results'),
        url(r'^(?P<poll_id>\d+)/vote/$', 'polls.views.vote'),
    )

여기에서 제네릭 뷰 두 개를 사용하고 있다: 
:class:`~django.views.generic.list.ListView` 와
:class:`~django.views.generic.detail.DetailView`.. 이 두 개의 뷰들은 각각, "개체들의 목록을 보여주기" 와 "개체의 특정한 형식에 맞춘 세부 페이지 보여주기" 란 개념을 가지고 있다. 

* 각 제네릭 뷰는 제네릭 뷰가 어떤 모델에 작용할지 알아야한다
  .. 그것은 ``model`` 파라미터를 사용하여 제공된다.

* :class:`~django.views.generic.list.DetailView` 제네릭 뷰는
  ``"pk"``라 불리는 URL에서 가져온 기본 키 값을 받을 준비를 하고 있다
  , 그래서 우리는 ``poll_id``\ 를  ``pk``\ 로 변경했다
  .

* 우리는 results 뷰에 ``poll_results``\ 란 이름을 추가했다,
  그렇게 하면 URL 이후에 오는 변수를 참조할 수 있게 된다.(
  이것에 관한 정보는 :ref:`naming URL patterns
  <naming-url-patterns>` 문서를 보라). We're also using the
  :func:`~django.conf.urls.url` function from
  :mod:`django.conf.urls` here. It's a good habit to use
  :func:`~django.conf.urls.url` when you are providing a
  pattern name like this.

By default, the :class:`~django.views.generic.list.DetailView` generic
view uses a template called ``<app name>/<model name>_detail.html``.
In our case, it'll use the template ``"polls/poll_detail.html"``. The
``template_name`` argument is used to tell Django to use a specific
template name instead of the autogenerated default template name. We
also specify the ``template_name`` for the ``results`` list view --
this ensures that the results view and the detail view have a
different appearance when rendered, even though they're both a
:class:`~django.views.generic.list.DetailView` behind the scenes.

Similarly, the :class:`~django.views.generic.list.ListView` generic
view uses a default template called ``<app name>/<model
name>_list.html``; we use ``template_name`` to tell
:class:`~django.views.generic.list.ListView` to use our existing
``"polls/index.html"`` template.

In previous parts of the tutorial, the templates have been provided
with a context that contains the ``poll`` and ``latest_poll_list``
context variables. For DetailView the ``poll`` variable is provided
automatically -- since we're using a Django model (``Poll``), Django
is able to determine an appropriate name for the context variable.
However, for ListView, the automatically generated context variable is
``poll_list``. To override this we provide the ``context_object_name``
option, specifying that we want to use ``latest_poll_list`` instead.
As an alternative approach, you could change your templates to match
the new default context variables -- but it's a lot easier to just
tell Django to use the variable you want.

You can now delete the ``index()``, ``detail()`` and ``results()``
views from ``polls/views.py``. We don't need them anymore -- they have
been replaced by generic views.

The last thing to do is fix the URL handling to account for the use of
generic views. In the vote view above, we used the
:func:`~django.core.urlresolvers.reverse` function to avoid
hard-coding our URLs. Now that we've switched to a generic view, we'll
need to change the :func:`~django.core.urlresolvers.reverse` call to
point back to our new generic view. We can't simply use the view
function anymore -- generic views can be (and are) used multiple times
-- but we can use the name we've given::

    return HttpResponseRedirect(reverse('poll_results', args=(p.id,)))

Run the server, and use your new polling app based on generic views.

For full details on generic views, see the :doc:`generic views documentation
</topics/http/generic-views>`.

Coming soon
===========

The tutorial ends here for the time being. Future installments of the tutorial
will cover:

* Advanced form processing
* Using the RSS framework
* Using the cache framework
* Using the comments framework
* Advanced admin features: Permissions
* Advanced admin features: Custom JavaScript

In the meantime, you might want to check out some pointers on :doc:`where to go
from here </intro/whatsnext>`
